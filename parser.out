Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; n_main_quad program1
Rule 2     n_main_quad -> <empty>
Rule 3     program1 -> var program1
Rule 4     program1 -> program2
Rule 5     program2 -> proc program2
Rule 6     program2 -> main
Rule 7     proc -> proca1 procA n_check_has_return
Rule 8     proc -> VOID proca2 procA
Rule 9     proc -> empty
Rule 10    n_check_has_return -> <empty>
Rule 11    proca2 -> ID (
Rule 12    proca1 -> datatype ID (
Rule 13    procA -> proc1 ) { proc3 }
Rule 14    proc1 -> n_push_variable proc2
Rule 15    proc1 -> empty
Rule 16    proc2 -> , n_push_variable proc2
Rule 17    proc2 -> empty
Rule 18    n_push_variable -> datatype ID
Rule 19    proc3 -> var proc3
Rule 20    proc3 -> n_quad_counter proc4
Rule 21    n_quad_counter -> <empty>
Rule 22    proc4 -> statement proc4
Rule 23    proc4 -> empty
Rule 24    vars -> var vars
Rule 25    vars -> var
Rule 26    var -> datatype var1
Rule 27    var1 -> ID , var1
Rule 28    var1 -> ID var2
Rule 29    var2 -> ;
Rule 30    assignment -> assignment2 ASSIGNATOR n_quad_assign expression
Rule 31    assignment2 -> ID
Rule 32    n_quad_assign -> <empty>
Rule 33    condition -> IF ( expression n_while_2 ) block condition1
Rule 34    condition1 -> ELSE n_if_2 block n_if_3
Rule 35    condition1 -> n_if_3
Rule 36    n_if_2 -> <empty>
Rule 37    n_if_3 -> <empty>
Rule 38    while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3
Rule 39    n_while_1 -> <empty>
Rule 40    n_while_2 -> <empty>
Rule 41    n_while_3 -> <empty>
Rule 42    input -> READ ( n_process_read input1 )
Rule 43    input1 -> , n_process_read input1
Rule 44    input1 -> empty
Rule 45    n_process_read -> ID
Rule 46    output -> PRINT ( n_output_quad output1 )
Rule 47    output1 -> , n_output_quad output1
Rule 48    output1 -> empty
Rule 49    n_output_quad -> expression
Rule 50    function_call -> n_era_size function_call1 )
Rule 51    n_era_size -> ID (
Rule 52    function_call1 -> empty
Rule 53    function_call1 -> function_call2
Rule 54    function_call2 -> n_verify_argument , n_add_one_to_counter function_call2
Rule 55    function_call2 -> n_verify_argument
Rule 56    n_add_one_to_counter -> <empty>
Rule 57    n_verify_argument -> expression
Rule 58    return -> RETURN expression
Rule 59    container_operation -> ID . OP_ARGS ( expression )
Rule 60    container_operation -> ID . OP ( )
Rule 61    statement -> statement1 ;
Rule 62    statement -> statement2
Rule 63    statement1 -> assignment
Rule 64    statement1 -> input
Rule 65    statement1 -> output
Rule 66    statement1 -> container_operation
Rule 67    statement1 -> map_definition
Rule 68    statement1 -> return
Rule 69    statement1 -> map_assignment
Rule 70    statement1 -> function_call
Rule 71    statement2 -> condition
Rule 72    statement2 -> while
Rule 73    relop -> <
Rule 74    relop -> >
Rule 75    relop -> NOT_EQ
Rule 76    relop -> EQ
Rule 77    relop -> LEQ
Rule 78    relop -> GEQ
Rule 79    logop -> OR
Rule 80    logop -> AND
Rule 81    expression -> exp0 expression2
Rule 82    expression2 -> logop exp0 n_quad_logop expression2
Rule 83    expression2 -> empty
Rule 84    n_quad_logop -> <empty>
Rule 85    exp0 -> exp exp02
Rule 86    exp02 -> relop exp
Rule 87    exp02 -> empty
Rule 88    exp -> term exp2
Rule 89    addsub -> +
Rule 90    addsub -> -
Rule 91    addsub -> SET_MATH_ADDSUB
Rule 92    muldiv -> *
Rule 93    muldiv -> /
Rule 94    muldiv -> SET_MATH_MULDIV
Rule 95    exp2 -> addsub term n_quad_addsub exp2
Rule 96    exp2 -> empty
Rule 97    term -> term_not factor n_quad_muldiv term2
Rule 98    n_quad_muldiv -> <empty>
Rule 99    n_quad_addsub -> <empty>
Rule 100   term2 -> muldiv factor n_quad_muldiv term2
Rule 101   term2 -> n_quad_not
Rule 102   n_quad_not -> <empty>
Rule 103   term_not -> !
Rule 104   term_not -> empty
Rule 105   factor -> ( n_push_false_bottom expression ) n_pop_false_bottom
Rule 106   factor -> varcte
Rule 107   n_push_false_bottom -> <empty>
Rule 108   n_pop_false_bottom -> <empty>
Rule 109   varcte -> ID empty
Rule 110   varcte -> varcte1
Rule 111   varcte1 -> CTE_INT
Rule 112   varcte1 -> CTE_FLOAT
Rule 113   varcte1 -> CTE_BOOL
Rule 114   varcte1 -> CTE_STRING
Rule 115   varcte1 -> CTE_CHAR
Rule 116   varcte1 -> function_call
Rule 117   varcte1 -> map_access
Rule 118   varcte1 -> container_operation
Rule 119   functype -> datatype
Rule 120   functype -> VOID
Rule 121   datatype -> INT
Rule 122   datatype -> FLOAT
Rule 123   datatype -> BOOL
Rule 124   datatype -> STRING
Rule 125   datatype -> CHAR
Rule 126   datatype -> set_definition
Rule 127   datatype -> map_definition
Rule 128   set_definition -> SET < datatype >
Rule 129   block -> { statement_aux }
Rule 130   statement_aux -> statement statement_aux
Rule 131   statement_aux -> empty
Rule 132   main -> MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux }
Rule 133   n_main_quad2 -> <empty>
Rule 134   n_clear_scope -> <empty>
Rule 135   vars_aux -> vars
Rule 136   vars_aux -> empty
Rule 137   map_definition -> MAP < datatype , datatype >
Rule 138   map_access -> ID [ expression ]
Rule 139   map_assignment -> map_access ASSIGNATOR n_quad_assign exp
Rule 140   empty -> <empty>

Terminals, with rules where they appear

!                    : 103
(                    : 11 12 33 38 42 46 51 59 60 105
)                    : 13 33 38 42 46 50 59 60 105
*                    : 92
+                    : 89
,                    : 16 27 43 47 54 137
-                    : 90
.                    : 59 60
/                    : 93
;                    : 1 29 61
<                    : 73 128 137
>                    : 74 128 137
AND                  : 80
ASSIGNATOR           : 30 139
BOOL                 : 123
CHAR                 : 125
CTE_BOOL             : 113
CTE_CHAR             : 115
CTE_FLOAT            : 112
CTE_INT              : 111
CTE_STRING           : 114
ELSE                 : 34
EQ                   : 76
FLOAT                : 122
GEQ                  : 78
ID                   : 1 11 12 18 27 28 31 45 51 59 60 109 138
IF                   : 33
INT                  : 121
LEQ                  : 77
MAIN                 : 132
MAP                  : 137
NOT_EQ               : 75
OP                   : 60
OP_ARGS              : 59
OR                   : 79
PRINT                : 46
PROGRAM              : 1
READ                 : 42
RETURN               : 58
SET                  : 128
SET_MATH_ADDSUB      : 91
SET_MATH_MULDIV      : 94
STRING               : 124
VOID                 : 8 120
WHILE                : 38
[                    : 138
]                    : 138
error                : 
{                    : 13 129 132
}                    : 13 129 132

Nonterminals, with rules where they appear

addsub               : 95
assignment           : 63
assignment2          : 30
block                : 33 34 38
condition            : 71
condition1           : 33
container_operation  : 66 118
datatype             : 12 18 26 119 128 137 137
empty                : 9 15 17 23 44 48 52 83 87 96 104 109 131 136
exp                  : 85 86 139
exp0                 : 81 82
exp02                : 85
exp2                 : 88 95
expression           : 30 33 38 49 57 58 59 105 138
expression2          : 81 82
factor               : 97 100
function_call        : 70 116
function_call1       : 50
function_call2       : 53 54
functype             : 
input                : 64
input1               : 42 43
logop                : 82
main                 : 6
map_access           : 117 139
map_assignment       : 69
map_definition       : 67 127
muldiv               : 100
n_add_one_to_counter : 54
n_check_has_return   : 7
n_clear_scope        : 132
n_era_size           : 50
n_if_2               : 34
n_if_3               : 34 35
n_main_quad          : 1
n_main_quad2         : 132
n_output_quad        : 46 47
n_pop_false_bottom   : 105
n_process_read       : 42 43
n_push_false_bottom  : 105
n_push_variable      : 14 16
n_quad_addsub        : 95
n_quad_assign        : 30 139
n_quad_counter       : 20
n_quad_logop         : 82
n_quad_muldiv        : 97 100
n_quad_not           : 101
n_verify_argument    : 54 55
n_while_1            : 38
n_while_2            : 33 38
n_while_3            : 38
output               : 65
output1              : 46 47
proc                 : 5
proc1                : 13
proc2                : 14 16
proc3                : 13 19
proc4                : 20 22
procA                : 7 8
proca1               : 7
proca2               : 8
program              : 0
program1             : 1 3
program2             : 4 5
relop                : 86
return               : 68
set_definition       : 126
statement            : 22 130
statement1           : 61
statement2           : 62
statement_aux        : 129 130 132
term                 : 88 95
term2                : 97 100
term_not             : 97
var                  : 3 19 24 25
var1                 : 26 27
var2                 : 28
varcte               : 106
varcte1              : 110
vars                 : 24 135
vars_aux             : 132
while                : 72

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; n_main_quad program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID ; n_main_quad program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . ; n_main_quad program1

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . n_main_quad program1
    (2) n_main_quad -> .

    INT             reduce using rule 2 (n_main_quad -> .)
    FLOAT           reduce using rule 2 (n_main_quad -> .)
    BOOL            reduce using rule 2 (n_main_quad -> .)
    STRING          reduce using rule 2 (n_main_quad -> .)
    CHAR            reduce using rule 2 (n_main_quad -> .)
    VOID            reduce using rule 2 (n_main_quad -> .)
    MAIN            reduce using rule 2 (n_main_quad -> .)
    SET             reduce using rule 2 (n_main_quad -> .)
    MAP             reduce using rule 2 (n_main_quad -> .)

    n_main_quad                    shift and go to state 5

state 5

    (1) program -> PROGRAM ID ; n_main_quad . program1
    (3) program1 -> . var program1
    (4) program1 -> . program2
    (26) var -> . datatype var1
    (5) program2 -> . proc program2
    (6) program2 -> . main
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (7) proc -> . proca1 procA n_check_has_return
    (8) proc -> . VOID proca2 procA
    (9) proc -> . empty
    (132) main -> . MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux }
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >
    (12) proca1 -> . datatype ID (
    (140) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    VOID            shift and go to state 6
    MAIN            shift and go to state 24
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! VOID            [ reduce using rule 140 (empty -> .) ]
  ! MAIN            [ reduce using rule 140 (empty -> .) ]
  ! INT             [ reduce using rule 140 (empty -> .) ]
  ! FLOAT           [ reduce using rule 140 (empty -> .) ]
  ! BOOL            [ reduce using rule 140 (empty -> .) ]
  ! STRING          [ reduce using rule 140 (empty -> .) ]
  ! CHAR            [ reduce using rule 140 (empty -> .) ]
  ! SET             [ reduce using rule 140 (empty -> .) ]
  ! MAP             [ reduce using rule 140 (empty -> .) ]

    program1                       shift and go to state 10
    program2                       shift and go to state 11
    datatype                       shift and go to state 20
    proca1                         shift and go to state 12
    map_definition                 shift and go to state 7
    var                            shift and go to state 13
    set_definition                 shift and go to state 19
    main                           shift and go to state 14
    proc                           shift and go to state 15
    empty                          shift and go to state 16

state 6

    (8) proc -> VOID . proca2 procA
    (11) proca2 -> . ID (

    ID              shift and go to state 25

    proca2                         shift and go to state 26

state 7

    (127) datatype -> map_definition .

    ID              reduce using rule 127 (datatype -> map_definition .)
    >               reduce using rule 127 (datatype -> map_definition .)
    ,               reduce using rule 127 (datatype -> map_definition .)


state 8

    (125) datatype -> CHAR .

    ID              reduce using rule 125 (datatype -> CHAR .)
    >               reduce using rule 125 (datatype -> CHAR .)
    ,               reduce using rule 125 (datatype -> CHAR .)


state 9

    (128) set_definition -> SET . < datatype >

    <               shift and go to state 27


state 10

    (1) program -> PROGRAM ID ; n_main_quad program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID ; n_main_quad program1 .)


state 11

    (4) program1 -> program2 .

    $end            reduce using rule 4 (program1 -> program2 .)


state 12

    (7) proc -> proca1 . procA n_check_has_return
    (13) procA -> . proc1 ) { proc3 }
    (14) proc1 -> . n_push_variable proc2
    (15) proc1 -> . empty
    (18) n_push_variable -> . datatype ID
    (140) empty -> .
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

    )               reduce using rule 140 (empty -> .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

    n_push_variable                shift and go to state 30
    set_definition                 shift and go to state 19
    datatype                       shift and go to state 31
    procA                          shift and go to state 32
    empty                          shift and go to state 29
    map_definition                 shift and go to state 7
    proc1                          shift and go to state 28

state 13

    (3) program1 -> var . program1
    (3) program1 -> . var program1
    (4) program1 -> . program2
    (26) var -> . datatype var1
    (5) program2 -> . proc program2
    (6) program2 -> . main
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (7) proc -> . proca1 procA n_check_has_return
    (8) proc -> . VOID proca2 procA
    (9) proc -> . empty
    (132) main -> . MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux }
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >
    (12) proca1 -> . datatype ID (
    (140) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    VOID            shift and go to state 6
    MAIN            shift and go to state 24
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! VOID            [ reduce using rule 140 (empty -> .) ]
  ! MAIN            [ reduce using rule 140 (empty -> .) ]
  ! INT             [ reduce using rule 140 (empty -> .) ]
  ! FLOAT           [ reduce using rule 140 (empty -> .) ]
  ! BOOL            [ reduce using rule 140 (empty -> .) ]
  ! STRING          [ reduce using rule 140 (empty -> .) ]
  ! CHAR            [ reduce using rule 140 (empty -> .) ]
  ! SET             [ reduce using rule 140 (empty -> .) ]
  ! MAP             [ reduce using rule 140 (empty -> .) ]

    program1                       shift and go to state 33
    program2                       shift and go to state 11
    datatype                       shift and go to state 20
    proca1                         shift and go to state 12
    map_definition                 shift and go to state 7
    set_definition                 shift and go to state 19
    var                            shift and go to state 13
    main                           shift and go to state 14
    proc                           shift and go to state 15
    empty                          shift and go to state 16

state 14

    (6) program2 -> main .

    $end            reduce using rule 6 (program2 -> main .)


state 15

    (5) program2 -> proc . program2
    (5) program2 -> . proc program2
    (6) program2 -> . main
    (7) proc -> . proca1 procA n_check_has_return
    (8) proc -> . VOID proca2 procA
    (9) proc -> . empty
    (132) main -> . MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux }
    (12) proca1 -> . datatype ID (
    (140) empty -> .
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    VOID            shift and go to state 6
    MAIN            shift and go to state 24
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! VOID            [ reduce using rule 140 (empty -> .) ]
  ! MAIN            [ reduce using rule 140 (empty -> .) ]
  ! INT             [ reduce using rule 140 (empty -> .) ]
  ! FLOAT           [ reduce using rule 140 (empty -> .) ]
  ! BOOL            [ reduce using rule 140 (empty -> .) ]
  ! STRING          [ reduce using rule 140 (empty -> .) ]
  ! CHAR            [ reduce using rule 140 (empty -> .) ]
  ! SET             [ reduce using rule 140 (empty -> .) ]
  ! MAP             [ reduce using rule 140 (empty -> .) ]

    set_definition                 shift and go to state 19
    program2                       shift and go to state 34
    datatype                       shift and go to state 35
    proca1                         shift and go to state 12
    map_definition                 shift and go to state 7
    main                           shift and go to state 14
    proc                           shift and go to state 15
    empty                          shift and go to state 16

state 16

    (9) proc -> empty .

    VOID            reduce using rule 9 (proc -> empty .)
    MAIN            reduce using rule 9 (proc -> empty .)
    INT             reduce using rule 9 (proc -> empty .)
    FLOAT           reduce using rule 9 (proc -> empty .)
    BOOL            reduce using rule 9 (proc -> empty .)
    STRING          reduce using rule 9 (proc -> empty .)
    CHAR            reduce using rule 9 (proc -> empty .)
    SET             reduce using rule 9 (proc -> empty .)
    MAP             reduce using rule 9 (proc -> empty .)


state 17

    (124) datatype -> STRING .

    ID              reduce using rule 124 (datatype -> STRING .)
    >               reduce using rule 124 (datatype -> STRING .)
    ,               reduce using rule 124 (datatype -> STRING .)


state 18

    (137) map_definition -> MAP . < datatype , datatype >

    <               shift and go to state 36


state 19

    (126) datatype -> set_definition .

    ID              reduce using rule 126 (datatype -> set_definition .)
    >               reduce using rule 126 (datatype -> set_definition .)
    ,               reduce using rule 126 (datatype -> set_definition .)


state 20

    (26) var -> datatype . var1
    (12) proca1 -> datatype . ID (
    (27) var1 -> . ID , var1
    (28) var1 -> . ID var2

    ID              shift and go to state 38

    var1                           shift and go to state 37

state 21

    (122) datatype -> FLOAT .

    ID              reduce using rule 122 (datatype -> FLOAT .)
    >               reduce using rule 122 (datatype -> FLOAT .)
    ,               reduce using rule 122 (datatype -> FLOAT .)


state 22

    (121) datatype -> INT .

    ID              reduce using rule 121 (datatype -> INT .)
    >               reduce using rule 121 (datatype -> INT .)
    ,               reduce using rule 121 (datatype -> INT .)


state 23

    (123) datatype -> BOOL .

    ID              reduce using rule 123 (datatype -> BOOL .)
    >               reduce using rule 123 (datatype -> BOOL .)
    ,               reduce using rule 123 (datatype -> BOOL .)


state 24

    (132) main -> MAIN . n_clear_scope n_main_quad2 { vars_aux statement_aux }
    (134) n_clear_scope -> .

    {               reduce using rule 134 (n_clear_scope -> .)

    n_clear_scope                  shift and go to state 39

state 25

    (11) proca2 -> ID . (

    (               shift and go to state 40


state 26

    (8) proc -> VOID proca2 . procA
    (13) procA -> . proc1 ) { proc3 }
    (14) proc1 -> . n_push_variable proc2
    (15) proc1 -> . empty
    (18) n_push_variable -> . datatype ID
    (140) empty -> .
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

    )               reduce using rule 140 (empty -> .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

    n_push_variable                shift and go to state 30
    set_definition                 shift and go to state 19
    datatype                       shift and go to state 31
    map_definition                 shift and go to state 7
    procA                          shift and go to state 41
    empty                          shift and go to state 29
    proc1                          shift and go to state 28

state 27

    (128) set_definition -> SET < . datatype >
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

    datatype                       shift and go to state 42
    map_definition                 shift and go to state 7
    set_definition                 shift and go to state 19

state 28

    (13) procA -> proc1 . ) { proc3 }

    )               shift and go to state 43


state 29

    (15) proc1 -> empty .

    )               reduce using rule 15 (proc1 -> empty .)


state 30

    (14) proc1 -> n_push_variable . proc2
    (16) proc2 -> . , n_push_variable proc2
    (17) proc2 -> . empty
    (140) empty -> .

    ,               shift and go to state 44
    )               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 45
    proc2                          shift and go to state 46

state 31

    (18) n_push_variable -> datatype . ID

    ID              shift and go to state 47


state 32

    (7) proc -> proca1 procA . n_check_has_return
    (10) n_check_has_return -> .

    VOID            reduce using rule 10 (n_check_has_return -> .)
    MAIN            reduce using rule 10 (n_check_has_return -> .)
    INT             reduce using rule 10 (n_check_has_return -> .)
    FLOAT           reduce using rule 10 (n_check_has_return -> .)
    BOOL            reduce using rule 10 (n_check_has_return -> .)
    STRING          reduce using rule 10 (n_check_has_return -> .)
    CHAR            reduce using rule 10 (n_check_has_return -> .)
    SET             reduce using rule 10 (n_check_has_return -> .)
    MAP             reduce using rule 10 (n_check_has_return -> .)

    n_check_has_return             shift and go to state 48

state 33

    (3) program1 -> var program1 .

    $end            reduce using rule 3 (program1 -> var program1 .)


state 34

    (5) program2 -> proc program2 .

    $end            reduce using rule 5 (program2 -> proc program2 .)


state 35

    (12) proca1 -> datatype . ID (

    ID              shift and go to state 49


state 36

    (137) map_definition -> MAP < . datatype , datatype >
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

    datatype                       shift and go to state 50
    map_definition                 shift and go to state 7
    set_definition                 shift and go to state 19

state 37

    (26) var -> datatype var1 .

    INT             reduce using rule 26 (var -> datatype var1 .)
    FLOAT           reduce using rule 26 (var -> datatype var1 .)
    BOOL            reduce using rule 26 (var -> datatype var1 .)
    STRING          reduce using rule 26 (var -> datatype var1 .)
    CHAR            reduce using rule 26 (var -> datatype var1 .)
    SET             reduce using rule 26 (var -> datatype var1 .)
    MAP             reduce using rule 26 (var -> datatype var1 .)
    READ            reduce using rule 26 (var -> datatype var1 .)
    PRINT           reduce using rule 26 (var -> datatype var1 .)
    ID              reduce using rule 26 (var -> datatype var1 .)
    RETURN          reduce using rule 26 (var -> datatype var1 .)
    IF              reduce using rule 26 (var -> datatype var1 .)
    WHILE           reduce using rule 26 (var -> datatype var1 .)
    }               reduce using rule 26 (var -> datatype var1 .)
    VOID            reduce using rule 26 (var -> datatype var1 .)
    MAIN            reduce using rule 26 (var -> datatype var1 .)


state 38

    (12) proca1 -> datatype ID . (
    (27) var1 -> ID . , var1
    (28) var1 -> ID . var2
    (29) var2 -> . ;

    (               shift and go to state 52
    ,               shift and go to state 53
    ;               shift and go to state 54

    var2                           shift and go to state 51

state 39

    (132) main -> MAIN n_clear_scope . n_main_quad2 { vars_aux statement_aux }
    (133) n_main_quad2 -> .

    {               reduce using rule 133 (n_main_quad2 -> .)

    n_main_quad2                   shift and go to state 55

state 40

    (11) proca2 -> ID ( .

    INT             reduce using rule 11 (proca2 -> ID ( .)
    FLOAT           reduce using rule 11 (proca2 -> ID ( .)
    BOOL            reduce using rule 11 (proca2 -> ID ( .)
    STRING          reduce using rule 11 (proca2 -> ID ( .)
    CHAR            reduce using rule 11 (proca2 -> ID ( .)
    SET             reduce using rule 11 (proca2 -> ID ( .)
    MAP             reduce using rule 11 (proca2 -> ID ( .)
    )               reduce using rule 11 (proca2 -> ID ( .)


state 41

    (8) proc -> VOID proca2 procA .

    VOID            reduce using rule 8 (proc -> VOID proca2 procA .)
    MAIN            reduce using rule 8 (proc -> VOID proca2 procA .)
    INT             reduce using rule 8 (proc -> VOID proca2 procA .)
    FLOAT           reduce using rule 8 (proc -> VOID proca2 procA .)
    BOOL            reduce using rule 8 (proc -> VOID proca2 procA .)
    STRING          reduce using rule 8 (proc -> VOID proca2 procA .)
    CHAR            reduce using rule 8 (proc -> VOID proca2 procA .)
    SET             reduce using rule 8 (proc -> VOID proca2 procA .)
    MAP             reduce using rule 8 (proc -> VOID proca2 procA .)


state 42

    (128) set_definition -> SET < datatype . >

    >               shift and go to state 56


state 43

    (13) procA -> proc1 ) . { proc3 }

    {               shift and go to state 57


state 44

    (16) proc2 -> , . n_push_variable proc2
    (18) n_push_variable -> . datatype ID
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

    datatype                       shift and go to state 31
    n_push_variable                shift and go to state 58
    map_definition                 shift and go to state 7
    set_definition                 shift and go to state 19

state 45

    (17) proc2 -> empty .

    )               reduce using rule 17 (proc2 -> empty .)


state 46

    (14) proc1 -> n_push_variable proc2 .

    )               reduce using rule 14 (proc1 -> n_push_variable proc2 .)


state 47

    (18) n_push_variable -> datatype ID .

    ,               reduce using rule 18 (n_push_variable -> datatype ID .)
    )               reduce using rule 18 (n_push_variable -> datatype ID .)


state 48

    (7) proc -> proca1 procA n_check_has_return .

    VOID            reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    MAIN            reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    INT             reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    FLOAT           reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    BOOL            reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    STRING          reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    CHAR            reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    SET             reduce using rule 7 (proc -> proca1 procA n_check_has_return .)
    MAP             reduce using rule 7 (proc -> proca1 procA n_check_has_return .)


state 49

    (12) proca1 -> datatype ID . (

    (               shift and go to state 52


state 50

    (137) map_definition -> MAP < datatype . , datatype >

    ,               shift and go to state 59


state 51

    (28) var1 -> ID var2 .

    INT             reduce using rule 28 (var1 -> ID var2 .)
    FLOAT           reduce using rule 28 (var1 -> ID var2 .)
    BOOL            reduce using rule 28 (var1 -> ID var2 .)
    STRING          reduce using rule 28 (var1 -> ID var2 .)
    CHAR            reduce using rule 28 (var1 -> ID var2 .)
    VOID            reduce using rule 28 (var1 -> ID var2 .)
    MAIN            reduce using rule 28 (var1 -> ID var2 .)
    SET             reduce using rule 28 (var1 -> ID var2 .)
    MAP             reduce using rule 28 (var1 -> ID var2 .)
    READ            reduce using rule 28 (var1 -> ID var2 .)
    PRINT           reduce using rule 28 (var1 -> ID var2 .)
    ID              reduce using rule 28 (var1 -> ID var2 .)
    RETURN          reduce using rule 28 (var1 -> ID var2 .)
    IF              reduce using rule 28 (var1 -> ID var2 .)
    WHILE           reduce using rule 28 (var1 -> ID var2 .)
    }               reduce using rule 28 (var1 -> ID var2 .)


state 52

    (12) proca1 -> datatype ID ( .

    INT             reduce using rule 12 (proca1 -> datatype ID ( .)
    FLOAT           reduce using rule 12 (proca1 -> datatype ID ( .)
    BOOL            reduce using rule 12 (proca1 -> datatype ID ( .)
    STRING          reduce using rule 12 (proca1 -> datatype ID ( .)
    CHAR            reduce using rule 12 (proca1 -> datatype ID ( .)
    SET             reduce using rule 12 (proca1 -> datatype ID ( .)
    MAP             reduce using rule 12 (proca1 -> datatype ID ( .)
    )               reduce using rule 12 (proca1 -> datatype ID ( .)


state 53

    (27) var1 -> ID , . var1
    (27) var1 -> . ID , var1
    (28) var1 -> . ID var2

    ID              shift and go to state 61

    var1                           shift and go to state 60

state 54

    (29) var2 -> ; .

    INT             reduce using rule 29 (var2 -> ; .)
    FLOAT           reduce using rule 29 (var2 -> ; .)
    BOOL            reduce using rule 29 (var2 -> ; .)
    STRING          reduce using rule 29 (var2 -> ; .)
    CHAR            reduce using rule 29 (var2 -> ; .)
    VOID            reduce using rule 29 (var2 -> ; .)
    MAIN            reduce using rule 29 (var2 -> ; .)
    SET             reduce using rule 29 (var2 -> ; .)
    MAP             reduce using rule 29 (var2 -> ; .)
    READ            reduce using rule 29 (var2 -> ; .)
    PRINT           reduce using rule 29 (var2 -> ; .)
    ID              reduce using rule 29 (var2 -> ; .)
    RETURN          reduce using rule 29 (var2 -> ; .)
    IF              reduce using rule 29 (var2 -> ; .)
    WHILE           reduce using rule 29 (var2 -> ; .)
    }               reduce using rule 29 (var2 -> ; .)


state 55

    (132) main -> MAIN n_clear_scope n_main_quad2 . { vars_aux statement_aux }

    {               shift and go to state 62


state 56

    (128) set_definition -> SET < datatype > .

    ID              reduce using rule 128 (set_definition -> SET < datatype > .)
    ,               reduce using rule 128 (set_definition -> SET < datatype > .)
    >               reduce using rule 128 (set_definition -> SET < datatype > .)


state 57

    (13) procA -> proc1 ) { . proc3 }
    (19) proc3 -> . var proc3
    (20) proc3 -> . n_quad_counter proc4
    (26) var -> . datatype var1
    (21) n_quad_counter -> .
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    READ            reduce using rule 21 (n_quad_counter -> .)
    PRINT           reduce using rule 21 (n_quad_counter -> .)
    ID              reduce using rule 21 (n_quad_counter -> .)
    RETURN          reduce using rule 21 (n_quad_counter -> .)
    IF              reduce using rule 21 (n_quad_counter -> .)
    WHILE           reduce using rule 21 (n_quad_counter -> .)
    }               reduce using rule 21 (n_quad_counter -> .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! MAP             [ reduce using rule 21 (n_quad_counter -> .) ]

    set_definition                 shift and go to state 19
    datatype                       shift and go to state 66
    map_definition                 shift and go to state 7
    n_quad_counter                 shift and go to state 64
    var                            shift and go to state 65
    proc3                          shift and go to state 63

state 58

    (16) proc2 -> , n_push_variable . proc2
    (16) proc2 -> . , n_push_variable proc2
    (17) proc2 -> . empty
    (140) empty -> .

    ,               shift and go to state 44
    )               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 45
    proc2                          shift and go to state 67

state 59

    (137) map_definition -> MAP < datatype , . datatype >
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

    datatype                       shift and go to state 68
    map_definition                 shift and go to state 7
    set_definition                 shift and go to state 19

state 60

    (27) var1 -> ID , var1 .

    INT             reduce using rule 27 (var1 -> ID , var1 .)
    FLOAT           reduce using rule 27 (var1 -> ID , var1 .)
    BOOL            reduce using rule 27 (var1 -> ID , var1 .)
    STRING          reduce using rule 27 (var1 -> ID , var1 .)
    CHAR            reduce using rule 27 (var1 -> ID , var1 .)
    VOID            reduce using rule 27 (var1 -> ID , var1 .)
    MAIN            reduce using rule 27 (var1 -> ID , var1 .)
    SET             reduce using rule 27 (var1 -> ID , var1 .)
    MAP             reduce using rule 27 (var1 -> ID , var1 .)
    READ            reduce using rule 27 (var1 -> ID , var1 .)
    PRINT           reduce using rule 27 (var1 -> ID , var1 .)
    ID              reduce using rule 27 (var1 -> ID , var1 .)
    RETURN          reduce using rule 27 (var1 -> ID , var1 .)
    IF              reduce using rule 27 (var1 -> ID , var1 .)
    WHILE           reduce using rule 27 (var1 -> ID , var1 .)
    }               reduce using rule 27 (var1 -> ID , var1 .)


state 61

    (27) var1 -> ID . , var1
    (28) var1 -> ID . var2
    (29) var2 -> . ;

    ,               shift and go to state 53
    ;               shift and go to state 54

    var2                           shift and go to state 51

state 62

    (132) main -> MAIN n_clear_scope n_main_quad2 { . vars_aux statement_aux }
    (135) vars_aux -> . vars
    (136) vars_aux -> . empty
    (24) vars -> . var vars
    (25) vars -> . var
    (140) empty -> .
    (26) var -> . datatype var1
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    READ            reduce using rule 140 (empty -> .)
    PRINT           reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    RETURN          reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! MAP             [ reduce using rule 140 (empty -> .) ]

    set_definition                 shift and go to state 19
    vars                           shift and go to state 69
    datatype                       shift and go to state 66
    map_definition                 shift and go to state 7
    vars_aux                       shift and go to state 70
    var                            shift and go to state 71
    empty                          shift and go to state 72

state 63

    (13) procA -> proc1 ) { proc3 . }

    }               shift and go to state 73


state 64

    (20) proc3 -> n_quad_counter . proc4
    (22) proc4 -> . statement proc4
    (23) proc4 -> . empty
    (61) statement -> . statement1 ;
    (62) statement -> . statement2
    (140) empty -> .
    (63) statement1 -> . assignment
    (64) statement1 -> . input
    (65) statement1 -> . output
    (66) statement1 -> . container_operation
    (67) statement1 -> . map_definition
    (68) statement1 -> . return
    (69) statement1 -> . map_assignment
    (70) statement1 -> . function_call
    (71) statement2 -> . condition
    (72) statement2 -> . while
    (30) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (42) input -> . READ ( n_process_read input1 )
    (46) output -> . PRINT ( n_output_quad output1 )
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (137) map_definition -> . MAP < datatype , datatype >
    (58) return -> . RETURN expression
    (139) map_assignment -> . map_access ASSIGNATOR n_quad_assign exp
    (50) function_call -> . n_era_size function_call1 )
    (33) condition -> . IF ( expression n_while_2 ) block condition1
    (38) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (31) assignment2 -> . ID
    (138) map_access -> . ID [ expression ]
    (51) n_era_size -> . ID (

    }               reduce using rule 140 (empty -> .)
    READ            shift and go to state 75
    PRINT           shift and go to state 79
    ID              shift and go to state 92
    MAP             shift and go to state 18
    RETURN          shift and go to state 74
    IF              shift and go to state 94
    WHILE           shift and go to state 78

    map_definition                 shift and go to state 76
    function_call                  shift and go to state 77
    proc4                          shift and go to state 80
    map_access                     shift and go to state 81
    assignment2                    shift and go to state 82
    statement                      shift and go to state 83
    input                          shift and go to state 84
    empty                          shift and go to state 85
    return                         shift and go to state 86
    statement2                     shift and go to state 87
    statement1                     shift and go to state 88
    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 90
    assignment                     shift and go to state 91
    condition                      shift and go to state 93
    map_assignment                 shift and go to state 95
    while                          shift and go to state 96
    output                         shift and go to state 97

state 65

    (19) proc3 -> var . proc3
    (19) proc3 -> . var proc3
    (20) proc3 -> . n_quad_counter proc4
    (26) var -> . datatype var1
    (21) n_quad_counter -> .
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    READ            reduce using rule 21 (n_quad_counter -> .)
    PRINT           reduce using rule 21 (n_quad_counter -> .)
    ID              reduce using rule 21 (n_quad_counter -> .)
    RETURN          reduce using rule 21 (n_quad_counter -> .)
    IF              reduce using rule 21 (n_quad_counter -> .)
    WHILE           reduce using rule 21 (n_quad_counter -> .)
    }               reduce using rule 21 (n_quad_counter -> .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! MAP             [ reduce using rule 21 (n_quad_counter -> .) ]

    set_definition                 shift and go to state 19
    datatype                       shift and go to state 66
    map_definition                 shift and go to state 7
    n_quad_counter                 shift and go to state 64
    var                            shift and go to state 65
    proc3                          shift and go to state 98

state 66

    (26) var -> datatype . var1
    (27) var1 -> . ID , var1
    (28) var1 -> . ID var2

    ID              shift and go to state 61

    var1                           shift and go to state 37

state 67

    (16) proc2 -> , n_push_variable proc2 .

    )               reduce using rule 16 (proc2 -> , n_push_variable proc2 .)


state 68

    (137) map_definition -> MAP < datatype , datatype . >

    >               shift and go to state 99


state 69

    (135) vars_aux -> vars .

    READ            reduce using rule 135 (vars_aux -> vars .)
    PRINT           reduce using rule 135 (vars_aux -> vars .)
    ID              reduce using rule 135 (vars_aux -> vars .)
    MAP             reduce using rule 135 (vars_aux -> vars .)
    RETURN          reduce using rule 135 (vars_aux -> vars .)
    IF              reduce using rule 135 (vars_aux -> vars .)
    WHILE           reduce using rule 135 (vars_aux -> vars .)
    }               reduce using rule 135 (vars_aux -> vars .)


state 70

    (132) main -> MAIN n_clear_scope n_main_quad2 { vars_aux . statement_aux }
    (130) statement_aux -> . statement statement_aux
    (131) statement_aux -> . empty
    (61) statement -> . statement1 ;
    (62) statement -> . statement2
    (140) empty -> .
    (63) statement1 -> . assignment
    (64) statement1 -> . input
    (65) statement1 -> . output
    (66) statement1 -> . container_operation
    (67) statement1 -> . map_definition
    (68) statement1 -> . return
    (69) statement1 -> . map_assignment
    (70) statement1 -> . function_call
    (71) statement2 -> . condition
    (72) statement2 -> . while
    (30) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (42) input -> . READ ( n_process_read input1 )
    (46) output -> . PRINT ( n_output_quad output1 )
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (137) map_definition -> . MAP < datatype , datatype >
    (58) return -> . RETURN expression
    (139) map_assignment -> . map_access ASSIGNATOR n_quad_assign exp
    (50) function_call -> . n_era_size function_call1 )
    (33) condition -> . IF ( expression n_while_2 ) block condition1
    (38) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (31) assignment2 -> . ID
    (138) map_access -> . ID [ expression ]
    (51) n_era_size -> . ID (

    }               reduce using rule 140 (empty -> .)
    READ            shift and go to state 75
    PRINT           shift and go to state 79
    ID              shift and go to state 92
    MAP             shift and go to state 18
    RETURN          shift and go to state 74
    IF              shift and go to state 94
    WHILE           shift and go to state 78

    map_definition                 shift and go to state 76
    function_call                  shift and go to state 77
    statement_aux                  shift and go to state 100
    map_access                     shift and go to state 81
    assignment2                    shift and go to state 82
    statement                      shift and go to state 101
    input                          shift and go to state 84
    empty                          shift and go to state 102
    return                         shift and go to state 86
    statement2                     shift and go to state 87
    statement1                     shift and go to state 88
    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 90
    assignment                     shift and go to state 91
    condition                      shift and go to state 93
    map_assignment                 shift and go to state 95
    while                          shift and go to state 96
    output                         shift and go to state 97

state 71

    (24) vars -> var . vars
    (25) vars -> var .
    (24) vars -> . var vars
    (25) vars -> . var
    (26) var -> . datatype var1
    (121) datatype -> . INT
    (122) datatype -> . FLOAT
    (123) datatype -> . BOOL
    (124) datatype -> . STRING
    (125) datatype -> . CHAR
    (126) datatype -> . set_definition
    (127) datatype -> . map_definition
    (128) set_definition -> . SET < datatype >
    (137) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    READ            reduce using rule 25 (vars -> var .)
    PRINT           reduce using rule 25 (vars -> var .)
    ID              reduce using rule 25 (vars -> var .)
    RETURN          reduce using rule 25 (vars -> var .)
    IF              reduce using rule 25 (vars -> var .)
    WHILE           reduce using rule 25 (vars -> var .)
    }               reduce using rule 25 (vars -> var .)
    INT             shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 23
    STRING          shift and go to state 17
    CHAR            shift and go to state 8
    SET             shift and go to state 9
    MAP             shift and go to state 18

  ! MAP             [ reduce using rule 25 (vars -> var .) ]

    vars                           shift and go to state 103
    set_definition                 shift and go to state 19
    datatype                       shift and go to state 66
    map_definition                 shift and go to state 7
    var                            shift and go to state 71

state 72

    (136) vars_aux -> empty .

    READ            reduce using rule 136 (vars_aux -> empty .)
    PRINT           reduce using rule 136 (vars_aux -> empty .)
    ID              reduce using rule 136 (vars_aux -> empty .)
    MAP             reduce using rule 136 (vars_aux -> empty .)
    RETURN          reduce using rule 136 (vars_aux -> empty .)
    IF              reduce using rule 136 (vars_aux -> empty .)
    WHILE           reduce using rule 136 (vars_aux -> empty .)
    }               reduce using rule 136 (vars_aux -> empty .)


state 73

    (13) procA -> proc1 ) { proc3 } .

    VOID            reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    MAIN            reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    INT             reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    FLOAT           reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    BOOL            reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    STRING          reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    CHAR            reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    SET             reduce using rule 13 (procA -> proc1 ) { proc3 } .)
    MAP             reduce using rule 13 (procA -> proc1 ) { proc3 } .)


state 74

    (58) return -> RETURN . expression
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    exp                            shift and go to state 108
    expression                     shift and go to state 109
    empty                          shift and go to state 110

state 75

    (42) input -> READ . ( n_process_read input1 )

    (               shift and go to state 111


state 76

    (67) statement1 -> map_definition .

    ;               reduce using rule 67 (statement1 -> map_definition .)


state 77

    (70) statement1 -> function_call .

    ;               reduce using rule 70 (statement1 -> function_call .)


state 78

    (38) while -> WHILE . n_while_1 ( expression ) n_while_2 block n_while_3
    (39) n_while_1 -> .

    (               reduce using rule 39 (n_while_1 -> .)

    n_while_1                      shift and go to state 112

state 79

    (46) output -> PRINT . ( n_output_quad output1 )

    (               shift and go to state 113


state 80

    (20) proc3 -> n_quad_counter proc4 .

    }               reduce using rule 20 (proc3 -> n_quad_counter proc4 .)


state 81

    (139) map_assignment -> map_access . ASSIGNATOR n_quad_assign exp

    ASSIGNATOR      shift and go to state 114


state 82

    (30) assignment -> assignment2 . ASSIGNATOR n_quad_assign expression

    ASSIGNATOR      shift and go to state 115


state 83

    (22) proc4 -> statement . proc4
    (22) proc4 -> . statement proc4
    (23) proc4 -> . empty
    (61) statement -> . statement1 ;
    (62) statement -> . statement2
    (140) empty -> .
    (63) statement1 -> . assignment
    (64) statement1 -> . input
    (65) statement1 -> . output
    (66) statement1 -> . container_operation
    (67) statement1 -> . map_definition
    (68) statement1 -> . return
    (69) statement1 -> . map_assignment
    (70) statement1 -> . function_call
    (71) statement2 -> . condition
    (72) statement2 -> . while
    (30) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (42) input -> . READ ( n_process_read input1 )
    (46) output -> . PRINT ( n_output_quad output1 )
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (137) map_definition -> . MAP < datatype , datatype >
    (58) return -> . RETURN expression
    (139) map_assignment -> . map_access ASSIGNATOR n_quad_assign exp
    (50) function_call -> . n_era_size function_call1 )
    (33) condition -> . IF ( expression n_while_2 ) block condition1
    (38) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (31) assignment2 -> . ID
    (138) map_access -> . ID [ expression ]
    (51) n_era_size -> . ID (

    }               reduce using rule 140 (empty -> .)
    READ            shift and go to state 75
    PRINT           shift and go to state 79
    ID              shift and go to state 92
    MAP             shift and go to state 18
    RETURN          shift and go to state 74
    IF              shift and go to state 94
    WHILE           shift and go to state 78

    map_definition                 shift and go to state 76
    function_call                  shift and go to state 77
    proc4                          shift and go to state 116
    map_access                     shift and go to state 81
    assignment2                    shift and go to state 82
    statement                      shift and go to state 83
    input                          shift and go to state 84
    empty                          shift and go to state 85
    return                         shift and go to state 86
    statement2                     shift and go to state 87
    statement1                     shift and go to state 88
    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 90
    assignment                     shift and go to state 91
    condition                      shift and go to state 93
    map_assignment                 shift and go to state 95
    while                          shift and go to state 96
    output                         shift and go to state 97

state 84

    (64) statement1 -> input .

    ;               reduce using rule 64 (statement1 -> input .)


state 85

    (23) proc4 -> empty .

    }               reduce using rule 23 (proc4 -> empty .)


state 86

    (68) statement1 -> return .

    ;               reduce using rule 68 (statement1 -> return .)


state 87

    (62) statement -> statement2 .

    READ            reduce using rule 62 (statement -> statement2 .)
    PRINT           reduce using rule 62 (statement -> statement2 .)
    ID              reduce using rule 62 (statement -> statement2 .)
    MAP             reduce using rule 62 (statement -> statement2 .)
    RETURN          reduce using rule 62 (statement -> statement2 .)
    IF              reduce using rule 62 (statement -> statement2 .)
    WHILE           reduce using rule 62 (statement -> statement2 .)
    }               reduce using rule 62 (statement -> statement2 .)


state 88

    (61) statement -> statement1 . ;

    ;               shift and go to state 117


state 89

    (50) function_call -> n_era_size . function_call1 )
    (52) function_call1 -> . empty
    (53) function_call1 -> . function_call2
    (140) empty -> .
    (54) function_call2 -> . n_verify_argument , n_add_one_to_counter function_call2
    (55) function_call2 -> . n_verify_argument
    (57) n_verify_argument -> . expression
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty

    )               reduce using rule 140 (empty -> .)
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)
    !               shift and go to state 107

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp                            shift and go to state 108
    exp0                           shift and go to state 106
    function_call2                 shift and go to state 118
    function_call1                 shift and go to state 119
    expression                     shift and go to state 120
    n_verify_argument              shift and go to state 121
    empty                          shift and go to state 122

state 90

    (66) statement1 -> container_operation .

    ;               reduce using rule 66 (statement1 -> container_operation .)


state 91

    (63) statement1 -> assignment .

    ;               reduce using rule 63 (statement1 -> assignment .)


state 92

    (59) container_operation -> ID . . OP_ARGS ( expression )
    (60) container_operation -> ID . . OP ( )
    (31) assignment2 -> ID .
    (138) map_access -> ID . [ expression ]
    (51) n_era_size -> ID . (

    .               shift and go to state 124
    ASSIGNATOR      reduce using rule 31 (assignment2 -> ID .)
    [               shift and go to state 125
    (               shift and go to state 123


state 93

    (71) statement2 -> condition .

    READ            reduce using rule 71 (statement2 -> condition .)
    PRINT           reduce using rule 71 (statement2 -> condition .)
    ID              reduce using rule 71 (statement2 -> condition .)
    MAP             reduce using rule 71 (statement2 -> condition .)
    RETURN          reduce using rule 71 (statement2 -> condition .)
    IF              reduce using rule 71 (statement2 -> condition .)
    WHILE           reduce using rule 71 (statement2 -> condition .)
    }               reduce using rule 71 (statement2 -> condition .)


state 94

    (33) condition -> IF . ( expression n_while_2 ) block condition1

    (               shift and go to state 126


state 95

    (69) statement1 -> map_assignment .

    ;               reduce using rule 69 (statement1 -> map_assignment .)


state 96

    (72) statement2 -> while .

    READ            reduce using rule 72 (statement2 -> while .)
    PRINT           reduce using rule 72 (statement2 -> while .)
    ID              reduce using rule 72 (statement2 -> while .)
    MAP             reduce using rule 72 (statement2 -> while .)
    RETURN          reduce using rule 72 (statement2 -> while .)
    IF              reduce using rule 72 (statement2 -> while .)
    WHILE           reduce using rule 72 (statement2 -> while .)
    }               reduce using rule 72 (statement2 -> while .)


state 97

    (65) statement1 -> output .

    ;               reduce using rule 65 (statement1 -> output .)


state 98

    (19) proc3 -> var proc3 .

    }               reduce using rule 19 (proc3 -> var proc3 .)


state 99

    (137) map_definition -> MAP < datatype , datatype > .

    ;               reduce using rule 137 (map_definition -> MAP < datatype , datatype > .)
    ID              reduce using rule 137 (map_definition -> MAP < datatype , datatype > .)
    >               reduce using rule 137 (map_definition -> MAP < datatype , datatype > .)
    ,               reduce using rule 137 (map_definition -> MAP < datatype , datatype > .)


state 100

    (132) main -> MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux . }

    }               shift and go to state 127


state 101

    (130) statement_aux -> statement . statement_aux
    (130) statement_aux -> . statement statement_aux
    (131) statement_aux -> . empty
    (61) statement -> . statement1 ;
    (62) statement -> . statement2
    (140) empty -> .
    (63) statement1 -> . assignment
    (64) statement1 -> . input
    (65) statement1 -> . output
    (66) statement1 -> . container_operation
    (67) statement1 -> . map_definition
    (68) statement1 -> . return
    (69) statement1 -> . map_assignment
    (70) statement1 -> . function_call
    (71) statement2 -> . condition
    (72) statement2 -> . while
    (30) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (42) input -> . READ ( n_process_read input1 )
    (46) output -> . PRINT ( n_output_quad output1 )
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (137) map_definition -> . MAP < datatype , datatype >
    (58) return -> . RETURN expression
    (139) map_assignment -> . map_access ASSIGNATOR n_quad_assign exp
    (50) function_call -> . n_era_size function_call1 )
    (33) condition -> . IF ( expression n_while_2 ) block condition1
    (38) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (31) assignment2 -> . ID
    (138) map_access -> . ID [ expression ]
    (51) n_era_size -> . ID (

    }               reduce using rule 140 (empty -> .)
    READ            shift and go to state 75
    PRINT           shift and go to state 79
    ID              shift and go to state 92
    MAP             shift and go to state 18
    RETURN          shift and go to state 74
    IF              shift and go to state 94
    WHILE           shift and go to state 78

    map_definition                 shift and go to state 76
    function_call                  shift and go to state 77
    statement_aux                  shift and go to state 128
    map_access                     shift and go to state 81
    assignment2                    shift and go to state 82
    statement                      shift and go to state 101
    input                          shift and go to state 84
    empty                          shift and go to state 102
    return                         shift and go to state 86
    statement2                     shift and go to state 87
    statement1                     shift and go to state 88
    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 90
    assignment                     shift and go to state 91
    condition                      shift and go to state 93
    map_assignment                 shift and go to state 95
    while                          shift and go to state 96
    output                         shift and go to state 97

state 102

    (131) statement_aux -> empty .

    }               reduce using rule 131 (statement_aux -> empty .)


state 103

    (24) vars -> var vars .

    READ            reduce using rule 24 (vars -> var vars .)
    PRINT           reduce using rule 24 (vars -> var vars .)
    ID              reduce using rule 24 (vars -> var vars .)
    MAP             reduce using rule 24 (vars -> var vars .)
    RETURN          reduce using rule 24 (vars -> var vars .)
    IF              reduce using rule 24 (vars -> var vars .)
    WHILE           reduce using rule 24 (vars -> var vars .)
    }               reduce using rule 24 (vars -> var vars .)


state 104

    (97) term -> term_not . factor n_quad_muldiv term2
    (105) factor -> . ( n_push_false_bottom expression ) n_pop_false_bottom
    (106) factor -> . varcte
    (109) varcte -> . ID empty
    (110) varcte -> . varcte1
    (111) varcte1 -> . CTE_INT
    (112) varcte1 -> . CTE_FLOAT
    (113) varcte1 -> . CTE_BOOL
    (114) varcte1 -> . CTE_STRING
    (115) varcte1 -> . CTE_CHAR
    (116) varcte1 -> . function_call
    (117) varcte1 -> . map_access
    (118) varcte1 -> . container_operation
    (50) function_call -> . n_era_size function_call1 )
    (138) map_access -> . ID [ expression ]
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (51) n_era_size -> . ID (

    (               shift and go to state 133
    ID              shift and go to state 138
    CTE_INT         shift and go to state 137
    CTE_FLOAT       shift and go to state 139
    CTE_BOOL        shift and go to state 140
    CTE_STRING      shift and go to state 141
    CTE_CHAR        shift and go to state 135

    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 136
    map_access                     shift and go to state 132
    function_call                  shift and go to state 129
    factor                         shift and go to state 134
    varcte1                        shift and go to state 130
    varcte                         shift and go to state 131

state 105

    (88) exp -> term . exp2
    (95) exp2 -> . addsub term n_quad_addsub exp2
    (96) exp2 -> . empty
    (89) addsub -> . +
    (90) addsub -> . -
    (91) addsub -> . SET_MATH_ADDSUB
    (140) empty -> .

    +               shift and go to state 143
    -               shift and go to state 144
    SET_MATH_ADDSUB shift and go to state 146
    <               reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    NOT_EQ          reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    LEQ             reduce using rule 140 (empty -> .)
    GEQ             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    exp2                           shift and go to state 142
    addsub                         shift and go to state 145
    empty                          shift and go to state 147

state 106

    (81) expression -> exp0 . expression2
    (82) expression2 -> . logop exp0 n_quad_logop expression2
    (83) expression2 -> . empty
    (79) logop -> . OR
    (80) logop -> . AND
    (140) empty -> .

    OR              shift and go to state 151
    AND             shift and go to state 148
    ;               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 152
    expression2                    shift and go to state 150
    logop                          shift and go to state 149

state 107

    (103) term_not -> ! .

    (               reduce using rule 103 (term_not -> ! .)
    ID              reduce using rule 103 (term_not -> ! .)
    CTE_INT         reduce using rule 103 (term_not -> ! .)
    CTE_FLOAT       reduce using rule 103 (term_not -> ! .)
    CTE_BOOL        reduce using rule 103 (term_not -> ! .)
    CTE_STRING      reduce using rule 103 (term_not -> ! .)
    CTE_CHAR        reduce using rule 103 (term_not -> ! .)


state 108

    (85) exp0 -> exp . exp02
    (86) exp02 -> . relop exp
    (87) exp02 -> . empty
    (73) relop -> . <
    (74) relop -> . >
    (75) relop -> . NOT_EQ
    (76) relop -> . EQ
    (77) relop -> . LEQ
    (78) relop -> . GEQ
    (140) empty -> .

    <               shift and go to state 159
    >               shift and go to state 161
    NOT_EQ          shift and go to state 155
    EQ              shift and go to state 158
    LEQ             shift and go to state 156
    GEQ             shift and go to state 153
    OR              reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    exp02                          shift and go to state 157
    empty                          shift and go to state 160
    relop                          shift and go to state 154

state 109

    (58) return -> RETURN expression .

    ;               reduce using rule 58 (return -> RETURN expression .)


state 110

    (104) term_not -> empty .

    (               reduce using rule 104 (term_not -> empty .)
    ID              reduce using rule 104 (term_not -> empty .)
    CTE_INT         reduce using rule 104 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 104 (term_not -> empty .)
    CTE_BOOL        reduce using rule 104 (term_not -> empty .)
    CTE_STRING      reduce using rule 104 (term_not -> empty .)
    CTE_CHAR        reduce using rule 104 (term_not -> empty .)


state 111

    (42) input -> READ ( . n_process_read input1 )
    (45) n_process_read -> . ID

    ID              shift and go to state 163

    n_process_read                 shift and go to state 162

state 112

    (38) while -> WHILE n_while_1 . ( expression ) n_while_2 block n_while_3

    (               shift and go to state 164


state 113

    (46) output -> PRINT ( . n_output_quad output1 )
    (49) n_output_quad -> . expression
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    n_output_quad                  shift and go to state 165
    exp                            shift and go to state 108
    expression                     shift and go to state 166
    empty                          shift and go to state 110

state 114

    (139) map_assignment -> map_access ASSIGNATOR . n_quad_assign exp
    (32) n_quad_assign -> .

    !               reduce using rule 32 (n_quad_assign -> .)
    (               reduce using rule 32 (n_quad_assign -> .)
    ID              reduce using rule 32 (n_quad_assign -> .)
    CTE_INT         reduce using rule 32 (n_quad_assign -> .)
    CTE_FLOAT       reduce using rule 32 (n_quad_assign -> .)
    CTE_BOOL        reduce using rule 32 (n_quad_assign -> .)
    CTE_STRING      reduce using rule 32 (n_quad_assign -> .)
    CTE_CHAR        reduce using rule 32 (n_quad_assign -> .)

    n_quad_assign                  shift and go to state 167

state 115

    (30) assignment -> assignment2 ASSIGNATOR . n_quad_assign expression
    (32) n_quad_assign -> .

    !               reduce using rule 32 (n_quad_assign -> .)
    (               reduce using rule 32 (n_quad_assign -> .)
    ID              reduce using rule 32 (n_quad_assign -> .)
    CTE_INT         reduce using rule 32 (n_quad_assign -> .)
    CTE_FLOAT       reduce using rule 32 (n_quad_assign -> .)
    CTE_BOOL        reduce using rule 32 (n_quad_assign -> .)
    CTE_STRING      reduce using rule 32 (n_quad_assign -> .)
    CTE_CHAR        reduce using rule 32 (n_quad_assign -> .)

    n_quad_assign                  shift and go to state 168

state 116

    (22) proc4 -> statement proc4 .

    }               reduce using rule 22 (proc4 -> statement proc4 .)


state 117

    (61) statement -> statement1 ; .

    READ            reduce using rule 61 (statement -> statement1 ; .)
    PRINT           reduce using rule 61 (statement -> statement1 ; .)
    ID              reduce using rule 61 (statement -> statement1 ; .)
    MAP             reduce using rule 61 (statement -> statement1 ; .)
    RETURN          reduce using rule 61 (statement -> statement1 ; .)
    IF              reduce using rule 61 (statement -> statement1 ; .)
    WHILE           reduce using rule 61 (statement -> statement1 ; .)
    }               reduce using rule 61 (statement -> statement1 ; .)


state 118

    (53) function_call1 -> function_call2 .

    )               reduce using rule 53 (function_call1 -> function_call2 .)


state 119

    (50) function_call -> n_era_size function_call1 . )

    )               shift and go to state 169


state 120

    (57) n_verify_argument -> expression .

    ,               reduce using rule 57 (n_verify_argument -> expression .)
    )               reduce using rule 57 (n_verify_argument -> expression .)


state 121

    (54) function_call2 -> n_verify_argument . , n_add_one_to_counter function_call2
    (55) function_call2 -> n_verify_argument .

    ,               shift and go to state 170
    )               reduce using rule 55 (function_call2 -> n_verify_argument .)


state 122

    (52) function_call1 -> empty .
    (104) term_not -> empty .

    )               reduce using rule 52 (function_call1 -> empty .)
    (               reduce using rule 104 (term_not -> empty .)
    ID              reduce using rule 104 (term_not -> empty .)
    CTE_INT         reduce using rule 104 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 104 (term_not -> empty .)
    CTE_BOOL        reduce using rule 104 (term_not -> empty .)
    CTE_STRING      reduce using rule 104 (term_not -> empty .)
    CTE_CHAR        reduce using rule 104 (term_not -> empty .)


state 123

    (51) n_era_size -> ID ( .

    !               reduce using rule 51 (n_era_size -> ID ( .)
    )               reduce using rule 51 (n_era_size -> ID ( .)
    (               reduce using rule 51 (n_era_size -> ID ( .)
    ID              reduce using rule 51 (n_era_size -> ID ( .)
    CTE_INT         reduce using rule 51 (n_era_size -> ID ( .)
    CTE_FLOAT       reduce using rule 51 (n_era_size -> ID ( .)
    CTE_BOOL        reduce using rule 51 (n_era_size -> ID ( .)
    CTE_STRING      reduce using rule 51 (n_era_size -> ID ( .)
    CTE_CHAR        reduce using rule 51 (n_era_size -> ID ( .)


state 124

    (59) container_operation -> ID . . OP_ARGS ( expression )
    (60) container_operation -> ID . . OP ( )

    OP_ARGS         shift and go to state 171
    OP              shift and go to state 172


state 125

    (138) map_access -> ID [ . expression ]
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    exp                            shift and go to state 108
    expression                     shift and go to state 173
    empty                          shift and go to state 110

state 126

    (33) condition -> IF ( . expression n_while_2 ) block condition1
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp                            shift and go to state 108
    exp0                           shift and go to state 106
    empty                          shift and go to state 110
    expression                     shift and go to state 174

state 127

    (132) main -> MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux } .

    $end            reduce using rule 132 (main -> MAIN n_clear_scope n_main_quad2 { vars_aux statement_aux } .)


state 128

    (130) statement_aux -> statement statement_aux .

    }               reduce using rule 130 (statement_aux -> statement statement_aux .)


state 129

    (116) varcte1 -> function_call .

    *               reduce using rule 116 (varcte1 -> function_call .)
    /               reduce using rule 116 (varcte1 -> function_call .)
    SET_MATH_MULDIV reduce using rule 116 (varcte1 -> function_call .)
    +               reduce using rule 116 (varcte1 -> function_call .)
    -               reduce using rule 116 (varcte1 -> function_call .)
    SET_MATH_ADDSUB reduce using rule 116 (varcte1 -> function_call .)
    <               reduce using rule 116 (varcte1 -> function_call .)
    >               reduce using rule 116 (varcte1 -> function_call .)
    NOT_EQ          reduce using rule 116 (varcte1 -> function_call .)
    EQ              reduce using rule 116 (varcte1 -> function_call .)
    LEQ             reduce using rule 116 (varcte1 -> function_call .)
    GEQ             reduce using rule 116 (varcte1 -> function_call .)
    OR              reduce using rule 116 (varcte1 -> function_call .)
    AND             reduce using rule 116 (varcte1 -> function_call .)
    ;               reduce using rule 116 (varcte1 -> function_call .)
    ,               reduce using rule 116 (varcte1 -> function_call .)
    )               reduce using rule 116 (varcte1 -> function_call .)
    ]               reduce using rule 116 (varcte1 -> function_call .)


state 130

    (110) varcte -> varcte1 .

    *               reduce using rule 110 (varcte -> varcte1 .)
    /               reduce using rule 110 (varcte -> varcte1 .)
    SET_MATH_MULDIV reduce using rule 110 (varcte -> varcte1 .)
    +               reduce using rule 110 (varcte -> varcte1 .)
    -               reduce using rule 110 (varcte -> varcte1 .)
    SET_MATH_ADDSUB reduce using rule 110 (varcte -> varcte1 .)
    <               reduce using rule 110 (varcte -> varcte1 .)
    >               reduce using rule 110 (varcte -> varcte1 .)
    NOT_EQ          reduce using rule 110 (varcte -> varcte1 .)
    EQ              reduce using rule 110 (varcte -> varcte1 .)
    LEQ             reduce using rule 110 (varcte -> varcte1 .)
    GEQ             reduce using rule 110 (varcte -> varcte1 .)
    OR              reduce using rule 110 (varcte -> varcte1 .)
    AND             reduce using rule 110 (varcte -> varcte1 .)
    ;               reduce using rule 110 (varcte -> varcte1 .)
    ,               reduce using rule 110 (varcte -> varcte1 .)
    )               reduce using rule 110 (varcte -> varcte1 .)
    ]               reduce using rule 110 (varcte -> varcte1 .)


state 131

    (106) factor -> varcte .

    *               reduce using rule 106 (factor -> varcte .)
    /               reduce using rule 106 (factor -> varcte .)
    SET_MATH_MULDIV reduce using rule 106 (factor -> varcte .)
    +               reduce using rule 106 (factor -> varcte .)
    -               reduce using rule 106 (factor -> varcte .)
    SET_MATH_ADDSUB reduce using rule 106 (factor -> varcte .)
    <               reduce using rule 106 (factor -> varcte .)
    >               reduce using rule 106 (factor -> varcte .)
    NOT_EQ          reduce using rule 106 (factor -> varcte .)
    EQ              reduce using rule 106 (factor -> varcte .)
    LEQ             reduce using rule 106 (factor -> varcte .)
    GEQ             reduce using rule 106 (factor -> varcte .)
    OR              reduce using rule 106 (factor -> varcte .)
    AND             reduce using rule 106 (factor -> varcte .)
    ;               reduce using rule 106 (factor -> varcte .)
    ,               reduce using rule 106 (factor -> varcte .)
    )               reduce using rule 106 (factor -> varcte .)
    ]               reduce using rule 106 (factor -> varcte .)


state 132

    (117) varcte1 -> map_access .

    *               reduce using rule 117 (varcte1 -> map_access .)
    /               reduce using rule 117 (varcte1 -> map_access .)
    SET_MATH_MULDIV reduce using rule 117 (varcte1 -> map_access .)
    +               reduce using rule 117 (varcte1 -> map_access .)
    -               reduce using rule 117 (varcte1 -> map_access .)
    SET_MATH_ADDSUB reduce using rule 117 (varcte1 -> map_access .)
    <               reduce using rule 117 (varcte1 -> map_access .)
    >               reduce using rule 117 (varcte1 -> map_access .)
    NOT_EQ          reduce using rule 117 (varcte1 -> map_access .)
    EQ              reduce using rule 117 (varcte1 -> map_access .)
    LEQ             reduce using rule 117 (varcte1 -> map_access .)
    GEQ             reduce using rule 117 (varcte1 -> map_access .)
    OR              reduce using rule 117 (varcte1 -> map_access .)
    AND             reduce using rule 117 (varcte1 -> map_access .)
    ;               reduce using rule 117 (varcte1 -> map_access .)
    ,               reduce using rule 117 (varcte1 -> map_access .)
    )               reduce using rule 117 (varcte1 -> map_access .)
    ]               reduce using rule 117 (varcte1 -> map_access .)


state 133

    (105) factor -> ( . n_push_false_bottom expression ) n_pop_false_bottom
    (107) n_push_false_bottom -> .

    !               reduce using rule 107 (n_push_false_bottom -> .)
    (               reduce using rule 107 (n_push_false_bottom -> .)
    ID              reduce using rule 107 (n_push_false_bottom -> .)
    CTE_INT         reduce using rule 107 (n_push_false_bottom -> .)
    CTE_FLOAT       reduce using rule 107 (n_push_false_bottom -> .)
    CTE_BOOL        reduce using rule 107 (n_push_false_bottom -> .)
    CTE_STRING      reduce using rule 107 (n_push_false_bottom -> .)
    CTE_CHAR        reduce using rule 107 (n_push_false_bottom -> .)

    n_push_false_bottom            shift and go to state 175

state 134

    (97) term -> term_not factor . n_quad_muldiv term2
    (98) n_quad_muldiv -> .

    *               reduce using rule 98 (n_quad_muldiv -> .)
    /               reduce using rule 98 (n_quad_muldiv -> .)
    SET_MATH_MULDIV reduce using rule 98 (n_quad_muldiv -> .)
    +               reduce using rule 98 (n_quad_muldiv -> .)
    -               reduce using rule 98 (n_quad_muldiv -> .)
    SET_MATH_ADDSUB reduce using rule 98 (n_quad_muldiv -> .)
    <               reduce using rule 98 (n_quad_muldiv -> .)
    >               reduce using rule 98 (n_quad_muldiv -> .)
    NOT_EQ          reduce using rule 98 (n_quad_muldiv -> .)
    EQ              reduce using rule 98 (n_quad_muldiv -> .)
    LEQ             reduce using rule 98 (n_quad_muldiv -> .)
    GEQ             reduce using rule 98 (n_quad_muldiv -> .)
    OR              reduce using rule 98 (n_quad_muldiv -> .)
    AND             reduce using rule 98 (n_quad_muldiv -> .)
    ;               reduce using rule 98 (n_quad_muldiv -> .)
    ,               reduce using rule 98 (n_quad_muldiv -> .)
    )               reduce using rule 98 (n_quad_muldiv -> .)
    ]               reduce using rule 98 (n_quad_muldiv -> .)

    n_quad_muldiv                  shift and go to state 176

state 135

    (115) varcte1 -> CTE_CHAR .

    *               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    /               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    SET_MATH_MULDIV reduce using rule 115 (varcte1 -> CTE_CHAR .)
    +               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    -               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    SET_MATH_ADDSUB reduce using rule 115 (varcte1 -> CTE_CHAR .)
    <               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    >               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    NOT_EQ          reduce using rule 115 (varcte1 -> CTE_CHAR .)
    EQ              reduce using rule 115 (varcte1 -> CTE_CHAR .)
    LEQ             reduce using rule 115 (varcte1 -> CTE_CHAR .)
    GEQ             reduce using rule 115 (varcte1 -> CTE_CHAR .)
    OR              reduce using rule 115 (varcte1 -> CTE_CHAR .)
    AND             reduce using rule 115 (varcte1 -> CTE_CHAR .)
    ;               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    ,               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    )               reduce using rule 115 (varcte1 -> CTE_CHAR .)
    ]               reduce using rule 115 (varcte1 -> CTE_CHAR .)


state 136

    (118) varcte1 -> container_operation .

    *               reduce using rule 118 (varcte1 -> container_operation .)
    /               reduce using rule 118 (varcte1 -> container_operation .)
    SET_MATH_MULDIV reduce using rule 118 (varcte1 -> container_operation .)
    +               reduce using rule 118 (varcte1 -> container_operation .)
    -               reduce using rule 118 (varcte1 -> container_operation .)
    SET_MATH_ADDSUB reduce using rule 118 (varcte1 -> container_operation .)
    <               reduce using rule 118 (varcte1 -> container_operation .)
    >               reduce using rule 118 (varcte1 -> container_operation .)
    NOT_EQ          reduce using rule 118 (varcte1 -> container_operation .)
    EQ              reduce using rule 118 (varcte1 -> container_operation .)
    LEQ             reduce using rule 118 (varcte1 -> container_operation .)
    GEQ             reduce using rule 118 (varcte1 -> container_operation .)
    OR              reduce using rule 118 (varcte1 -> container_operation .)
    AND             reduce using rule 118 (varcte1 -> container_operation .)
    ;               reduce using rule 118 (varcte1 -> container_operation .)
    ,               reduce using rule 118 (varcte1 -> container_operation .)
    )               reduce using rule 118 (varcte1 -> container_operation .)
    ]               reduce using rule 118 (varcte1 -> container_operation .)


state 137

    (111) varcte1 -> CTE_INT .

    *               reduce using rule 111 (varcte1 -> CTE_INT .)
    /               reduce using rule 111 (varcte1 -> CTE_INT .)
    SET_MATH_MULDIV reduce using rule 111 (varcte1 -> CTE_INT .)
    +               reduce using rule 111 (varcte1 -> CTE_INT .)
    -               reduce using rule 111 (varcte1 -> CTE_INT .)
    SET_MATH_ADDSUB reduce using rule 111 (varcte1 -> CTE_INT .)
    <               reduce using rule 111 (varcte1 -> CTE_INT .)
    >               reduce using rule 111 (varcte1 -> CTE_INT .)
    NOT_EQ          reduce using rule 111 (varcte1 -> CTE_INT .)
    EQ              reduce using rule 111 (varcte1 -> CTE_INT .)
    LEQ             reduce using rule 111 (varcte1 -> CTE_INT .)
    GEQ             reduce using rule 111 (varcte1 -> CTE_INT .)
    OR              reduce using rule 111 (varcte1 -> CTE_INT .)
    AND             reduce using rule 111 (varcte1 -> CTE_INT .)
    ;               reduce using rule 111 (varcte1 -> CTE_INT .)
    ,               reduce using rule 111 (varcte1 -> CTE_INT .)
    )               reduce using rule 111 (varcte1 -> CTE_INT .)
    ]               reduce using rule 111 (varcte1 -> CTE_INT .)


state 138

    (109) varcte -> ID . empty
    (138) map_access -> ID . [ expression ]
    (59) container_operation -> ID . . OP_ARGS ( expression )
    (60) container_operation -> ID . . OP ( )
    (51) n_era_size -> ID . (
    (140) empty -> .

    [               shift and go to state 125
    .               shift and go to state 124
    (               shift and go to state 123
    *               reduce using rule 140 (empty -> .)
    /               reduce using rule 140 (empty -> .)
    SET_MATH_MULDIV reduce using rule 140 (empty -> .)
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    SET_MATH_ADDSUB reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    NOT_EQ          reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    LEQ             reduce using rule 140 (empty -> .)
    GEQ             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 177

state 139

    (112) varcte1 -> CTE_FLOAT .

    *               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    /               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    SET_MATH_MULDIV reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    +               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    -               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    SET_MATH_ADDSUB reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    <               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    >               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    NOT_EQ          reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    EQ              reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    LEQ             reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    GEQ             reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    OR              reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    AND             reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    ;               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    ,               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    )               reduce using rule 112 (varcte1 -> CTE_FLOAT .)
    ]               reduce using rule 112 (varcte1 -> CTE_FLOAT .)


state 140

    (113) varcte1 -> CTE_BOOL .

    *               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    /               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    SET_MATH_MULDIV reduce using rule 113 (varcte1 -> CTE_BOOL .)
    +               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    -               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    SET_MATH_ADDSUB reduce using rule 113 (varcte1 -> CTE_BOOL .)
    <               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    >               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    NOT_EQ          reduce using rule 113 (varcte1 -> CTE_BOOL .)
    EQ              reduce using rule 113 (varcte1 -> CTE_BOOL .)
    LEQ             reduce using rule 113 (varcte1 -> CTE_BOOL .)
    GEQ             reduce using rule 113 (varcte1 -> CTE_BOOL .)
    OR              reduce using rule 113 (varcte1 -> CTE_BOOL .)
    AND             reduce using rule 113 (varcte1 -> CTE_BOOL .)
    ;               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    ,               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    )               reduce using rule 113 (varcte1 -> CTE_BOOL .)
    ]               reduce using rule 113 (varcte1 -> CTE_BOOL .)


state 141

    (114) varcte1 -> CTE_STRING .

    *               reduce using rule 114 (varcte1 -> CTE_STRING .)
    /               reduce using rule 114 (varcte1 -> CTE_STRING .)
    SET_MATH_MULDIV reduce using rule 114 (varcte1 -> CTE_STRING .)
    +               reduce using rule 114 (varcte1 -> CTE_STRING .)
    -               reduce using rule 114 (varcte1 -> CTE_STRING .)
    SET_MATH_ADDSUB reduce using rule 114 (varcte1 -> CTE_STRING .)
    <               reduce using rule 114 (varcte1 -> CTE_STRING .)
    >               reduce using rule 114 (varcte1 -> CTE_STRING .)
    NOT_EQ          reduce using rule 114 (varcte1 -> CTE_STRING .)
    EQ              reduce using rule 114 (varcte1 -> CTE_STRING .)
    LEQ             reduce using rule 114 (varcte1 -> CTE_STRING .)
    GEQ             reduce using rule 114 (varcte1 -> CTE_STRING .)
    OR              reduce using rule 114 (varcte1 -> CTE_STRING .)
    AND             reduce using rule 114 (varcte1 -> CTE_STRING .)
    ;               reduce using rule 114 (varcte1 -> CTE_STRING .)
    ,               reduce using rule 114 (varcte1 -> CTE_STRING .)
    )               reduce using rule 114 (varcte1 -> CTE_STRING .)
    ]               reduce using rule 114 (varcte1 -> CTE_STRING .)


state 142

    (88) exp -> term exp2 .

    <               reduce using rule 88 (exp -> term exp2 .)
    >               reduce using rule 88 (exp -> term exp2 .)
    NOT_EQ          reduce using rule 88 (exp -> term exp2 .)
    EQ              reduce using rule 88 (exp -> term exp2 .)
    LEQ             reduce using rule 88 (exp -> term exp2 .)
    GEQ             reduce using rule 88 (exp -> term exp2 .)
    OR              reduce using rule 88 (exp -> term exp2 .)
    AND             reduce using rule 88 (exp -> term exp2 .)
    ,               reduce using rule 88 (exp -> term exp2 .)
    )               reduce using rule 88 (exp -> term exp2 .)
    ;               reduce using rule 88 (exp -> term exp2 .)
    ]               reduce using rule 88 (exp -> term exp2 .)


state 143

    (89) addsub -> + .

    !               reduce using rule 89 (addsub -> + .)
    (               reduce using rule 89 (addsub -> + .)
    ID              reduce using rule 89 (addsub -> + .)
    CTE_INT         reduce using rule 89 (addsub -> + .)
    CTE_FLOAT       reduce using rule 89 (addsub -> + .)
    CTE_BOOL        reduce using rule 89 (addsub -> + .)
    CTE_STRING      reduce using rule 89 (addsub -> + .)
    CTE_CHAR        reduce using rule 89 (addsub -> + .)


state 144

    (90) addsub -> - .

    !               reduce using rule 90 (addsub -> - .)
    (               reduce using rule 90 (addsub -> - .)
    ID              reduce using rule 90 (addsub -> - .)
    CTE_INT         reduce using rule 90 (addsub -> - .)
    CTE_FLOAT       reduce using rule 90 (addsub -> - .)
    CTE_BOOL        reduce using rule 90 (addsub -> - .)
    CTE_STRING      reduce using rule 90 (addsub -> - .)
    CTE_CHAR        reduce using rule 90 (addsub -> - .)


state 145

    (95) exp2 -> addsub . term n_quad_addsub exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 178
    empty                          shift and go to state 110

state 146

    (91) addsub -> SET_MATH_ADDSUB .

    !               reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    (               reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    ID              reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    CTE_INT         reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    CTE_FLOAT       reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    CTE_BOOL        reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    CTE_STRING      reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)
    CTE_CHAR        reduce using rule 91 (addsub -> SET_MATH_ADDSUB .)


state 147

    (96) exp2 -> empty .

    <               reduce using rule 96 (exp2 -> empty .)
    >               reduce using rule 96 (exp2 -> empty .)
    NOT_EQ          reduce using rule 96 (exp2 -> empty .)
    EQ              reduce using rule 96 (exp2 -> empty .)
    LEQ             reduce using rule 96 (exp2 -> empty .)
    GEQ             reduce using rule 96 (exp2 -> empty .)
    OR              reduce using rule 96 (exp2 -> empty .)
    AND             reduce using rule 96 (exp2 -> empty .)
    ;               reduce using rule 96 (exp2 -> empty .)
    ,               reduce using rule 96 (exp2 -> empty .)
    )               reduce using rule 96 (exp2 -> empty .)
    ]               reduce using rule 96 (exp2 -> empty .)


state 148

    (80) logop -> AND .

    !               reduce using rule 80 (logop -> AND .)
    (               reduce using rule 80 (logop -> AND .)
    ID              reduce using rule 80 (logop -> AND .)
    CTE_INT         reduce using rule 80 (logop -> AND .)
    CTE_FLOAT       reduce using rule 80 (logop -> AND .)
    CTE_BOOL        reduce using rule 80 (logop -> AND .)
    CTE_STRING      reduce using rule 80 (logop -> AND .)
    CTE_CHAR        reduce using rule 80 (logop -> AND .)


state 149

    (82) expression2 -> logop . exp0 n_quad_logop expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    exp0                           shift and go to state 179
    term                           shift and go to state 105
    exp                            shift and go to state 108
    empty                          shift and go to state 110

state 150

    (81) expression -> exp0 expression2 .

    ;               reduce using rule 81 (expression -> exp0 expression2 .)
    ,               reduce using rule 81 (expression -> exp0 expression2 .)
    )               reduce using rule 81 (expression -> exp0 expression2 .)
    ]               reduce using rule 81 (expression -> exp0 expression2 .)


state 151

    (79) logop -> OR .

    !               reduce using rule 79 (logop -> OR .)
    (               reduce using rule 79 (logop -> OR .)
    ID              reduce using rule 79 (logop -> OR .)
    CTE_INT         reduce using rule 79 (logop -> OR .)
    CTE_FLOAT       reduce using rule 79 (logop -> OR .)
    CTE_BOOL        reduce using rule 79 (logop -> OR .)
    CTE_STRING      reduce using rule 79 (logop -> OR .)
    CTE_CHAR        reduce using rule 79 (logop -> OR .)


state 152

    (83) expression2 -> empty .

    ;               reduce using rule 83 (expression2 -> empty .)
    ,               reduce using rule 83 (expression2 -> empty .)
    )               reduce using rule 83 (expression2 -> empty .)
    ]               reduce using rule 83 (expression2 -> empty .)


state 153

    (78) relop -> GEQ .

    !               reduce using rule 78 (relop -> GEQ .)
    (               reduce using rule 78 (relop -> GEQ .)
    ID              reduce using rule 78 (relop -> GEQ .)
    CTE_INT         reduce using rule 78 (relop -> GEQ .)
    CTE_FLOAT       reduce using rule 78 (relop -> GEQ .)
    CTE_BOOL        reduce using rule 78 (relop -> GEQ .)
    CTE_STRING      reduce using rule 78 (relop -> GEQ .)
    CTE_CHAR        reduce using rule 78 (relop -> GEQ .)


state 154

    (86) exp02 -> relop . exp
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp                            shift and go to state 180
    empty                          shift and go to state 110

state 155

    (75) relop -> NOT_EQ .

    !               reduce using rule 75 (relop -> NOT_EQ .)
    (               reduce using rule 75 (relop -> NOT_EQ .)
    ID              reduce using rule 75 (relop -> NOT_EQ .)
    CTE_INT         reduce using rule 75 (relop -> NOT_EQ .)
    CTE_FLOAT       reduce using rule 75 (relop -> NOT_EQ .)
    CTE_BOOL        reduce using rule 75 (relop -> NOT_EQ .)
    CTE_STRING      reduce using rule 75 (relop -> NOT_EQ .)
    CTE_CHAR        reduce using rule 75 (relop -> NOT_EQ .)


state 156

    (77) relop -> LEQ .

    !               reduce using rule 77 (relop -> LEQ .)
    (               reduce using rule 77 (relop -> LEQ .)
    ID              reduce using rule 77 (relop -> LEQ .)
    CTE_INT         reduce using rule 77 (relop -> LEQ .)
    CTE_FLOAT       reduce using rule 77 (relop -> LEQ .)
    CTE_BOOL        reduce using rule 77 (relop -> LEQ .)
    CTE_STRING      reduce using rule 77 (relop -> LEQ .)
    CTE_CHAR        reduce using rule 77 (relop -> LEQ .)


state 157

    (85) exp0 -> exp exp02 .

    OR              reduce using rule 85 (exp0 -> exp exp02 .)
    AND             reduce using rule 85 (exp0 -> exp exp02 .)
    )               reduce using rule 85 (exp0 -> exp exp02 .)
    ;               reduce using rule 85 (exp0 -> exp exp02 .)
    ,               reduce using rule 85 (exp0 -> exp exp02 .)
    ]               reduce using rule 85 (exp0 -> exp exp02 .)


state 158

    (76) relop -> EQ .

    !               reduce using rule 76 (relop -> EQ .)
    (               reduce using rule 76 (relop -> EQ .)
    ID              reduce using rule 76 (relop -> EQ .)
    CTE_INT         reduce using rule 76 (relop -> EQ .)
    CTE_FLOAT       reduce using rule 76 (relop -> EQ .)
    CTE_BOOL        reduce using rule 76 (relop -> EQ .)
    CTE_STRING      reduce using rule 76 (relop -> EQ .)
    CTE_CHAR        reduce using rule 76 (relop -> EQ .)


state 159

    (73) relop -> < .

    !               reduce using rule 73 (relop -> < .)
    (               reduce using rule 73 (relop -> < .)
    ID              reduce using rule 73 (relop -> < .)
    CTE_INT         reduce using rule 73 (relop -> < .)
    CTE_FLOAT       reduce using rule 73 (relop -> < .)
    CTE_BOOL        reduce using rule 73 (relop -> < .)
    CTE_STRING      reduce using rule 73 (relop -> < .)
    CTE_CHAR        reduce using rule 73 (relop -> < .)


state 160

    (87) exp02 -> empty .

    OR              reduce using rule 87 (exp02 -> empty .)
    AND             reduce using rule 87 (exp02 -> empty .)
    ;               reduce using rule 87 (exp02 -> empty .)
    ,               reduce using rule 87 (exp02 -> empty .)
    )               reduce using rule 87 (exp02 -> empty .)
    ]               reduce using rule 87 (exp02 -> empty .)


state 161

    (74) relop -> > .

    !               reduce using rule 74 (relop -> > .)
    (               reduce using rule 74 (relop -> > .)
    ID              reduce using rule 74 (relop -> > .)
    CTE_INT         reduce using rule 74 (relop -> > .)
    CTE_FLOAT       reduce using rule 74 (relop -> > .)
    CTE_BOOL        reduce using rule 74 (relop -> > .)
    CTE_STRING      reduce using rule 74 (relop -> > .)
    CTE_CHAR        reduce using rule 74 (relop -> > .)


state 162

    (42) input -> READ ( n_process_read . input1 )
    (43) input1 -> . , n_process_read input1
    (44) input1 -> . empty
    (140) empty -> .

    ,               shift and go to state 182
    )               reduce using rule 140 (empty -> .)

    input1                         shift and go to state 181
    empty                          shift and go to state 183

state 163

    (45) n_process_read -> ID .

    ,               reduce using rule 45 (n_process_read -> ID .)
    )               reduce using rule 45 (n_process_read -> ID .)


state 164

    (38) while -> WHILE n_while_1 ( . expression ) n_while_2 block n_while_3
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp                            shift and go to state 108
    exp0                           shift and go to state 106
    empty                          shift and go to state 110
    expression                     shift and go to state 184

state 165

    (46) output -> PRINT ( n_output_quad . output1 )
    (47) output1 -> . , n_output_quad output1
    (48) output1 -> . empty
    (140) empty -> .

    ,               shift and go to state 186
    )               reduce using rule 140 (empty -> .)

    output1                        shift and go to state 185
    empty                          shift and go to state 187

state 166

    (49) n_output_quad -> expression .

    ,               reduce using rule 49 (n_output_quad -> expression .)
    )               reduce using rule 49 (n_output_quad -> expression .)


state 167

    (139) map_assignment -> map_access ASSIGNATOR n_quad_assign . exp
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp                            shift and go to state 188
    empty                          shift and go to state 110

state 168

    (30) assignment -> assignment2 ASSIGNATOR n_quad_assign . expression
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    exp                            shift and go to state 108
    expression                     shift and go to state 189
    empty                          shift and go to state 110

state 169

    (50) function_call -> n_era_size function_call1 ) .

    ;               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    *               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    /               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    SET_MATH_MULDIV reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    +               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    -               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    SET_MATH_ADDSUB reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    <               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    >               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    NOT_EQ          reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    EQ              reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    LEQ             reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    GEQ             reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    OR              reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    AND             reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    ,               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    )               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)
    ]               reduce using rule 50 (function_call -> n_era_size function_call1 ) .)


state 170

    (54) function_call2 -> n_verify_argument , . n_add_one_to_counter function_call2
    (56) n_add_one_to_counter -> .

    !               reduce using rule 56 (n_add_one_to_counter -> .)
    (               reduce using rule 56 (n_add_one_to_counter -> .)
    ID              reduce using rule 56 (n_add_one_to_counter -> .)
    CTE_INT         reduce using rule 56 (n_add_one_to_counter -> .)
    CTE_FLOAT       reduce using rule 56 (n_add_one_to_counter -> .)
    CTE_BOOL        reduce using rule 56 (n_add_one_to_counter -> .)
    CTE_STRING      reduce using rule 56 (n_add_one_to_counter -> .)
    CTE_CHAR        reduce using rule 56 (n_add_one_to_counter -> .)

    n_add_one_to_counter           shift and go to state 190

state 171

    (59) container_operation -> ID . OP_ARGS . ( expression )

    (               shift and go to state 191


state 172

    (60) container_operation -> ID . OP . ( )

    (               shift and go to state 192


state 173

    (138) map_access -> ID [ expression . ]

    ]               shift and go to state 193


state 174

    (33) condition -> IF ( expression . n_while_2 ) block condition1
    (40) n_while_2 -> .

    )               reduce using rule 40 (n_while_2 -> .)

    n_while_2                      shift and go to state 194

state 175

    (105) factor -> ( n_push_false_bottom . expression ) n_pop_false_bottom
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    exp                            shift and go to state 108
    expression                     shift and go to state 195
    empty                          shift and go to state 110

state 176

    (97) term -> term_not factor n_quad_muldiv . term2
    (100) term2 -> . muldiv factor n_quad_muldiv term2
    (101) term2 -> . n_quad_not
    (92) muldiv -> . *
    (93) muldiv -> . /
    (94) muldiv -> . SET_MATH_MULDIV
    (102) n_quad_not -> .

    *               shift and go to state 198
    /               shift and go to state 200
    SET_MATH_MULDIV shift and go to state 196
    +               reduce using rule 102 (n_quad_not -> .)
    -               reduce using rule 102 (n_quad_not -> .)
    SET_MATH_ADDSUB reduce using rule 102 (n_quad_not -> .)
    <               reduce using rule 102 (n_quad_not -> .)
    >               reduce using rule 102 (n_quad_not -> .)
    NOT_EQ          reduce using rule 102 (n_quad_not -> .)
    EQ              reduce using rule 102 (n_quad_not -> .)
    LEQ             reduce using rule 102 (n_quad_not -> .)
    GEQ             reduce using rule 102 (n_quad_not -> .)
    OR              reduce using rule 102 (n_quad_not -> .)
    AND             reduce using rule 102 (n_quad_not -> .)
    ;               reduce using rule 102 (n_quad_not -> .)
    ,               reduce using rule 102 (n_quad_not -> .)
    )               reduce using rule 102 (n_quad_not -> .)
    ]               reduce using rule 102 (n_quad_not -> .)

    term2                          shift and go to state 197
    n_quad_not                     shift and go to state 199
    muldiv                         shift and go to state 201

state 177

    (109) varcte -> ID empty .

    *               reduce using rule 109 (varcte -> ID empty .)
    /               reduce using rule 109 (varcte -> ID empty .)
    SET_MATH_MULDIV reduce using rule 109 (varcte -> ID empty .)
    +               reduce using rule 109 (varcte -> ID empty .)
    -               reduce using rule 109 (varcte -> ID empty .)
    SET_MATH_ADDSUB reduce using rule 109 (varcte -> ID empty .)
    <               reduce using rule 109 (varcte -> ID empty .)
    >               reduce using rule 109 (varcte -> ID empty .)
    NOT_EQ          reduce using rule 109 (varcte -> ID empty .)
    EQ              reduce using rule 109 (varcte -> ID empty .)
    LEQ             reduce using rule 109 (varcte -> ID empty .)
    GEQ             reduce using rule 109 (varcte -> ID empty .)
    OR              reduce using rule 109 (varcte -> ID empty .)
    AND             reduce using rule 109 (varcte -> ID empty .)
    ;               reduce using rule 109 (varcte -> ID empty .)
    ,               reduce using rule 109 (varcte -> ID empty .)
    )               reduce using rule 109 (varcte -> ID empty .)
    ]               reduce using rule 109 (varcte -> ID empty .)


state 178

    (95) exp2 -> addsub term . n_quad_addsub exp2
    (99) n_quad_addsub -> .

    +               reduce using rule 99 (n_quad_addsub -> .)
    -               reduce using rule 99 (n_quad_addsub -> .)
    SET_MATH_ADDSUB reduce using rule 99 (n_quad_addsub -> .)
    <               reduce using rule 99 (n_quad_addsub -> .)
    >               reduce using rule 99 (n_quad_addsub -> .)
    NOT_EQ          reduce using rule 99 (n_quad_addsub -> .)
    EQ              reduce using rule 99 (n_quad_addsub -> .)
    LEQ             reduce using rule 99 (n_quad_addsub -> .)
    GEQ             reduce using rule 99 (n_quad_addsub -> .)
    OR              reduce using rule 99 (n_quad_addsub -> .)
    AND             reduce using rule 99 (n_quad_addsub -> .)
    ;               reduce using rule 99 (n_quad_addsub -> .)
    ,               reduce using rule 99 (n_quad_addsub -> .)
    )               reduce using rule 99 (n_quad_addsub -> .)
    ]               reduce using rule 99 (n_quad_addsub -> .)

    n_quad_addsub                  shift and go to state 202

state 179

    (82) expression2 -> logop exp0 . n_quad_logop expression2
    (84) n_quad_logop -> .

    OR              reduce using rule 84 (n_quad_logop -> .)
    AND             reduce using rule 84 (n_quad_logop -> .)
    ;               reduce using rule 84 (n_quad_logop -> .)
    ,               reduce using rule 84 (n_quad_logop -> .)
    )               reduce using rule 84 (n_quad_logop -> .)
    ]               reduce using rule 84 (n_quad_logop -> .)

    n_quad_logop                   shift and go to state 203

state 180

    (86) exp02 -> relop exp .

    OR              reduce using rule 86 (exp02 -> relop exp .)
    AND             reduce using rule 86 (exp02 -> relop exp .)
    ;               reduce using rule 86 (exp02 -> relop exp .)
    ,               reduce using rule 86 (exp02 -> relop exp .)
    )               reduce using rule 86 (exp02 -> relop exp .)
    ]               reduce using rule 86 (exp02 -> relop exp .)


state 181

    (42) input -> READ ( n_process_read input1 . )

    )               shift and go to state 204


state 182

    (43) input1 -> , . n_process_read input1
    (45) n_process_read -> . ID

    ID              shift and go to state 163

    n_process_read                 shift and go to state 205

state 183

    (44) input1 -> empty .

    )               reduce using rule 44 (input1 -> empty .)


state 184

    (38) while -> WHILE n_while_1 ( expression . ) n_while_2 block n_while_3

    )               shift and go to state 206


state 185

    (46) output -> PRINT ( n_output_quad output1 . )

    )               shift and go to state 207


state 186

    (47) output1 -> , . n_output_quad output1
    (49) n_output_quad -> . expression
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    n_output_quad                  shift and go to state 208
    exp                            shift and go to state 108
    expression                     shift and go to state 166
    empty                          shift and go to state 110

state 187

    (48) output1 -> empty .

    )               reduce using rule 48 (output1 -> empty .)


state 188

    (139) map_assignment -> map_access ASSIGNATOR n_quad_assign exp .

    ;               reduce using rule 139 (map_assignment -> map_access ASSIGNATOR n_quad_assign exp .)


state 189

    (30) assignment -> assignment2 ASSIGNATOR n_quad_assign expression .

    ;               reduce using rule 30 (assignment -> assignment2 ASSIGNATOR n_quad_assign expression .)


state 190

    (54) function_call2 -> n_verify_argument , n_add_one_to_counter . function_call2
    (54) function_call2 -> . n_verify_argument , n_add_one_to_counter function_call2
    (55) function_call2 -> . n_verify_argument
    (57) n_verify_argument -> . expression
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    function_call2                 shift and go to state 209
    exp                            shift and go to state 108
    expression                     shift and go to state 120
    n_verify_argument              shift and go to state 121
    empty                          shift and go to state 110

state 191

    (59) container_operation -> ID . OP_ARGS ( . expression )
    (81) expression -> . exp0 expression2
    (85) exp0 -> . exp exp02
    (88) exp -> . term exp2
    (97) term -> . term_not factor n_quad_muldiv term2
    (103) term_not -> . !
    (104) term_not -> . empty
    (140) empty -> .

    !               shift and go to state 107
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTE_INT         reduce using rule 140 (empty -> .)
    CTE_FLOAT       reduce using rule 140 (empty -> .)
    CTE_BOOL        reduce using rule 140 (empty -> .)
    CTE_STRING      reduce using rule 140 (empty -> .)
    CTE_CHAR        reduce using rule 140 (empty -> .)

    term_not                       shift and go to state 104
    term                           shift and go to state 105
    exp0                           shift and go to state 106
    exp                            shift and go to state 108
    expression                     shift and go to state 210
    empty                          shift and go to state 110

state 192

    (60) container_operation -> ID . OP ( . )

    )               shift and go to state 211


state 193

    (138) map_access -> ID [ expression ] .

    *               reduce using rule 138 (map_access -> ID [ expression ] .)
    /               reduce using rule 138 (map_access -> ID [ expression ] .)
    SET_MATH_MULDIV reduce using rule 138 (map_access -> ID [ expression ] .)
    +               reduce using rule 138 (map_access -> ID [ expression ] .)
    -               reduce using rule 138 (map_access -> ID [ expression ] .)
    SET_MATH_ADDSUB reduce using rule 138 (map_access -> ID [ expression ] .)
    <               reduce using rule 138 (map_access -> ID [ expression ] .)
    >               reduce using rule 138 (map_access -> ID [ expression ] .)
    NOT_EQ          reduce using rule 138 (map_access -> ID [ expression ] .)
    EQ              reduce using rule 138 (map_access -> ID [ expression ] .)
    LEQ             reduce using rule 138 (map_access -> ID [ expression ] .)
    GEQ             reduce using rule 138 (map_access -> ID [ expression ] .)
    OR              reduce using rule 138 (map_access -> ID [ expression ] .)
    AND             reduce using rule 138 (map_access -> ID [ expression ] .)
    ;               reduce using rule 138 (map_access -> ID [ expression ] .)
    ,               reduce using rule 138 (map_access -> ID [ expression ] .)
    )               reduce using rule 138 (map_access -> ID [ expression ] .)
    ]               reduce using rule 138 (map_access -> ID [ expression ] .)
    ASSIGNATOR      reduce using rule 138 (map_access -> ID [ expression ] .)


state 194

    (33) condition -> IF ( expression n_while_2 . ) block condition1

    )               shift and go to state 212


state 195

    (105) factor -> ( n_push_false_bottom expression . ) n_pop_false_bottom

    )               shift and go to state 213


state 196

    (94) muldiv -> SET_MATH_MULDIV .

    (               reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)
    ID              reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)
    CTE_INT         reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)
    CTE_FLOAT       reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)
    CTE_BOOL        reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)
    CTE_STRING      reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)
    CTE_CHAR        reduce using rule 94 (muldiv -> SET_MATH_MULDIV .)


state 197

    (97) term -> term_not factor n_quad_muldiv term2 .

    +               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    -               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    SET_MATH_ADDSUB reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    <               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    >               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    NOT_EQ          reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    EQ              reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    LEQ             reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    GEQ             reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    OR              reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    AND             reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    ;               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    )               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    ,               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)
    ]               reduce using rule 97 (term -> term_not factor n_quad_muldiv term2 .)


state 198

    (92) muldiv -> * .

    (               reduce using rule 92 (muldiv -> * .)
    ID              reduce using rule 92 (muldiv -> * .)
    CTE_INT         reduce using rule 92 (muldiv -> * .)
    CTE_FLOAT       reduce using rule 92 (muldiv -> * .)
    CTE_BOOL        reduce using rule 92 (muldiv -> * .)
    CTE_STRING      reduce using rule 92 (muldiv -> * .)
    CTE_CHAR        reduce using rule 92 (muldiv -> * .)


state 199

    (101) term2 -> n_quad_not .

    +               reduce using rule 101 (term2 -> n_quad_not .)
    -               reduce using rule 101 (term2 -> n_quad_not .)
    SET_MATH_ADDSUB reduce using rule 101 (term2 -> n_quad_not .)
    <               reduce using rule 101 (term2 -> n_quad_not .)
    >               reduce using rule 101 (term2 -> n_quad_not .)
    NOT_EQ          reduce using rule 101 (term2 -> n_quad_not .)
    EQ              reduce using rule 101 (term2 -> n_quad_not .)
    LEQ             reduce using rule 101 (term2 -> n_quad_not .)
    GEQ             reduce using rule 101 (term2 -> n_quad_not .)
    OR              reduce using rule 101 (term2 -> n_quad_not .)
    AND             reduce using rule 101 (term2 -> n_quad_not .)
    ;               reduce using rule 101 (term2 -> n_quad_not .)
    ,               reduce using rule 101 (term2 -> n_quad_not .)
    )               reduce using rule 101 (term2 -> n_quad_not .)
    ]               reduce using rule 101 (term2 -> n_quad_not .)


state 200

    (93) muldiv -> / .

    (               reduce using rule 93 (muldiv -> / .)
    ID              reduce using rule 93 (muldiv -> / .)
    CTE_INT         reduce using rule 93 (muldiv -> / .)
    CTE_FLOAT       reduce using rule 93 (muldiv -> / .)
    CTE_BOOL        reduce using rule 93 (muldiv -> / .)
    CTE_STRING      reduce using rule 93 (muldiv -> / .)
    CTE_CHAR        reduce using rule 93 (muldiv -> / .)


state 201

    (100) term2 -> muldiv . factor n_quad_muldiv term2
    (105) factor -> . ( n_push_false_bottom expression ) n_pop_false_bottom
    (106) factor -> . varcte
    (109) varcte -> . ID empty
    (110) varcte -> . varcte1
    (111) varcte1 -> . CTE_INT
    (112) varcte1 -> . CTE_FLOAT
    (113) varcte1 -> . CTE_BOOL
    (114) varcte1 -> . CTE_STRING
    (115) varcte1 -> . CTE_CHAR
    (116) varcte1 -> . function_call
    (117) varcte1 -> . map_access
    (118) varcte1 -> . container_operation
    (50) function_call -> . n_era_size function_call1 )
    (138) map_access -> . ID [ expression ]
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (51) n_era_size -> . ID (

    (               shift and go to state 133
    ID              shift and go to state 138
    CTE_INT         shift and go to state 137
    CTE_FLOAT       shift and go to state 139
    CTE_BOOL        shift and go to state 140
    CTE_STRING      shift and go to state 141
    CTE_CHAR        shift and go to state 135

    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 136
    map_access                     shift and go to state 132
    function_call                  shift and go to state 129
    factor                         shift and go to state 214
    varcte1                        shift and go to state 130
    varcte                         shift and go to state 131

state 202

    (95) exp2 -> addsub term n_quad_addsub . exp2
    (95) exp2 -> . addsub term n_quad_addsub exp2
    (96) exp2 -> . empty
    (89) addsub -> . +
    (90) addsub -> . -
    (91) addsub -> . SET_MATH_ADDSUB
    (140) empty -> .

    +               shift and go to state 143
    -               shift and go to state 144
    SET_MATH_ADDSUB shift and go to state 146
    <               reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    NOT_EQ          reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    LEQ             reduce using rule 140 (empty -> .)
    GEQ             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    exp2                           shift and go to state 215
    addsub                         shift and go to state 145
    empty                          shift and go to state 147

state 203

    (82) expression2 -> logop exp0 n_quad_logop . expression2
    (82) expression2 -> . logop exp0 n_quad_logop expression2
    (83) expression2 -> . empty
    (79) logop -> . OR
    (80) logop -> . AND
    (140) empty -> .

    OR              shift and go to state 151
    AND             shift and go to state 148
    ;               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)

    logop                          shift and go to state 149
    empty                          shift and go to state 152
    expression2                    shift and go to state 216

state 204

    (42) input -> READ ( n_process_read input1 ) .

    ;               reduce using rule 42 (input -> READ ( n_process_read input1 ) .)


state 205

    (43) input1 -> , n_process_read . input1
    (43) input1 -> . , n_process_read input1
    (44) input1 -> . empty
    (140) empty -> .

    ,               shift and go to state 182
    )               reduce using rule 140 (empty -> .)

    input1                         shift and go to state 217
    empty                          shift and go to state 183

state 206

    (38) while -> WHILE n_while_1 ( expression ) . n_while_2 block n_while_3
    (40) n_while_2 -> .

    {               reduce using rule 40 (n_while_2 -> .)

    n_while_2                      shift and go to state 218

state 207

    (46) output -> PRINT ( n_output_quad output1 ) .

    ;               reduce using rule 46 (output -> PRINT ( n_output_quad output1 ) .)


state 208

    (47) output1 -> , n_output_quad . output1
    (47) output1 -> . , n_output_quad output1
    (48) output1 -> . empty
    (140) empty -> .

    ,               shift and go to state 186
    )               reduce using rule 140 (empty -> .)

    output1                        shift and go to state 219
    empty                          shift and go to state 187

state 209

    (54) function_call2 -> n_verify_argument , n_add_one_to_counter function_call2 .

    )               reduce using rule 54 (function_call2 -> n_verify_argument , n_add_one_to_counter function_call2 .)


state 210

    (59) container_operation -> ID . OP_ARGS ( expression . )

    )               shift and go to state 220


state 211

    (60) container_operation -> ID . OP ( ) .

    ;               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    *               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    /               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    SET_MATH_MULDIV reduce using rule 60 (container_operation -> ID . OP ( ) .)
    +               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    -               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    SET_MATH_ADDSUB reduce using rule 60 (container_operation -> ID . OP ( ) .)
    <               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    >               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    NOT_EQ          reduce using rule 60 (container_operation -> ID . OP ( ) .)
    EQ              reduce using rule 60 (container_operation -> ID . OP ( ) .)
    LEQ             reduce using rule 60 (container_operation -> ID . OP ( ) .)
    GEQ             reduce using rule 60 (container_operation -> ID . OP ( ) .)
    OR              reduce using rule 60 (container_operation -> ID . OP ( ) .)
    AND             reduce using rule 60 (container_operation -> ID . OP ( ) .)
    ,               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    )               reduce using rule 60 (container_operation -> ID . OP ( ) .)
    ]               reduce using rule 60 (container_operation -> ID . OP ( ) .)


state 212

    (33) condition -> IF ( expression n_while_2 ) . block condition1
    (129) block -> . { statement_aux }

    {               shift and go to state 221

    block                          shift and go to state 222

state 213

    (105) factor -> ( n_push_false_bottom expression ) . n_pop_false_bottom
    (108) n_pop_false_bottom -> .

    *               reduce using rule 108 (n_pop_false_bottom -> .)
    /               reduce using rule 108 (n_pop_false_bottom -> .)
    SET_MATH_MULDIV reduce using rule 108 (n_pop_false_bottom -> .)
    +               reduce using rule 108 (n_pop_false_bottom -> .)
    -               reduce using rule 108 (n_pop_false_bottom -> .)
    SET_MATH_ADDSUB reduce using rule 108 (n_pop_false_bottom -> .)
    <               reduce using rule 108 (n_pop_false_bottom -> .)
    >               reduce using rule 108 (n_pop_false_bottom -> .)
    NOT_EQ          reduce using rule 108 (n_pop_false_bottom -> .)
    EQ              reduce using rule 108 (n_pop_false_bottom -> .)
    LEQ             reduce using rule 108 (n_pop_false_bottom -> .)
    GEQ             reduce using rule 108 (n_pop_false_bottom -> .)
    OR              reduce using rule 108 (n_pop_false_bottom -> .)
    AND             reduce using rule 108 (n_pop_false_bottom -> .)
    ;               reduce using rule 108 (n_pop_false_bottom -> .)
    ,               reduce using rule 108 (n_pop_false_bottom -> .)
    )               reduce using rule 108 (n_pop_false_bottom -> .)
    ]               reduce using rule 108 (n_pop_false_bottom -> .)

    n_pop_false_bottom             shift and go to state 223

state 214

    (100) term2 -> muldiv factor . n_quad_muldiv term2
    (98) n_quad_muldiv -> .

    *               reduce using rule 98 (n_quad_muldiv -> .)
    /               reduce using rule 98 (n_quad_muldiv -> .)
    SET_MATH_MULDIV reduce using rule 98 (n_quad_muldiv -> .)
    +               reduce using rule 98 (n_quad_muldiv -> .)
    -               reduce using rule 98 (n_quad_muldiv -> .)
    SET_MATH_ADDSUB reduce using rule 98 (n_quad_muldiv -> .)
    <               reduce using rule 98 (n_quad_muldiv -> .)
    >               reduce using rule 98 (n_quad_muldiv -> .)
    NOT_EQ          reduce using rule 98 (n_quad_muldiv -> .)
    EQ              reduce using rule 98 (n_quad_muldiv -> .)
    LEQ             reduce using rule 98 (n_quad_muldiv -> .)
    GEQ             reduce using rule 98 (n_quad_muldiv -> .)
    OR              reduce using rule 98 (n_quad_muldiv -> .)
    AND             reduce using rule 98 (n_quad_muldiv -> .)
    ;               reduce using rule 98 (n_quad_muldiv -> .)
    ,               reduce using rule 98 (n_quad_muldiv -> .)
    )               reduce using rule 98 (n_quad_muldiv -> .)
    ]               reduce using rule 98 (n_quad_muldiv -> .)

    n_quad_muldiv                  shift and go to state 224

state 215

    (95) exp2 -> addsub term n_quad_addsub exp2 .

    <               reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    >               reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    NOT_EQ          reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    EQ              reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    LEQ             reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    GEQ             reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    OR              reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    AND             reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    ;               reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    ,               reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    )               reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)
    ]               reduce using rule 95 (exp2 -> addsub term n_quad_addsub exp2 .)


state 216

    (82) expression2 -> logop exp0 n_quad_logop expression2 .

    ;               reduce using rule 82 (expression2 -> logop exp0 n_quad_logop expression2 .)
    ,               reduce using rule 82 (expression2 -> logop exp0 n_quad_logop expression2 .)
    )               reduce using rule 82 (expression2 -> logop exp0 n_quad_logop expression2 .)
    ]               reduce using rule 82 (expression2 -> logop exp0 n_quad_logop expression2 .)


state 217

    (43) input1 -> , n_process_read input1 .

    )               reduce using rule 43 (input1 -> , n_process_read input1 .)


state 218

    (38) while -> WHILE n_while_1 ( expression ) n_while_2 . block n_while_3
    (129) block -> . { statement_aux }

    {               shift and go to state 221

    block                          shift and go to state 225

state 219

    (47) output1 -> , n_output_quad output1 .

    )               reduce using rule 47 (output1 -> , n_output_quad output1 .)


state 220

    (59) container_operation -> ID . OP_ARGS ( expression ) .

    ;               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    *               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    /               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    SET_MATH_MULDIV reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    +               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    -               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    SET_MATH_ADDSUB reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    <               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    >               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    NOT_EQ          reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    EQ              reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    LEQ             reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    GEQ             reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    OR              reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    AND             reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    ,               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    )               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)
    ]               reduce using rule 59 (container_operation -> ID . OP_ARGS ( expression ) .)


state 221

    (129) block -> { . statement_aux }
    (130) statement_aux -> . statement statement_aux
    (131) statement_aux -> . empty
    (61) statement -> . statement1 ;
    (62) statement -> . statement2
    (140) empty -> .
    (63) statement1 -> . assignment
    (64) statement1 -> . input
    (65) statement1 -> . output
    (66) statement1 -> . container_operation
    (67) statement1 -> . map_definition
    (68) statement1 -> . return
    (69) statement1 -> . map_assignment
    (70) statement1 -> . function_call
    (71) statement2 -> . condition
    (72) statement2 -> . while
    (30) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (42) input -> . READ ( n_process_read input1 )
    (46) output -> . PRINT ( n_output_quad output1 )
    (59) container_operation -> . ID . OP_ARGS ( expression )
    (60) container_operation -> . ID . OP ( )
    (137) map_definition -> . MAP < datatype , datatype >
    (58) return -> . RETURN expression
    (139) map_assignment -> . map_access ASSIGNATOR n_quad_assign exp
    (50) function_call -> . n_era_size function_call1 )
    (33) condition -> . IF ( expression n_while_2 ) block condition1
    (38) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (31) assignment2 -> . ID
    (138) map_access -> . ID [ expression ]
    (51) n_era_size -> . ID (

    }               reduce using rule 140 (empty -> .)
    READ            shift and go to state 75
    PRINT           shift and go to state 79
    ID              shift and go to state 92
    MAP             shift and go to state 18
    RETURN          shift and go to state 74
    IF              shift and go to state 94
    WHILE           shift and go to state 78

    map_definition                 shift and go to state 76
    function_call                  shift and go to state 77
    statement_aux                  shift and go to state 226
    map_access                     shift and go to state 81
    assignment2                    shift and go to state 82
    statement                      shift and go to state 101
    input                          shift and go to state 84
    empty                          shift and go to state 102
    return                         shift and go to state 86
    statement2                     shift and go to state 87
    statement1                     shift and go to state 88
    n_era_size                     shift and go to state 89
    container_operation            shift and go to state 90
    assignment                     shift and go to state 91
    condition                      shift and go to state 93
    map_assignment                 shift and go to state 95
    while                          shift and go to state 96
    output                         shift and go to state 97

state 222

    (33) condition -> IF ( expression n_while_2 ) block . condition1
    (34) condition1 -> . ELSE n_if_2 block n_if_3
    (35) condition1 -> . n_if_3
    (37) n_if_3 -> .

    ELSE            shift and go to state 228
    READ            reduce using rule 37 (n_if_3 -> .)
    PRINT           reduce using rule 37 (n_if_3 -> .)
    ID              reduce using rule 37 (n_if_3 -> .)
    MAP             reduce using rule 37 (n_if_3 -> .)
    RETURN          reduce using rule 37 (n_if_3 -> .)
    IF              reduce using rule 37 (n_if_3 -> .)
    WHILE           reduce using rule 37 (n_if_3 -> .)
    }               reduce using rule 37 (n_if_3 -> .)

    n_if_3                         shift and go to state 227
    condition1                     shift and go to state 229

state 223

    (105) factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .

    *               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    /               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    SET_MATH_MULDIV reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    +               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    -               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    SET_MATH_ADDSUB reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    <               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    >               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    NOT_EQ          reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    EQ              reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    LEQ             reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    GEQ             reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    OR              reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    AND             reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ;               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ,               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    )               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ]               reduce using rule 105 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)


state 224

    (100) term2 -> muldiv factor n_quad_muldiv . term2
    (100) term2 -> . muldiv factor n_quad_muldiv term2
    (101) term2 -> . n_quad_not
    (92) muldiv -> . *
    (93) muldiv -> . /
    (94) muldiv -> . SET_MATH_MULDIV
    (102) n_quad_not -> .

    *               shift and go to state 198
    /               shift and go to state 200
    SET_MATH_MULDIV shift and go to state 196
    +               reduce using rule 102 (n_quad_not -> .)
    -               reduce using rule 102 (n_quad_not -> .)
    SET_MATH_ADDSUB reduce using rule 102 (n_quad_not -> .)
    <               reduce using rule 102 (n_quad_not -> .)
    >               reduce using rule 102 (n_quad_not -> .)
    NOT_EQ          reduce using rule 102 (n_quad_not -> .)
    EQ              reduce using rule 102 (n_quad_not -> .)
    LEQ             reduce using rule 102 (n_quad_not -> .)
    GEQ             reduce using rule 102 (n_quad_not -> .)
    OR              reduce using rule 102 (n_quad_not -> .)
    AND             reduce using rule 102 (n_quad_not -> .)
    ;               reduce using rule 102 (n_quad_not -> .)
    ,               reduce using rule 102 (n_quad_not -> .)
    )               reduce using rule 102 (n_quad_not -> .)
    ]               reduce using rule 102 (n_quad_not -> .)

    term2                          shift and go to state 230
    n_quad_not                     shift and go to state 199
    muldiv                         shift and go to state 201

state 225

    (38) while -> WHILE n_while_1 ( expression ) n_while_2 block . n_while_3
    (41) n_while_3 -> .

    READ            reduce using rule 41 (n_while_3 -> .)
    PRINT           reduce using rule 41 (n_while_3 -> .)
    ID              reduce using rule 41 (n_while_3 -> .)
    MAP             reduce using rule 41 (n_while_3 -> .)
    RETURN          reduce using rule 41 (n_while_3 -> .)
    IF              reduce using rule 41 (n_while_3 -> .)
    WHILE           reduce using rule 41 (n_while_3 -> .)
    }               reduce using rule 41 (n_while_3 -> .)

    n_while_3                      shift and go to state 231

state 226

    (129) block -> { statement_aux . }

    }               shift and go to state 232


state 227

    (35) condition1 -> n_if_3 .

    READ            reduce using rule 35 (condition1 -> n_if_3 .)
    PRINT           reduce using rule 35 (condition1 -> n_if_3 .)
    ID              reduce using rule 35 (condition1 -> n_if_3 .)
    MAP             reduce using rule 35 (condition1 -> n_if_3 .)
    RETURN          reduce using rule 35 (condition1 -> n_if_3 .)
    IF              reduce using rule 35 (condition1 -> n_if_3 .)
    WHILE           reduce using rule 35 (condition1 -> n_if_3 .)
    }               reduce using rule 35 (condition1 -> n_if_3 .)


state 228

    (34) condition1 -> ELSE . n_if_2 block n_if_3
    (36) n_if_2 -> .

    {               reduce using rule 36 (n_if_2 -> .)

    n_if_2                         shift and go to state 233

state 229

    (33) condition -> IF ( expression n_while_2 ) block condition1 .

    READ            reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    PRINT           reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    ID              reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    MAP             reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    RETURN          reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    IF              reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    WHILE           reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)
    }               reduce using rule 33 (condition -> IF ( expression n_while_2 ) block condition1 .)


state 230

    (100) term2 -> muldiv factor n_quad_muldiv term2 .

    +               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    -               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    SET_MATH_ADDSUB reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    <               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    >               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    NOT_EQ          reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    EQ              reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    LEQ             reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    GEQ             reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    OR              reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    AND             reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ;               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ,               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    )               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ]               reduce using rule 100 (term2 -> muldiv factor n_quad_muldiv term2 .)


state 231

    (38) while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .

    READ            reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    PRINT           reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    ID              reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    MAP             reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    RETURN          reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    IF              reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    WHILE           reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    }               reduce using rule 38 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)


state 232

    (129) block -> { statement_aux } .

    ELSE            reduce using rule 129 (block -> { statement_aux } .)
    READ            reduce using rule 129 (block -> { statement_aux } .)
    PRINT           reduce using rule 129 (block -> { statement_aux } .)
    ID              reduce using rule 129 (block -> { statement_aux } .)
    MAP             reduce using rule 129 (block -> { statement_aux } .)
    RETURN          reduce using rule 129 (block -> { statement_aux } .)
    IF              reduce using rule 129 (block -> { statement_aux } .)
    WHILE           reduce using rule 129 (block -> { statement_aux } .)
    }               reduce using rule 129 (block -> { statement_aux } .)


state 233

    (34) condition1 -> ELSE n_if_2 . block n_if_3
    (129) block -> . { statement_aux }

    {               shift and go to state 221

    block                          shift and go to state 234

state 234

    (34) condition1 -> ELSE n_if_2 block . n_if_3
    (37) n_if_3 -> .

    READ            reduce using rule 37 (n_if_3 -> .)
    PRINT           reduce using rule 37 (n_if_3 -> .)
    ID              reduce using rule 37 (n_if_3 -> .)
    MAP             reduce using rule 37 (n_if_3 -> .)
    RETURN          reduce using rule 37 (n_if_3 -> .)
    IF              reduce using rule 37 (n_if_3 -> .)
    WHILE           reduce using rule 37 (n_if_3 -> .)
    }               reduce using rule 37 (n_if_3 -> .)

    n_if_3                         shift and go to state 235

state 235

    (34) condition1 -> ELSE n_if_2 block n_if_3 .

    READ            reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    PRINT           reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    ID              reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    MAP             reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    RETURN          reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    IF              reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    WHILE           reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)
    }               reduce using rule 34 (condition1 -> ELSE n_if_2 block n_if_3 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 5 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 5 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 5 resolved as shift
WARNING: shift/reduce conflict for STRING in state 5 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 5 resolved as shift
WARNING: shift/reduce conflict for SET in state 5 resolved as shift
WARNING: shift/reduce conflict for MAP in state 5 resolved as shift
WARNING: shift/reduce conflict for VOID in state 13 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 13 resolved as shift
WARNING: shift/reduce conflict for INT in state 13 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 13 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 13 resolved as shift
WARNING: shift/reduce conflict for STRING in state 13 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 13 resolved as shift
WARNING: shift/reduce conflict for SET in state 13 resolved as shift
WARNING: shift/reduce conflict for MAP in state 13 resolved as shift
WARNING: shift/reduce conflict for VOID in state 15 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 15 resolved as shift
WARNING: shift/reduce conflict for INT in state 15 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 15 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 15 resolved as shift
WARNING: shift/reduce conflict for STRING in state 15 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 15 resolved as shift
WARNING: shift/reduce conflict for SET in state 15 resolved as shift
WARNING: shift/reduce conflict for MAP in state 15 resolved as shift
WARNING: shift/reduce conflict for MAP in state 57 resolved as shift
WARNING: shift/reduce conflict for MAP in state 62 resolved as shift
WARNING: shift/reduce conflict for MAP in state 65 resolved as shift
WARNING: shift/reduce conflict for MAP in state 71 resolved as shift
