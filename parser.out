Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; program1
Rule 2     program1 -> program2 program3 main
Rule 3     program2 -> vars
Rule 4     program2 -> empty
Rule 5     program3 -> proc program3
Rule 6     program3 -> empty
Rule 7     vars -> datatype vars1 ; vars2
Rule 8     vars1 -> ID , vars1
Rule 9     vars1 -> ID
Rule 10    vars2 -> vars
Rule 11    vars2 -> empty
Rule 12    proc -> functype ID ( proc1 ) { proc3 proc4 }
Rule 13    proc1 -> datatype ID proc2
Rule 14    proc2 -> , proc1
Rule 15    proc2 -> empty
Rule 16    proc3 -> vars
Rule 17    proc3 -> empty
Rule 18    proc4 -> statement proc4
Rule 19    proc4 -> empty
Rule 20    assignment -> ID ASSIGNATOR expression
Rule 21    condition -> IF ( expression ) block condition1
Rule 22    condition1 -> ELSE block
Rule 23    condition1 -> empty
Rule 24    input -> READ ( ID input1 )
Rule 25    input1 -> , ID input1
Rule 26    input1 -> empty
Rule 27    output -> PRINT ( expression output1 )
Rule 28    output1 -> , expression output1
Rule 29    output1 -> empty
Rule 30    function_call -> ID ( function_call1 )
Rule 31    function_call1 -> function_call2
Rule 32    function_call1 -> empty
Rule 33    function_call2 -> expression , function_call2
Rule 34    function_call2 -> empty
Rule 35    return -> RETURN expression
Rule 36    set_operation -> ID . OPERATION ( set_operation1 )
Rule 37    set_operation1 -> expression
Rule 38    set_operation1 -> empty
Rule 39    statement -> statement1 ;
Rule 40    statement -> statement2
Rule 41    statement1 -> assignment
Rule 42    statement1 -> input
Rule 43    statement1 -> output
Rule 44    statement1 -> set_operation
Rule 45    statement1 -> map_definition
Rule 46    statement1 -> return
Rule 47    statement1 -> map_assignment
Rule 48    statement1 -> map_operation
Rule 49    statement2 -> condition
Rule 50    statement2 -> while
Rule 51    while -> WHILE ( expression ) block
Rule 52    relop -> <
Rule 53    relop -> >
Rule 54    relop -> NOT_EQ
Rule 55    relop -> EQ
Rule 56    relop -> LEQ
Rule 57    relop -> GEQ
Rule 58    logop -> OR
Rule 59    logop -> AND
Rule 60    expression -> exp0 expression2
Rule 61    expression2 -> logop exp0 expression2
Rule 62    expression2 -> empty
Rule 63    exp0 -> exp exp02
Rule 64    exp02 -> relop exp02
Rule 65    exp02 -> empty
Rule 66    exp -> term exp2
Rule 67    addsub -> +
Rule 68    addsub -> -
Rule 69    muldiv -> *
Rule 70    muldiv -> /
Rule 71    exp2 -> addsub term exp2
Rule 72    exp2 -> empty
Rule 73    term -> term_not factor term2
Rule 74    term2 -> muldiv factor term2
Rule 75    term2 -> empty
Rule 76    term_not -> !
Rule 77    term_not -> empty
Rule 78    factor -> ( expression )
Rule 79    factor -> factor2
Rule 80    factor2 -> factor3 varcte
Rule 81    factor3 -> addsub
Rule 82    factor3 -> empty
Rule 83    varcte -> ID
Rule 84    varcte -> CTE_INT
Rule 85    varcte -> CTE_FLOAT
Rule 86    varcte -> CTE_BOOL
Rule 87    varcte -> CTE_STRING
Rule 88    varcte -> CTE_CHAR
Rule 89    varcte -> function_call
Rule 90    varcte -> map_access
Rule 91    varcte -> map_operation
Rule 92    varcte -> set_operation
Rule 93    datatype -> INT
Rule 94    datatype -> FLOAT
Rule 95    datatype -> BOOL
Rule 96    datatype -> STRING
Rule 97    datatype -> CHAR
Rule 98    datatype -> set_definition
Rule 99    datatype -> map_definition
Rule 100   set_definition -> SET < datatype >
Rule 101   functype -> datatype
Rule 102   functype -> VOID
Rule 103   block -> { statement_aux }
Rule 104   statement_aux -> statement statement_aux
Rule 105   statement_aux -> empty
Rule 106   main -> MAIN { vars_aux statement_aux }
Rule 107   vars_aux -> vars
Rule 108   vars_aux -> empty
Rule 109   map_definition -> MAP < datatype , datatype >
Rule 110   map_access -> ID ( exp )
Rule 111   map_assignment -> map_access ASSIGNATOR exp
Rule 112   map_operation -> ID . OPERATION ( )
Rule 113   empty -> <empty>

Terminals, with rules where they appear

!                    : 76
(                    : 12 21 24 27 30 36 51 78 110 112
)                    : 12 21 24 27 30 36 51 78 110 112
*                    : 69
+                    : 67
,                    : 8 14 25 28 33 109
-                    : 68
.                    : 36 112
/                    : 70
;                    : 1 7 39
<                    : 52 100 109
>                    : 53 100 109
AND                  : 59
ASSIGNATOR           : 20 111
BOOL                 : 95
CHAR                 : 97
CTE_BOOL             : 86
CTE_CHAR             : 88
CTE_FLOAT            : 85
CTE_INT              : 84
CTE_STRING           : 87
ELSE                 : 22
EQ                   : 55
FLOAT                : 94
GEQ                  : 57
ID                   : 1 8 9 12 13 20 24 25 30 36 83 110 112
IF                   : 21
INT                  : 93
LEQ                  : 56
MAIN                 : 106
MAP                  : 109
NOT_EQ               : 54
OPERATION            : 36 112
OR                   : 58
PRINT                : 27
PROGRAM              : 1
READ                 : 24
RETURN               : 35
SET                  : 100
STRING               : 96
VOID                 : 102
WHILE                : 51
error                : 
{                    : 12 103 106
}                    : 12 103 106

Nonterminals, with rules where they appear

addsub               : 71 81
assignment           : 41
block                : 21 22 51
condition            : 49
condition1           : 21
datatype             : 7 13 100 101 109 109
empty                : 4 6 11 15 17 19 23 26 29 32 34 38 62 65 72 75 77 82 105 108
exp                  : 63 110 111
exp0                 : 60 61
exp02                : 63 64
exp2                 : 66 71
expression           : 20 21 27 28 33 35 37 51 78
expression2          : 60 61
factor               : 73 74
factor2              : 79
factor3              : 80
function_call        : 89
function_call1       : 30
function_call2       : 31 33
functype             : 12
input                : 42
input1               : 24 25
logop                : 61
main                 : 2
map_access           : 90 111
map_assignment       : 47
map_definition       : 45 99
map_operation        : 48 91
muldiv               : 74
output               : 43
output1              : 27 28
proc                 : 5
proc1                : 12 14
proc2                : 13
proc3                : 12
proc4                : 12 18
program              : 0
program1             : 1
program2             : 2
program3             : 2 5
relop                : 64
return               : 46
set_definition       : 98
set_operation        : 44 92
set_operation1       : 36
statement            : 18 104
statement1           : 39
statement2           : 40
statement_aux        : 103 104 106
term                 : 66 71
term2                : 73 74
term_not             : 73
varcte               : 80
vars                 : 3 10 16 107
vars1                : 7 8
vars2                : 7
vars_aux             : 106
while                : 50

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID ; program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . ; program1

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . program1
    (2) program1 -> . program2 program3 main
    (3) program2 -> . vars
    (4) program2 -> . empty
    (7) vars -> . datatype vars1 ; vars2
    (113) empty -> .
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    VOID            reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! STRING          [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! SET             [ reduce using rule 113 (empty -> .) ]
  ! MAP             [ reduce using rule 113 (empty -> .) ]

    program1                       shift and go to state 5
    program2                       shift and go to state 6
    vars                           shift and go to state 7
    empty                          shift and go to state 8
    datatype                       shift and go to state 9
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 5

    (1) program -> PROGRAM ID ; program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID ; program1 .)


state 6

    (2) program1 -> program2 . program3 main
    (5) program3 -> . proc program3
    (6) program3 -> . empty
    (12) proc -> . functype ID ( proc1 ) { proc3 proc4 }
    (113) empty -> .
    (101) functype -> . datatype
    (102) functype -> . VOID
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    MAIN            reduce using rule 113 (empty -> .)
    VOID            shift and go to state 24
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    program3                       shift and go to state 19
    proc                           shift and go to state 20
    empty                          shift and go to state 21
    functype                       shift and go to state 22
    datatype                       shift and go to state 23
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 7

    (3) program2 -> vars .

    VOID            reduce using rule 3 (program2 -> vars .)
    INT             reduce using rule 3 (program2 -> vars .)
    FLOAT           reduce using rule 3 (program2 -> vars .)
    BOOL            reduce using rule 3 (program2 -> vars .)
    STRING          reduce using rule 3 (program2 -> vars .)
    CHAR            reduce using rule 3 (program2 -> vars .)
    SET             reduce using rule 3 (program2 -> vars .)
    MAP             reduce using rule 3 (program2 -> vars .)
    MAIN            reduce using rule 3 (program2 -> vars .)


state 8

    (4) program2 -> empty .

    VOID            reduce using rule 4 (program2 -> empty .)
    INT             reduce using rule 4 (program2 -> empty .)
    FLOAT           reduce using rule 4 (program2 -> empty .)
    BOOL            reduce using rule 4 (program2 -> empty .)
    STRING          reduce using rule 4 (program2 -> empty .)
    CHAR            reduce using rule 4 (program2 -> empty .)
    SET             reduce using rule 4 (program2 -> empty .)
    MAP             reduce using rule 4 (program2 -> empty .)
    MAIN            reduce using rule 4 (program2 -> empty .)


state 9

    (7) vars -> datatype . vars1 ; vars2
    (8) vars1 -> . ID , vars1
    (9) vars1 -> . ID

    ID              shift and go to state 26

    vars1                          shift and go to state 25

state 10

    (93) datatype -> INT .

    ID              reduce using rule 93 (datatype -> INT .)
    >               reduce using rule 93 (datatype -> INT .)
    ,               reduce using rule 93 (datatype -> INT .)


state 11

    (94) datatype -> FLOAT .

    ID              reduce using rule 94 (datatype -> FLOAT .)
    >               reduce using rule 94 (datatype -> FLOAT .)
    ,               reduce using rule 94 (datatype -> FLOAT .)


state 12

    (95) datatype -> BOOL .

    ID              reduce using rule 95 (datatype -> BOOL .)
    >               reduce using rule 95 (datatype -> BOOL .)
    ,               reduce using rule 95 (datatype -> BOOL .)


state 13

    (96) datatype -> STRING .

    ID              reduce using rule 96 (datatype -> STRING .)
    >               reduce using rule 96 (datatype -> STRING .)
    ,               reduce using rule 96 (datatype -> STRING .)


state 14

    (97) datatype -> CHAR .

    ID              reduce using rule 97 (datatype -> CHAR .)
    >               reduce using rule 97 (datatype -> CHAR .)
    ,               reduce using rule 97 (datatype -> CHAR .)


state 15

    (98) datatype -> set_definition .

    ID              reduce using rule 98 (datatype -> set_definition .)
    >               reduce using rule 98 (datatype -> set_definition .)
    ,               reduce using rule 98 (datatype -> set_definition .)


state 16

    (99) datatype -> map_definition .

    ID              reduce using rule 99 (datatype -> map_definition .)
    >               reduce using rule 99 (datatype -> map_definition .)
    ,               reduce using rule 99 (datatype -> map_definition .)


state 17

    (100) set_definition -> SET . < datatype >

    <               shift and go to state 27


state 18

    (109) map_definition -> MAP . < datatype , datatype >

    <               shift and go to state 28


state 19

    (2) program1 -> program2 program3 . main
    (106) main -> . MAIN { vars_aux statement_aux }

    MAIN            shift and go to state 30

    main                           shift and go to state 29

state 20

    (5) program3 -> proc . program3
    (5) program3 -> . proc program3
    (6) program3 -> . empty
    (12) proc -> . functype ID ( proc1 ) { proc3 proc4 }
    (113) empty -> .
    (101) functype -> . datatype
    (102) functype -> . VOID
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    MAIN            reduce using rule 113 (empty -> .)
    VOID            shift and go to state 24
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    proc                           shift and go to state 20
    program3                       shift and go to state 31
    empty                          shift and go to state 21
    functype                       shift and go to state 22
    datatype                       shift and go to state 23
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 21

    (6) program3 -> empty .

    MAIN            reduce using rule 6 (program3 -> empty .)


state 22

    (12) proc -> functype . ID ( proc1 ) { proc3 proc4 }

    ID              shift and go to state 32


state 23

    (101) functype -> datatype .

    ID              reduce using rule 101 (functype -> datatype .)


state 24

    (102) functype -> VOID .

    ID              reduce using rule 102 (functype -> VOID .)


state 25

    (7) vars -> datatype vars1 . ; vars2

    ;               shift and go to state 33


state 26

    (8) vars1 -> ID . , vars1
    (9) vars1 -> ID .

    ,               shift and go to state 34
    ;               reduce using rule 9 (vars1 -> ID .)


state 27

    (100) set_definition -> SET < . datatype >
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    datatype                       shift and go to state 35
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 28

    (109) map_definition -> MAP < . datatype , datatype >
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    datatype                       shift and go to state 36
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 29

    (2) program1 -> program2 program3 main .

    $end            reduce using rule 2 (program1 -> program2 program3 main .)


state 30

    (106) main -> MAIN . { vars_aux statement_aux }

    {               shift and go to state 37


state 31

    (5) program3 -> proc program3 .

    MAIN            reduce using rule 5 (program3 -> proc program3 .)


state 32

    (12) proc -> functype ID . ( proc1 ) { proc3 proc4 }

    (               shift and go to state 38


state 33

    (7) vars -> datatype vars1 ; . vars2
    (10) vars2 -> . vars
    (11) vars2 -> . empty
    (7) vars -> . datatype vars1 ; vars2
    (113) empty -> .
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    VOID            reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    READ            reduce using rule 113 (empty -> .)
    PRINT           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    }               reduce using rule 113 (empty -> .)
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! BOOL            [ reduce using rule 113 (empty -> .) ]
  ! STRING          [ reduce using rule 113 (empty -> .) ]
  ! CHAR            [ reduce using rule 113 (empty -> .) ]
  ! SET             [ reduce using rule 113 (empty -> .) ]
  ! MAP             [ reduce using rule 113 (empty -> .) ]

    datatype                       shift and go to state 9
    vars2                          shift and go to state 39
    vars                           shift and go to state 40
    empty                          shift and go to state 41
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 34

    (8) vars1 -> ID , . vars1
    (8) vars1 -> . ID , vars1
    (9) vars1 -> . ID

    ID              shift and go to state 26

    vars1                          shift and go to state 42

state 35

    (100) set_definition -> SET < datatype . >

    >               shift and go to state 43


state 36

    (109) map_definition -> MAP < datatype . , datatype >

    ,               shift and go to state 44


state 37

    (106) main -> MAIN { . vars_aux statement_aux }
    (107) vars_aux -> . vars
    (108) vars_aux -> . empty
    (7) vars -> . datatype vars1 ; vars2
    (113) empty -> .
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    ID              reduce using rule 113 (empty -> .)
    READ            reduce using rule 113 (empty -> .)
    PRINT           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    }               reduce using rule 113 (empty -> .)
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

  ! MAP             [ reduce using rule 113 (empty -> .) ]

    vars_aux                       shift and go to state 45
    vars                           shift and go to state 46
    empty                          shift and go to state 47
    datatype                       shift and go to state 9
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 38

    (12) proc -> functype ID ( . proc1 ) { proc3 proc4 }
    (13) proc1 -> . datatype ID proc2
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    proc1                          shift and go to state 48
    datatype                       shift and go to state 49
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 39

    (7) vars -> datatype vars1 ; vars2 .

    VOID            reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    INT             reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    FLOAT           reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    BOOL            reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    STRING          reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    CHAR            reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    SET             reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    MAP             reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    MAIN            reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    ID              reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    READ            reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    PRINT           reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    RETURN          reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    IF              reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    WHILE           reduce using rule 7 (vars -> datatype vars1 ; vars2 .)
    }               reduce using rule 7 (vars -> datatype vars1 ; vars2 .)


state 40

    (10) vars2 -> vars .

    VOID            reduce using rule 10 (vars2 -> vars .)
    INT             reduce using rule 10 (vars2 -> vars .)
    FLOAT           reduce using rule 10 (vars2 -> vars .)
    BOOL            reduce using rule 10 (vars2 -> vars .)
    STRING          reduce using rule 10 (vars2 -> vars .)
    CHAR            reduce using rule 10 (vars2 -> vars .)
    SET             reduce using rule 10 (vars2 -> vars .)
    MAP             reduce using rule 10 (vars2 -> vars .)
    MAIN            reduce using rule 10 (vars2 -> vars .)
    ID              reduce using rule 10 (vars2 -> vars .)
    READ            reduce using rule 10 (vars2 -> vars .)
    PRINT           reduce using rule 10 (vars2 -> vars .)
    RETURN          reduce using rule 10 (vars2 -> vars .)
    IF              reduce using rule 10 (vars2 -> vars .)
    WHILE           reduce using rule 10 (vars2 -> vars .)
    }               reduce using rule 10 (vars2 -> vars .)


state 41

    (11) vars2 -> empty .

    VOID            reduce using rule 11 (vars2 -> empty .)
    INT             reduce using rule 11 (vars2 -> empty .)
    FLOAT           reduce using rule 11 (vars2 -> empty .)
    BOOL            reduce using rule 11 (vars2 -> empty .)
    STRING          reduce using rule 11 (vars2 -> empty .)
    CHAR            reduce using rule 11 (vars2 -> empty .)
    SET             reduce using rule 11 (vars2 -> empty .)
    MAP             reduce using rule 11 (vars2 -> empty .)
    MAIN            reduce using rule 11 (vars2 -> empty .)
    ID              reduce using rule 11 (vars2 -> empty .)
    READ            reduce using rule 11 (vars2 -> empty .)
    PRINT           reduce using rule 11 (vars2 -> empty .)
    RETURN          reduce using rule 11 (vars2 -> empty .)
    IF              reduce using rule 11 (vars2 -> empty .)
    WHILE           reduce using rule 11 (vars2 -> empty .)
    }               reduce using rule 11 (vars2 -> empty .)


state 42

    (8) vars1 -> ID , vars1 .

    ;               reduce using rule 8 (vars1 -> ID , vars1 .)


state 43

    (100) set_definition -> SET < datatype > .

    ID              reduce using rule 100 (set_definition -> SET < datatype > .)
    >               reduce using rule 100 (set_definition -> SET < datatype > .)
    ,               reduce using rule 100 (set_definition -> SET < datatype > .)


state 44

    (109) map_definition -> MAP < datatype , . datatype >
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    datatype                       shift and go to state 50
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 45

    (106) main -> MAIN { vars_aux . statement_aux }
    (104) statement_aux -> . statement statement_aux
    (105) statement_aux -> . empty
    (39) statement -> . statement1 ;
    (40) statement -> . statement2
    (113) empty -> .
    (41) statement1 -> . assignment
    (42) statement1 -> . input
    (43) statement1 -> . output
    (44) statement1 -> . set_operation
    (45) statement1 -> . map_definition
    (46) statement1 -> . return
    (47) statement1 -> . map_assignment
    (48) statement1 -> . map_operation
    (49) statement2 -> . condition
    (50) statement2 -> . while
    (20) assignment -> . ID ASSIGNATOR expression
    (24) input -> . READ ( ID input1 )
    (27) output -> . PRINT ( expression output1 )
    (36) set_operation -> . ID . OPERATION ( set_operation1 )
    (109) map_definition -> . MAP < datatype , datatype >
    (35) return -> . RETURN expression
    (111) map_assignment -> . map_access ASSIGNATOR exp
    (112) map_operation -> . ID . OPERATION ( )
    (21) condition -> . IF ( expression ) block condition1
    (51) while -> . WHILE ( expression ) block
    (110) map_access -> . ID ( exp )

    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 66
    READ            shift and go to state 67
    PRINT           shift and go to state 68
    MAP             shift and go to state 18
    RETURN          shift and go to state 69
    IF              shift and go to state 71
    WHILE           shift and go to state 72

    statement_aux                  shift and go to state 51
    statement                      shift and go to state 52
    empty                          shift and go to state 53
    statement1                     shift and go to state 54
    statement2                     shift and go to state 55
    assignment                     shift and go to state 56
    input                          shift and go to state 57
    output                         shift and go to state 58
    set_operation                  shift and go to state 59
    map_definition                 shift and go to state 60
    return                         shift and go to state 61
    map_assignment                 shift and go to state 62
    map_operation                  shift and go to state 63
    condition                      shift and go to state 64
    while                          shift and go to state 65
    map_access                     shift and go to state 70

state 46

    (107) vars_aux -> vars .

    ID              reduce using rule 107 (vars_aux -> vars .)
    READ            reduce using rule 107 (vars_aux -> vars .)
    PRINT           reduce using rule 107 (vars_aux -> vars .)
    MAP             reduce using rule 107 (vars_aux -> vars .)
    RETURN          reduce using rule 107 (vars_aux -> vars .)
    IF              reduce using rule 107 (vars_aux -> vars .)
    WHILE           reduce using rule 107 (vars_aux -> vars .)
    }               reduce using rule 107 (vars_aux -> vars .)


state 47

    (108) vars_aux -> empty .

    ID              reduce using rule 108 (vars_aux -> empty .)
    READ            reduce using rule 108 (vars_aux -> empty .)
    PRINT           reduce using rule 108 (vars_aux -> empty .)
    MAP             reduce using rule 108 (vars_aux -> empty .)
    RETURN          reduce using rule 108 (vars_aux -> empty .)
    IF              reduce using rule 108 (vars_aux -> empty .)
    WHILE           reduce using rule 108 (vars_aux -> empty .)
    }               reduce using rule 108 (vars_aux -> empty .)


state 48

    (12) proc -> functype ID ( proc1 . ) { proc3 proc4 }

    )               shift and go to state 73


state 49

    (13) proc1 -> datatype . ID proc2

    ID              shift and go to state 74


state 50

    (109) map_definition -> MAP < datatype , datatype . >

    >               shift and go to state 75


state 51

    (106) main -> MAIN { vars_aux statement_aux . }

    }               shift and go to state 76


state 52

    (104) statement_aux -> statement . statement_aux
    (104) statement_aux -> . statement statement_aux
    (105) statement_aux -> . empty
    (39) statement -> . statement1 ;
    (40) statement -> . statement2
    (113) empty -> .
    (41) statement1 -> . assignment
    (42) statement1 -> . input
    (43) statement1 -> . output
    (44) statement1 -> . set_operation
    (45) statement1 -> . map_definition
    (46) statement1 -> . return
    (47) statement1 -> . map_assignment
    (48) statement1 -> . map_operation
    (49) statement2 -> . condition
    (50) statement2 -> . while
    (20) assignment -> . ID ASSIGNATOR expression
    (24) input -> . READ ( ID input1 )
    (27) output -> . PRINT ( expression output1 )
    (36) set_operation -> . ID . OPERATION ( set_operation1 )
    (109) map_definition -> . MAP < datatype , datatype >
    (35) return -> . RETURN expression
    (111) map_assignment -> . map_access ASSIGNATOR exp
    (112) map_operation -> . ID . OPERATION ( )
    (21) condition -> . IF ( expression ) block condition1
    (51) while -> . WHILE ( expression ) block
    (110) map_access -> . ID ( exp )

    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 66
    READ            shift and go to state 67
    PRINT           shift and go to state 68
    MAP             shift and go to state 18
    RETURN          shift and go to state 69
    IF              shift and go to state 71
    WHILE           shift and go to state 72

    statement                      shift and go to state 52
    statement_aux                  shift and go to state 77
    empty                          shift and go to state 53
    statement1                     shift and go to state 54
    statement2                     shift and go to state 55
    assignment                     shift and go to state 56
    input                          shift and go to state 57
    output                         shift and go to state 58
    set_operation                  shift and go to state 59
    map_definition                 shift and go to state 60
    return                         shift and go to state 61
    map_assignment                 shift and go to state 62
    map_operation                  shift and go to state 63
    condition                      shift and go to state 64
    while                          shift and go to state 65
    map_access                     shift and go to state 70

state 53

    (105) statement_aux -> empty .

    }               reduce using rule 105 (statement_aux -> empty .)


state 54

    (39) statement -> statement1 . ;

    ;               shift and go to state 78


state 55

    (40) statement -> statement2 .

    ID              reduce using rule 40 (statement -> statement2 .)
    READ            reduce using rule 40 (statement -> statement2 .)
    PRINT           reduce using rule 40 (statement -> statement2 .)
    MAP             reduce using rule 40 (statement -> statement2 .)
    RETURN          reduce using rule 40 (statement -> statement2 .)
    IF              reduce using rule 40 (statement -> statement2 .)
    WHILE           reduce using rule 40 (statement -> statement2 .)
    }               reduce using rule 40 (statement -> statement2 .)


state 56

    (41) statement1 -> assignment .

    ;               reduce using rule 41 (statement1 -> assignment .)


state 57

    (42) statement1 -> input .

    ;               reduce using rule 42 (statement1 -> input .)


state 58

    (43) statement1 -> output .

    ;               reduce using rule 43 (statement1 -> output .)


state 59

    (44) statement1 -> set_operation .

    ;               reduce using rule 44 (statement1 -> set_operation .)


state 60

    (45) statement1 -> map_definition .

    ;               reduce using rule 45 (statement1 -> map_definition .)


state 61

    (46) statement1 -> return .

    ;               reduce using rule 46 (statement1 -> return .)


state 62

    (47) statement1 -> map_assignment .

    ;               reduce using rule 47 (statement1 -> map_assignment .)


state 63

    (48) statement1 -> map_operation .

    ;               reduce using rule 48 (statement1 -> map_operation .)


state 64

    (49) statement2 -> condition .

    ID              reduce using rule 49 (statement2 -> condition .)
    READ            reduce using rule 49 (statement2 -> condition .)
    PRINT           reduce using rule 49 (statement2 -> condition .)
    MAP             reduce using rule 49 (statement2 -> condition .)
    RETURN          reduce using rule 49 (statement2 -> condition .)
    IF              reduce using rule 49 (statement2 -> condition .)
    WHILE           reduce using rule 49 (statement2 -> condition .)
    }               reduce using rule 49 (statement2 -> condition .)


state 65

    (50) statement2 -> while .

    ID              reduce using rule 50 (statement2 -> while .)
    READ            reduce using rule 50 (statement2 -> while .)
    PRINT           reduce using rule 50 (statement2 -> while .)
    MAP             reduce using rule 50 (statement2 -> while .)
    RETURN          reduce using rule 50 (statement2 -> while .)
    IF              reduce using rule 50 (statement2 -> while .)
    WHILE           reduce using rule 50 (statement2 -> while .)
    }               reduce using rule 50 (statement2 -> while .)


state 66

    (20) assignment -> ID . ASSIGNATOR expression
    (36) set_operation -> ID . . OPERATION ( set_operation1 )
    (112) map_operation -> ID . . OPERATION ( )
    (110) map_access -> ID . ( exp )

    ASSIGNATOR      shift and go to state 79
    .               shift and go to state 80
    (               shift and go to state 81


state 67

    (24) input -> READ . ( ID input1 )

    (               shift and go to state 82


state 68

    (27) output -> PRINT . ( expression output1 )

    (               shift and go to state 83


state 69

    (35) return -> RETURN . expression
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 84
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 70

    (111) map_assignment -> map_access . ASSIGNATOR exp

    ASSIGNATOR      shift and go to state 91


state 71

    (21) condition -> IF . ( expression ) block condition1

    (               shift and go to state 92


state 72

    (51) while -> WHILE . ( expression ) block

    (               shift and go to state 93


state 73

    (12) proc -> functype ID ( proc1 ) . { proc3 proc4 }

    {               shift and go to state 94


state 74

    (13) proc1 -> datatype ID . proc2
    (14) proc2 -> . , proc1
    (15) proc2 -> . empty
    (113) empty -> .

    ,               shift and go to state 96
    )               reduce using rule 113 (empty -> .)

    proc2                          shift and go to state 95
    empty                          shift and go to state 97

state 75

    (109) map_definition -> MAP < datatype , datatype > .

    ID              reduce using rule 109 (map_definition -> MAP < datatype , datatype > .)
    >               reduce using rule 109 (map_definition -> MAP < datatype , datatype > .)
    ,               reduce using rule 109 (map_definition -> MAP < datatype , datatype > .)
    ;               reduce using rule 109 (map_definition -> MAP < datatype , datatype > .)


state 76

    (106) main -> MAIN { vars_aux statement_aux } .

    $end            reduce using rule 106 (main -> MAIN { vars_aux statement_aux } .)


state 77

    (104) statement_aux -> statement statement_aux .

    }               reduce using rule 104 (statement_aux -> statement statement_aux .)


state 78

    (39) statement -> statement1 ; .

    ID              reduce using rule 39 (statement -> statement1 ; .)
    READ            reduce using rule 39 (statement -> statement1 ; .)
    PRINT           reduce using rule 39 (statement -> statement1 ; .)
    MAP             reduce using rule 39 (statement -> statement1 ; .)
    RETURN          reduce using rule 39 (statement -> statement1 ; .)
    IF              reduce using rule 39 (statement -> statement1 ; .)
    WHILE           reduce using rule 39 (statement -> statement1 ; .)
    }               reduce using rule 39 (statement -> statement1 ; .)


state 79

    (20) assignment -> ID ASSIGNATOR . expression
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 98
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 80

    (36) set_operation -> ID . . OPERATION ( set_operation1 )
    (112) map_operation -> ID . . OPERATION ( )

    OPERATION       shift and go to state 99


state 81

    (110) map_access -> ID ( . exp )
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    exp                            shift and go to state 100
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 82

    (24) input -> READ ( . ID input1 )

    ID              shift and go to state 101


state 83

    (27) output -> PRINT ( . expression output1 )
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 102
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 84

    (35) return -> RETURN expression .

    ;               reduce using rule 35 (return -> RETURN expression .)


state 85

    (60) expression -> exp0 . expression2
    (61) expression2 -> . logop exp0 expression2
    (62) expression2 -> . empty
    (58) logop -> . OR
    (59) logop -> . AND
    (113) empty -> .

    OR              shift and go to state 106
    AND             shift and go to state 107
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)

    expression2                    shift and go to state 103
    logop                          shift and go to state 104
    empty                          shift and go to state 105

state 86

    (63) exp0 -> exp . exp02
    (64) exp02 -> . relop exp02
    (65) exp02 -> . empty
    (52) relop -> . <
    (53) relop -> . >
    (54) relop -> . NOT_EQ
    (55) relop -> . EQ
    (56) relop -> . LEQ
    (57) relop -> . GEQ
    (113) empty -> .

    <               shift and go to state 111
    >               shift and go to state 112
    NOT_EQ          shift and go to state 113
    EQ              shift and go to state 114
    LEQ             shift and go to state 115
    GEQ             shift and go to state 116
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)

    exp02                          shift and go to state 108
    relop                          shift and go to state 109
    empty                          shift and go to state 110

state 87

    (66) exp -> term . exp2
    (71) exp2 -> . addsub term exp2
    (72) exp2 -> . empty
    (67) addsub -> . +
    (68) addsub -> . -
    (113) empty -> .

    +               shift and go to state 120
    -               shift and go to state 121
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    NOT_EQ          reduce using rule 113 (empty -> .)
    EQ              reduce using rule 113 (empty -> .)
    LEQ             reduce using rule 113 (empty -> .)
    GEQ             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    exp2                           shift and go to state 117
    addsub                         shift and go to state 118
    empty                          shift and go to state 119

state 88

    (73) term -> term_not . factor term2
    (78) factor -> . ( expression )
    (79) factor -> . factor2
    (80) factor2 -> . factor3 varcte
    (81) factor3 -> . addsub
    (82) factor3 -> . empty
    (67) addsub -> . +
    (68) addsub -> . -
    (113) empty -> .

    (               shift and go to state 123
    +               shift and go to state 120
    -               shift and go to state 121
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    factor                         shift and go to state 122
    factor2                        shift and go to state 124
    factor3                        shift and go to state 125
    addsub                         shift and go to state 126
    empty                          shift and go to state 127

state 89

    (76) term_not -> ! .

    (               reduce using rule 76 (term_not -> ! .)
    +               reduce using rule 76 (term_not -> ! .)
    -               reduce using rule 76 (term_not -> ! .)
    ID              reduce using rule 76 (term_not -> ! .)
    CTE_INT         reduce using rule 76 (term_not -> ! .)
    CTE_FLOAT       reduce using rule 76 (term_not -> ! .)
    CTE_BOOL        reduce using rule 76 (term_not -> ! .)
    CTE_STRING      reduce using rule 76 (term_not -> ! .)
    CTE_CHAR        reduce using rule 76 (term_not -> ! .)


state 90

    (77) term_not -> empty .

    (               reduce using rule 77 (term_not -> empty .)
    +               reduce using rule 77 (term_not -> empty .)
    -               reduce using rule 77 (term_not -> empty .)
    ID              reduce using rule 77 (term_not -> empty .)
    CTE_INT         reduce using rule 77 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 77 (term_not -> empty .)
    CTE_BOOL        reduce using rule 77 (term_not -> empty .)
    CTE_STRING      reduce using rule 77 (term_not -> empty .)
    CTE_CHAR        reduce using rule 77 (term_not -> empty .)


state 91

    (111) map_assignment -> map_access ASSIGNATOR . exp
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    exp                            shift and go to state 128
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 92

    (21) condition -> IF ( . expression ) block condition1
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 129
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 93

    (51) while -> WHILE ( . expression ) block
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 130
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 94

    (12) proc -> functype ID ( proc1 ) { . proc3 proc4 }
    (16) proc3 -> . vars
    (17) proc3 -> . empty
    (7) vars -> . datatype vars1 ; vars2
    (113) empty -> .
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    ID              reduce using rule 113 (empty -> .)
    READ            reduce using rule 113 (empty -> .)
    PRINT           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    }               reduce using rule 113 (empty -> .)
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

  ! MAP             [ reduce using rule 113 (empty -> .) ]

    proc3                          shift and go to state 131
    vars                           shift and go to state 132
    empty                          shift and go to state 133
    datatype                       shift and go to state 9
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 95

    (13) proc1 -> datatype ID proc2 .

    )               reduce using rule 13 (proc1 -> datatype ID proc2 .)


state 96

    (14) proc2 -> , . proc1
    (13) proc1 -> . datatype ID proc2
    (93) datatype -> . INT
    (94) datatype -> . FLOAT
    (95) datatype -> . BOOL
    (96) datatype -> . STRING
    (97) datatype -> . CHAR
    (98) datatype -> . set_definition
    (99) datatype -> . map_definition
    (100) set_definition -> . SET < datatype >
    (109) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    STRING          shift and go to state 13
    CHAR            shift and go to state 14
    SET             shift and go to state 17
    MAP             shift and go to state 18

    proc1                          shift and go to state 134
    datatype                       shift and go to state 49
    set_definition                 shift and go to state 15
    map_definition                 shift and go to state 16

state 97

    (15) proc2 -> empty .

    )               reduce using rule 15 (proc2 -> empty .)


state 98

    (20) assignment -> ID ASSIGNATOR expression .

    ;               reduce using rule 20 (assignment -> ID ASSIGNATOR expression .)


state 99

    (36) set_operation -> ID . OPERATION . ( set_operation1 )
    (112) map_operation -> ID . OPERATION . ( )

    (               shift and go to state 135


state 100

    (110) map_access -> ID ( exp . )

    )               shift and go to state 136


state 101

    (24) input -> READ ( ID . input1 )
    (25) input1 -> . , ID input1
    (26) input1 -> . empty
    (113) empty -> .

    ,               shift and go to state 138
    )               reduce using rule 113 (empty -> .)

    input1                         shift and go to state 137
    empty                          shift and go to state 139

state 102

    (27) output -> PRINT ( expression . output1 )
    (28) output1 -> . , expression output1
    (29) output1 -> . empty
    (113) empty -> .

    ,               shift and go to state 141
    )               reduce using rule 113 (empty -> .)

    output1                        shift and go to state 140
    empty                          shift and go to state 142

state 103

    (60) expression -> exp0 expression2 .

    ;               reduce using rule 60 (expression -> exp0 expression2 .)
    ,               reduce using rule 60 (expression -> exp0 expression2 .)
    )               reduce using rule 60 (expression -> exp0 expression2 .)


state 104

    (61) expression2 -> logop . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    exp0                           shift and go to state 143
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 105

    (62) expression2 -> empty .

    ;               reduce using rule 62 (expression2 -> empty .)
    ,               reduce using rule 62 (expression2 -> empty .)
    )               reduce using rule 62 (expression2 -> empty .)


state 106

    (58) logop -> OR .

    !               reduce using rule 58 (logop -> OR .)
    (               reduce using rule 58 (logop -> OR .)
    +               reduce using rule 58 (logop -> OR .)
    -               reduce using rule 58 (logop -> OR .)
    ID              reduce using rule 58 (logop -> OR .)
    CTE_INT         reduce using rule 58 (logop -> OR .)
    CTE_FLOAT       reduce using rule 58 (logop -> OR .)
    CTE_BOOL        reduce using rule 58 (logop -> OR .)
    CTE_STRING      reduce using rule 58 (logop -> OR .)
    CTE_CHAR        reduce using rule 58 (logop -> OR .)


state 107

    (59) logop -> AND .

    !               reduce using rule 59 (logop -> AND .)
    (               reduce using rule 59 (logop -> AND .)
    +               reduce using rule 59 (logop -> AND .)
    -               reduce using rule 59 (logop -> AND .)
    ID              reduce using rule 59 (logop -> AND .)
    CTE_INT         reduce using rule 59 (logop -> AND .)
    CTE_FLOAT       reduce using rule 59 (logop -> AND .)
    CTE_BOOL        reduce using rule 59 (logop -> AND .)
    CTE_STRING      reduce using rule 59 (logop -> AND .)
    CTE_CHAR        reduce using rule 59 (logop -> AND .)


state 108

    (63) exp0 -> exp exp02 .

    OR              reduce using rule 63 (exp0 -> exp exp02 .)
    AND             reduce using rule 63 (exp0 -> exp exp02 .)
    ;               reduce using rule 63 (exp0 -> exp exp02 .)
    ,               reduce using rule 63 (exp0 -> exp exp02 .)
    )               reduce using rule 63 (exp0 -> exp exp02 .)


state 109

    (64) exp02 -> relop . exp02
    (64) exp02 -> . relop exp02
    (65) exp02 -> . empty
    (52) relop -> . <
    (53) relop -> . >
    (54) relop -> . NOT_EQ
    (55) relop -> . EQ
    (56) relop -> . LEQ
    (57) relop -> . GEQ
    (113) empty -> .

    <               shift and go to state 111
    >               shift and go to state 112
    NOT_EQ          shift and go to state 113
    EQ              shift and go to state 114
    LEQ             shift and go to state 115
    GEQ             shift and go to state 116
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)

    relop                          shift and go to state 109
    exp02                          shift and go to state 144
    empty                          shift and go to state 110

state 110

    (65) exp02 -> empty .

    OR              reduce using rule 65 (exp02 -> empty .)
    AND             reduce using rule 65 (exp02 -> empty .)
    ;               reduce using rule 65 (exp02 -> empty .)
    ,               reduce using rule 65 (exp02 -> empty .)
    )               reduce using rule 65 (exp02 -> empty .)


state 111

    (52) relop -> < .

    <               reduce using rule 52 (relop -> < .)
    >               reduce using rule 52 (relop -> < .)
    NOT_EQ          reduce using rule 52 (relop -> < .)
    EQ              reduce using rule 52 (relop -> < .)
    LEQ             reduce using rule 52 (relop -> < .)
    GEQ             reduce using rule 52 (relop -> < .)
    OR              reduce using rule 52 (relop -> < .)
    AND             reduce using rule 52 (relop -> < .)
    ;               reduce using rule 52 (relop -> < .)
    ,               reduce using rule 52 (relop -> < .)
    )               reduce using rule 52 (relop -> < .)


state 112

    (53) relop -> > .

    <               reduce using rule 53 (relop -> > .)
    >               reduce using rule 53 (relop -> > .)
    NOT_EQ          reduce using rule 53 (relop -> > .)
    EQ              reduce using rule 53 (relop -> > .)
    LEQ             reduce using rule 53 (relop -> > .)
    GEQ             reduce using rule 53 (relop -> > .)
    OR              reduce using rule 53 (relop -> > .)
    AND             reduce using rule 53 (relop -> > .)
    ;               reduce using rule 53 (relop -> > .)
    ,               reduce using rule 53 (relop -> > .)
    )               reduce using rule 53 (relop -> > .)


state 113

    (54) relop -> NOT_EQ .

    <               reduce using rule 54 (relop -> NOT_EQ .)
    >               reduce using rule 54 (relop -> NOT_EQ .)
    NOT_EQ          reduce using rule 54 (relop -> NOT_EQ .)
    EQ              reduce using rule 54 (relop -> NOT_EQ .)
    LEQ             reduce using rule 54 (relop -> NOT_EQ .)
    GEQ             reduce using rule 54 (relop -> NOT_EQ .)
    OR              reduce using rule 54 (relop -> NOT_EQ .)
    AND             reduce using rule 54 (relop -> NOT_EQ .)
    ;               reduce using rule 54 (relop -> NOT_EQ .)
    ,               reduce using rule 54 (relop -> NOT_EQ .)
    )               reduce using rule 54 (relop -> NOT_EQ .)


state 114

    (55) relop -> EQ .

    <               reduce using rule 55 (relop -> EQ .)
    >               reduce using rule 55 (relop -> EQ .)
    NOT_EQ          reduce using rule 55 (relop -> EQ .)
    EQ              reduce using rule 55 (relop -> EQ .)
    LEQ             reduce using rule 55 (relop -> EQ .)
    GEQ             reduce using rule 55 (relop -> EQ .)
    OR              reduce using rule 55 (relop -> EQ .)
    AND             reduce using rule 55 (relop -> EQ .)
    ;               reduce using rule 55 (relop -> EQ .)
    ,               reduce using rule 55 (relop -> EQ .)
    )               reduce using rule 55 (relop -> EQ .)


state 115

    (56) relop -> LEQ .

    <               reduce using rule 56 (relop -> LEQ .)
    >               reduce using rule 56 (relop -> LEQ .)
    NOT_EQ          reduce using rule 56 (relop -> LEQ .)
    EQ              reduce using rule 56 (relop -> LEQ .)
    LEQ             reduce using rule 56 (relop -> LEQ .)
    GEQ             reduce using rule 56 (relop -> LEQ .)
    OR              reduce using rule 56 (relop -> LEQ .)
    AND             reduce using rule 56 (relop -> LEQ .)
    ;               reduce using rule 56 (relop -> LEQ .)
    ,               reduce using rule 56 (relop -> LEQ .)
    )               reduce using rule 56 (relop -> LEQ .)


state 116

    (57) relop -> GEQ .

    <               reduce using rule 57 (relop -> GEQ .)
    >               reduce using rule 57 (relop -> GEQ .)
    NOT_EQ          reduce using rule 57 (relop -> GEQ .)
    EQ              reduce using rule 57 (relop -> GEQ .)
    LEQ             reduce using rule 57 (relop -> GEQ .)
    GEQ             reduce using rule 57 (relop -> GEQ .)
    OR              reduce using rule 57 (relop -> GEQ .)
    AND             reduce using rule 57 (relop -> GEQ .)
    ;               reduce using rule 57 (relop -> GEQ .)
    ,               reduce using rule 57 (relop -> GEQ .)
    )               reduce using rule 57 (relop -> GEQ .)


state 117

    (66) exp -> term exp2 .

    <               reduce using rule 66 (exp -> term exp2 .)
    >               reduce using rule 66 (exp -> term exp2 .)
    NOT_EQ          reduce using rule 66 (exp -> term exp2 .)
    EQ              reduce using rule 66 (exp -> term exp2 .)
    LEQ             reduce using rule 66 (exp -> term exp2 .)
    GEQ             reduce using rule 66 (exp -> term exp2 .)
    OR              reduce using rule 66 (exp -> term exp2 .)
    AND             reduce using rule 66 (exp -> term exp2 .)
    ;               reduce using rule 66 (exp -> term exp2 .)
    )               reduce using rule 66 (exp -> term exp2 .)
    ,               reduce using rule 66 (exp -> term exp2 .)


state 118

    (71) exp2 -> addsub . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    term                           shift and go to state 145
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 119

    (72) exp2 -> empty .

    <               reduce using rule 72 (exp2 -> empty .)
    >               reduce using rule 72 (exp2 -> empty .)
    NOT_EQ          reduce using rule 72 (exp2 -> empty .)
    EQ              reduce using rule 72 (exp2 -> empty .)
    LEQ             reduce using rule 72 (exp2 -> empty .)
    GEQ             reduce using rule 72 (exp2 -> empty .)
    OR              reduce using rule 72 (exp2 -> empty .)
    AND             reduce using rule 72 (exp2 -> empty .)
    ;               reduce using rule 72 (exp2 -> empty .)
    )               reduce using rule 72 (exp2 -> empty .)
    ,               reduce using rule 72 (exp2 -> empty .)


state 120

    (67) addsub -> + .

    !               reduce using rule 67 (addsub -> + .)
    (               reduce using rule 67 (addsub -> + .)
    +               reduce using rule 67 (addsub -> + .)
    -               reduce using rule 67 (addsub -> + .)
    ID              reduce using rule 67 (addsub -> + .)
    CTE_INT         reduce using rule 67 (addsub -> + .)
    CTE_FLOAT       reduce using rule 67 (addsub -> + .)
    CTE_BOOL        reduce using rule 67 (addsub -> + .)
    CTE_STRING      reduce using rule 67 (addsub -> + .)
    CTE_CHAR        reduce using rule 67 (addsub -> + .)


state 121

    (68) addsub -> - .

    !               reduce using rule 68 (addsub -> - .)
    (               reduce using rule 68 (addsub -> - .)
    +               reduce using rule 68 (addsub -> - .)
    -               reduce using rule 68 (addsub -> - .)
    ID              reduce using rule 68 (addsub -> - .)
    CTE_INT         reduce using rule 68 (addsub -> - .)
    CTE_FLOAT       reduce using rule 68 (addsub -> - .)
    CTE_BOOL        reduce using rule 68 (addsub -> - .)
    CTE_STRING      reduce using rule 68 (addsub -> - .)
    CTE_CHAR        reduce using rule 68 (addsub -> - .)


state 122

    (73) term -> term_not factor . term2
    (74) term2 -> . muldiv factor term2
    (75) term2 -> . empty
    (69) muldiv -> . *
    (70) muldiv -> . /
    (113) empty -> .

    *               shift and go to state 149
    /               shift and go to state 150
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    NOT_EQ          reduce using rule 113 (empty -> .)
    EQ              reduce using rule 113 (empty -> .)
    LEQ             reduce using rule 113 (empty -> .)
    GEQ             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    term2                          shift and go to state 146
    muldiv                         shift and go to state 147
    empty                          shift and go to state 148

state 123

    (78) factor -> ( . expression )
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 151
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 124

    (79) factor -> factor2 .

    *               reduce using rule 79 (factor -> factor2 .)
    /               reduce using rule 79 (factor -> factor2 .)
    +               reduce using rule 79 (factor -> factor2 .)
    -               reduce using rule 79 (factor -> factor2 .)
    <               reduce using rule 79 (factor -> factor2 .)
    >               reduce using rule 79 (factor -> factor2 .)
    NOT_EQ          reduce using rule 79 (factor -> factor2 .)
    EQ              reduce using rule 79 (factor -> factor2 .)
    LEQ             reduce using rule 79 (factor -> factor2 .)
    GEQ             reduce using rule 79 (factor -> factor2 .)
    OR              reduce using rule 79 (factor -> factor2 .)
    AND             reduce using rule 79 (factor -> factor2 .)
    ;               reduce using rule 79 (factor -> factor2 .)
    )               reduce using rule 79 (factor -> factor2 .)
    ,               reduce using rule 79 (factor -> factor2 .)


state 125

    (80) factor2 -> factor3 . varcte
    (83) varcte -> . ID
    (84) varcte -> . CTE_INT
    (85) varcte -> . CTE_FLOAT
    (86) varcte -> . CTE_BOOL
    (87) varcte -> . CTE_STRING
    (88) varcte -> . CTE_CHAR
    (89) varcte -> . function_call
    (90) varcte -> . map_access
    (91) varcte -> . map_operation
    (92) varcte -> . set_operation
    (30) function_call -> . ID ( function_call1 )
    (110) map_access -> . ID ( exp )
    (112) map_operation -> . ID . OPERATION ( )
    (36) set_operation -> . ID . OPERATION ( set_operation1 )

    ID              shift and go to state 153
    CTE_INT         shift and go to state 154
    CTE_FLOAT       shift and go to state 155
    CTE_BOOL        shift and go to state 156
    CTE_STRING      shift and go to state 157
    CTE_CHAR        shift and go to state 158

    varcte                         shift and go to state 152
    function_call                  shift and go to state 159
    map_access                     shift and go to state 160
    map_operation                  shift and go to state 161
    set_operation                  shift and go to state 162

state 126

    (81) factor3 -> addsub .

    ID              reduce using rule 81 (factor3 -> addsub .)
    CTE_INT         reduce using rule 81 (factor3 -> addsub .)
    CTE_FLOAT       reduce using rule 81 (factor3 -> addsub .)
    CTE_BOOL        reduce using rule 81 (factor3 -> addsub .)
    CTE_STRING      reduce using rule 81 (factor3 -> addsub .)
    CTE_CHAR        reduce using rule 81 (factor3 -> addsub .)


state 127

    (82) factor3 -> empty .

    ID              reduce using rule 82 (factor3 -> empty .)
    CTE_INT         reduce using rule 82 (factor3 -> empty .)
    CTE_FLOAT       reduce using rule 82 (factor3 -> empty .)
    CTE_BOOL        reduce using rule 82 (factor3 -> empty .)
    CTE_STRING      reduce using rule 82 (factor3 -> empty .)
    CTE_CHAR        reduce using rule 82 (factor3 -> empty .)


state 128

    (111) map_assignment -> map_access ASSIGNATOR exp .

    ;               reduce using rule 111 (map_assignment -> map_access ASSIGNATOR exp .)


state 129

    (21) condition -> IF ( expression . ) block condition1

    )               shift and go to state 163


state 130

    (51) while -> WHILE ( expression . ) block

    )               shift and go to state 164


state 131

    (12) proc -> functype ID ( proc1 ) { proc3 . proc4 }
    (18) proc4 -> . statement proc4
    (19) proc4 -> . empty
    (39) statement -> . statement1 ;
    (40) statement -> . statement2
    (113) empty -> .
    (41) statement1 -> . assignment
    (42) statement1 -> . input
    (43) statement1 -> . output
    (44) statement1 -> . set_operation
    (45) statement1 -> . map_definition
    (46) statement1 -> . return
    (47) statement1 -> . map_assignment
    (48) statement1 -> . map_operation
    (49) statement2 -> . condition
    (50) statement2 -> . while
    (20) assignment -> . ID ASSIGNATOR expression
    (24) input -> . READ ( ID input1 )
    (27) output -> . PRINT ( expression output1 )
    (36) set_operation -> . ID . OPERATION ( set_operation1 )
    (109) map_definition -> . MAP < datatype , datatype >
    (35) return -> . RETURN expression
    (111) map_assignment -> . map_access ASSIGNATOR exp
    (112) map_operation -> . ID . OPERATION ( )
    (21) condition -> . IF ( expression ) block condition1
    (51) while -> . WHILE ( expression ) block
    (110) map_access -> . ID ( exp )

    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 66
    READ            shift and go to state 67
    PRINT           shift and go to state 68
    MAP             shift and go to state 18
    RETURN          shift and go to state 69
    IF              shift and go to state 71
    WHILE           shift and go to state 72

    proc4                          shift and go to state 165
    statement                      shift and go to state 166
    empty                          shift and go to state 167
    statement1                     shift and go to state 54
    statement2                     shift and go to state 55
    assignment                     shift and go to state 56
    input                          shift and go to state 57
    output                         shift and go to state 58
    set_operation                  shift and go to state 59
    map_definition                 shift and go to state 60
    return                         shift and go to state 61
    map_assignment                 shift and go to state 62
    map_operation                  shift and go to state 63
    condition                      shift and go to state 64
    while                          shift and go to state 65
    map_access                     shift and go to state 70

state 132

    (16) proc3 -> vars .

    ID              reduce using rule 16 (proc3 -> vars .)
    READ            reduce using rule 16 (proc3 -> vars .)
    PRINT           reduce using rule 16 (proc3 -> vars .)
    MAP             reduce using rule 16 (proc3 -> vars .)
    RETURN          reduce using rule 16 (proc3 -> vars .)
    IF              reduce using rule 16 (proc3 -> vars .)
    WHILE           reduce using rule 16 (proc3 -> vars .)
    }               reduce using rule 16 (proc3 -> vars .)


state 133

    (17) proc3 -> empty .

    ID              reduce using rule 17 (proc3 -> empty .)
    READ            reduce using rule 17 (proc3 -> empty .)
    PRINT           reduce using rule 17 (proc3 -> empty .)
    MAP             reduce using rule 17 (proc3 -> empty .)
    RETURN          reduce using rule 17 (proc3 -> empty .)
    IF              reduce using rule 17 (proc3 -> empty .)
    WHILE           reduce using rule 17 (proc3 -> empty .)
    }               reduce using rule 17 (proc3 -> empty .)


state 134

    (14) proc2 -> , proc1 .

    )               reduce using rule 14 (proc2 -> , proc1 .)


state 135

    (36) set_operation -> ID . OPERATION ( . set_operation1 )
    (112) map_operation -> ID . OPERATION ( . )
    (37) set_operation1 -> . expression
    (38) set_operation1 -> . empty
    (60) expression -> . exp0 expression2
    (113) empty -> .
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 169
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    !               shift and go to state 89

  ! )               [ reduce using rule 113 (empty -> .) ]

    set_operation1                 shift and go to state 168
    expression                     shift and go to state 170
    empty                          shift and go to state 171
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88

state 136

    (110) map_access -> ID ( exp ) .

    ASSIGNATOR      reduce using rule 110 (map_access -> ID ( exp ) .)
    *               reduce using rule 110 (map_access -> ID ( exp ) .)
    /               reduce using rule 110 (map_access -> ID ( exp ) .)
    +               reduce using rule 110 (map_access -> ID ( exp ) .)
    -               reduce using rule 110 (map_access -> ID ( exp ) .)
    <               reduce using rule 110 (map_access -> ID ( exp ) .)
    >               reduce using rule 110 (map_access -> ID ( exp ) .)
    NOT_EQ          reduce using rule 110 (map_access -> ID ( exp ) .)
    EQ              reduce using rule 110 (map_access -> ID ( exp ) .)
    LEQ             reduce using rule 110 (map_access -> ID ( exp ) .)
    GEQ             reduce using rule 110 (map_access -> ID ( exp ) .)
    OR              reduce using rule 110 (map_access -> ID ( exp ) .)
    AND             reduce using rule 110 (map_access -> ID ( exp ) .)
    ;               reduce using rule 110 (map_access -> ID ( exp ) .)
    )               reduce using rule 110 (map_access -> ID ( exp ) .)
    ,               reduce using rule 110 (map_access -> ID ( exp ) .)


state 137

    (24) input -> READ ( ID input1 . )

    )               shift and go to state 172


state 138

    (25) input1 -> , . ID input1

    ID              shift and go to state 173


state 139

    (26) input1 -> empty .

    )               reduce using rule 26 (input1 -> empty .)


state 140

    (27) output -> PRINT ( expression output1 . )

    )               shift and go to state 174


state 141

    (28) output1 -> , . expression output1
    (60) expression -> . exp0 expression2
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty
    (113) empty -> .

    !               shift and go to state 89
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    expression                     shift and go to state 175
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88
    empty                          shift and go to state 90

state 142

    (29) output1 -> empty .

    )               reduce using rule 29 (output1 -> empty .)


state 143

    (61) expression2 -> logop exp0 . expression2
    (61) expression2 -> . logop exp0 expression2
    (62) expression2 -> . empty
    (58) logop -> . OR
    (59) logop -> . AND
    (113) empty -> .

    OR              shift and go to state 106
    AND             shift and go to state 107
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)

    logop                          shift and go to state 104
    expression2                    shift and go to state 176
    empty                          shift and go to state 105

state 144

    (64) exp02 -> relop exp02 .

    OR              reduce using rule 64 (exp02 -> relop exp02 .)
    AND             reduce using rule 64 (exp02 -> relop exp02 .)
    ;               reduce using rule 64 (exp02 -> relop exp02 .)
    ,               reduce using rule 64 (exp02 -> relop exp02 .)
    )               reduce using rule 64 (exp02 -> relop exp02 .)


state 145

    (71) exp2 -> addsub term . exp2
    (71) exp2 -> . addsub term exp2
    (72) exp2 -> . empty
    (67) addsub -> . +
    (68) addsub -> . -
    (113) empty -> .

    +               shift and go to state 120
    -               shift and go to state 121
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    NOT_EQ          reduce using rule 113 (empty -> .)
    EQ              reduce using rule 113 (empty -> .)
    LEQ             reduce using rule 113 (empty -> .)
    GEQ             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    addsub                         shift and go to state 118
    exp2                           shift and go to state 177
    empty                          shift and go to state 119

state 146

    (73) term -> term_not factor term2 .

    +               reduce using rule 73 (term -> term_not factor term2 .)
    -               reduce using rule 73 (term -> term_not factor term2 .)
    <               reduce using rule 73 (term -> term_not factor term2 .)
    >               reduce using rule 73 (term -> term_not factor term2 .)
    NOT_EQ          reduce using rule 73 (term -> term_not factor term2 .)
    EQ              reduce using rule 73 (term -> term_not factor term2 .)
    LEQ             reduce using rule 73 (term -> term_not factor term2 .)
    GEQ             reduce using rule 73 (term -> term_not factor term2 .)
    OR              reduce using rule 73 (term -> term_not factor term2 .)
    AND             reduce using rule 73 (term -> term_not factor term2 .)
    ;               reduce using rule 73 (term -> term_not factor term2 .)
    )               reduce using rule 73 (term -> term_not factor term2 .)
    ,               reduce using rule 73 (term -> term_not factor term2 .)


state 147

    (74) term2 -> muldiv . factor term2
    (78) factor -> . ( expression )
    (79) factor -> . factor2
    (80) factor2 -> . factor3 varcte
    (81) factor3 -> . addsub
    (82) factor3 -> . empty
    (67) addsub -> . +
    (68) addsub -> . -
    (113) empty -> .

    (               shift and go to state 123
    +               shift and go to state 120
    -               shift and go to state 121
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)

    factor                         shift and go to state 178
    factor2                        shift and go to state 124
    factor3                        shift and go to state 125
    addsub                         shift and go to state 126
    empty                          shift and go to state 127

state 148

    (75) term2 -> empty .

    +               reduce using rule 75 (term2 -> empty .)
    -               reduce using rule 75 (term2 -> empty .)
    <               reduce using rule 75 (term2 -> empty .)
    >               reduce using rule 75 (term2 -> empty .)
    NOT_EQ          reduce using rule 75 (term2 -> empty .)
    EQ              reduce using rule 75 (term2 -> empty .)
    LEQ             reduce using rule 75 (term2 -> empty .)
    GEQ             reduce using rule 75 (term2 -> empty .)
    OR              reduce using rule 75 (term2 -> empty .)
    AND             reduce using rule 75 (term2 -> empty .)
    ;               reduce using rule 75 (term2 -> empty .)
    )               reduce using rule 75 (term2 -> empty .)
    ,               reduce using rule 75 (term2 -> empty .)


state 149

    (69) muldiv -> * .

    (               reduce using rule 69 (muldiv -> * .)
    +               reduce using rule 69 (muldiv -> * .)
    -               reduce using rule 69 (muldiv -> * .)
    ID              reduce using rule 69 (muldiv -> * .)
    CTE_INT         reduce using rule 69 (muldiv -> * .)
    CTE_FLOAT       reduce using rule 69 (muldiv -> * .)
    CTE_BOOL        reduce using rule 69 (muldiv -> * .)
    CTE_STRING      reduce using rule 69 (muldiv -> * .)
    CTE_CHAR        reduce using rule 69 (muldiv -> * .)


state 150

    (70) muldiv -> / .

    (               reduce using rule 70 (muldiv -> / .)
    +               reduce using rule 70 (muldiv -> / .)
    -               reduce using rule 70 (muldiv -> / .)
    ID              reduce using rule 70 (muldiv -> / .)
    CTE_INT         reduce using rule 70 (muldiv -> / .)
    CTE_FLOAT       reduce using rule 70 (muldiv -> / .)
    CTE_BOOL        reduce using rule 70 (muldiv -> / .)
    CTE_STRING      reduce using rule 70 (muldiv -> / .)
    CTE_CHAR        reduce using rule 70 (muldiv -> / .)


state 151

    (78) factor -> ( expression . )

    )               shift and go to state 179


state 152

    (80) factor2 -> factor3 varcte .

    *               reduce using rule 80 (factor2 -> factor3 varcte .)
    /               reduce using rule 80 (factor2 -> factor3 varcte .)
    +               reduce using rule 80 (factor2 -> factor3 varcte .)
    -               reduce using rule 80 (factor2 -> factor3 varcte .)
    <               reduce using rule 80 (factor2 -> factor3 varcte .)
    >               reduce using rule 80 (factor2 -> factor3 varcte .)
    NOT_EQ          reduce using rule 80 (factor2 -> factor3 varcte .)
    EQ              reduce using rule 80 (factor2 -> factor3 varcte .)
    LEQ             reduce using rule 80 (factor2 -> factor3 varcte .)
    GEQ             reduce using rule 80 (factor2 -> factor3 varcte .)
    OR              reduce using rule 80 (factor2 -> factor3 varcte .)
    AND             reduce using rule 80 (factor2 -> factor3 varcte .)
    ;               reduce using rule 80 (factor2 -> factor3 varcte .)
    )               reduce using rule 80 (factor2 -> factor3 varcte .)
    ,               reduce using rule 80 (factor2 -> factor3 varcte .)


state 153

    (83) varcte -> ID .
    (30) function_call -> ID . ( function_call1 )
    (110) map_access -> ID . ( exp )
    (112) map_operation -> ID . . OPERATION ( )
    (36) set_operation -> ID . . OPERATION ( set_operation1 )

    *               reduce using rule 83 (varcte -> ID .)
    /               reduce using rule 83 (varcte -> ID .)
    +               reduce using rule 83 (varcte -> ID .)
    -               reduce using rule 83 (varcte -> ID .)
    <               reduce using rule 83 (varcte -> ID .)
    >               reduce using rule 83 (varcte -> ID .)
    NOT_EQ          reduce using rule 83 (varcte -> ID .)
    EQ              reduce using rule 83 (varcte -> ID .)
    LEQ             reduce using rule 83 (varcte -> ID .)
    GEQ             reduce using rule 83 (varcte -> ID .)
    OR              reduce using rule 83 (varcte -> ID .)
    AND             reduce using rule 83 (varcte -> ID .)
    ;               reduce using rule 83 (varcte -> ID .)
    )               reduce using rule 83 (varcte -> ID .)
    ,               reduce using rule 83 (varcte -> ID .)
    (               shift and go to state 180
    .               shift and go to state 181


state 154

    (84) varcte -> CTE_INT .

    *               reduce using rule 84 (varcte -> CTE_INT .)
    /               reduce using rule 84 (varcte -> CTE_INT .)
    +               reduce using rule 84 (varcte -> CTE_INT .)
    -               reduce using rule 84 (varcte -> CTE_INT .)
    <               reduce using rule 84 (varcte -> CTE_INT .)
    >               reduce using rule 84 (varcte -> CTE_INT .)
    NOT_EQ          reduce using rule 84 (varcte -> CTE_INT .)
    EQ              reduce using rule 84 (varcte -> CTE_INT .)
    LEQ             reduce using rule 84 (varcte -> CTE_INT .)
    GEQ             reduce using rule 84 (varcte -> CTE_INT .)
    OR              reduce using rule 84 (varcte -> CTE_INT .)
    AND             reduce using rule 84 (varcte -> CTE_INT .)
    ;               reduce using rule 84 (varcte -> CTE_INT .)
    )               reduce using rule 84 (varcte -> CTE_INT .)
    ,               reduce using rule 84 (varcte -> CTE_INT .)


state 155

    (85) varcte -> CTE_FLOAT .

    *               reduce using rule 85 (varcte -> CTE_FLOAT .)
    /               reduce using rule 85 (varcte -> CTE_FLOAT .)
    +               reduce using rule 85 (varcte -> CTE_FLOAT .)
    -               reduce using rule 85 (varcte -> CTE_FLOAT .)
    <               reduce using rule 85 (varcte -> CTE_FLOAT .)
    >               reduce using rule 85 (varcte -> CTE_FLOAT .)
    NOT_EQ          reduce using rule 85 (varcte -> CTE_FLOAT .)
    EQ              reduce using rule 85 (varcte -> CTE_FLOAT .)
    LEQ             reduce using rule 85 (varcte -> CTE_FLOAT .)
    GEQ             reduce using rule 85 (varcte -> CTE_FLOAT .)
    OR              reduce using rule 85 (varcte -> CTE_FLOAT .)
    AND             reduce using rule 85 (varcte -> CTE_FLOAT .)
    ;               reduce using rule 85 (varcte -> CTE_FLOAT .)
    )               reduce using rule 85 (varcte -> CTE_FLOAT .)
    ,               reduce using rule 85 (varcte -> CTE_FLOAT .)


state 156

    (86) varcte -> CTE_BOOL .

    *               reduce using rule 86 (varcte -> CTE_BOOL .)
    /               reduce using rule 86 (varcte -> CTE_BOOL .)
    +               reduce using rule 86 (varcte -> CTE_BOOL .)
    -               reduce using rule 86 (varcte -> CTE_BOOL .)
    <               reduce using rule 86 (varcte -> CTE_BOOL .)
    >               reduce using rule 86 (varcte -> CTE_BOOL .)
    NOT_EQ          reduce using rule 86 (varcte -> CTE_BOOL .)
    EQ              reduce using rule 86 (varcte -> CTE_BOOL .)
    LEQ             reduce using rule 86 (varcte -> CTE_BOOL .)
    GEQ             reduce using rule 86 (varcte -> CTE_BOOL .)
    OR              reduce using rule 86 (varcte -> CTE_BOOL .)
    AND             reduce using rule 86 (varcte -> CTE_BOOL .)
    ;               reduce using rule 86 (varcte -> CTE_BOOL .)
    )               reduce using rule 86 (varcte -> CTE_BOOL .)
    ,               reduce using rule 86 (varcte -> CTE_BOOL .)


state 157

    (87) varcte -> CTE_STRING .

    *               reduce using rule 87 (varcte -> CTE_STRING .)
    /               reduce using rule 87 (varcte -> CTE_STRING .)
    +               reduce using rule 87 (varcte -> CTE_STRING .)
    -               reduce using rule 87 (varcte -> CTE_STRING .)
    <               reduce using rule 87 (varcte -> CTE_STRING .)
    >               reduce using rule 87 (varcte -> CTE_STRING .)
    NOT_EQ          reduce using rule 87 (varcte -> CTE_STRING .)
    EQ              reduce using rule 87 (varcte -> CTE_STRING .)
    LEQ             reduce using rule 87 (varcte -> CTE_STRING .)
    GEQ             reduce using rule 87 (varcte -> CTE_STRING .)
    OR              reduce using rule 87 (varcte -> CTE_STRING .)
    AND             reduce using rule 87 (varcte -> CTE_STRING .)
    ;               reduce using rule 87 (varcte -> CTE_STRING .)
    )               reduce using rule 87 (varcte -> CTE_STRING .)
    ,               reduce using rule 87 (varcte -> CTE_STRING .)


state 158

    (88) varcte -> CTE_CHAR .

    *               reduce using rule 88 (varcte -> CTE_CHAR .)
    /               reduce using rule 88 (varcte -> CTE_CHAR .)
    +               reduce using rule 88 (varcte -> CTE_CHAR .)
    -               reduce using rule 88 (varcte -> CTE_CHAR .)
    <               reduce using rule 88 (varcte -> CTE_CHAR .)
    >               reduce using rule 88 (varcte -> CTE_CHAR .)
    NOT_EQ          reduce using rule 88 (varcte -> CTE_CHAR .)
    EQ              reduce using rule 88 (varcte -> CTE_CHAR .)
    LEQ             reduce using rule 88 (varcte -> CTE_CHAR .)
    GEQ             reduce using rule 88 (varcte -> CTE_CHAR .)
    OR              reduce using rule 88 (varcte -> CTE_CHAR .)
    AND             reduce using rule 88 (varcte -> CTE_CHAR .)
    ;               reduce using rule 88 (varcte -> CTE_CHAR .)
    )               reduce using rule 88 (varcte -> CTE_CHAR .)
    ,               reduce using rule 88 (varcte -> CTE_CHAR .)


state 159

    (89) varcte -> function_call .

    *               reduce using rule 89 (varcte -> function_call .)
    /               reduce using rule 89 (varcte -> function_call .)
    +               reduce using rule 89 (varcte -> function_call .)
    -               reduce using rule 89 (varcte -> function_call .)
    <               reduce using rule 89 (varcte -> function_call .)
    >               reduce using rule 89 (varcte -> function_call .)
    NOT_EQ          reduce using rule 89 (varcte -> function_call .)
    EQ              reduce using rule 89 (varcte -> function_call .)
    LEQ             reduce using rule 89 (varcte -> function_call .)
    GEQ             reduce using rule 89 (varcte -> function_call .)
    OR              reduce using rule 89 (varcte -> function_call .)
    AND             reduce using rule 89 (varcte -> function_call .)
    ;               reduce using rule 89 (varcte -> function_call .)
    )               reduce using rule 89 (varcte -> function_call .)
    ,               reduce using rule 89 (varcte -> function_call .)


state 160

    (90) varcte -> map_access .

    *               reduce using rule 90 (varcte -> map_access .)
    /               reduce using rule 90 (varcte -> map_access .)
    +               reduce using rule 90 (varcte -> map_access .)
    -               reduce using rule 90 (varcte -> map_access .)
    <               reduce using rule 90 (varcte -> map_access .)
    >               reduce using rule 90 (varcte -> map_access .)
    NOT_EQ          reduce using rule 90 (varcte -> map_access .)
    EQ              reduce using rule 90 (varcte -> map_access .)
    LEQ             reduce using rule 90 (varcte -> map_access .)
    GEQ             reduce using rule 90 (varcte -> map_access .)
    OR              reduce using rule 90 (varcte -> map_access .)
    AND             reduce using rule 90 (varcte -> map_access .)
    ;               reduce using rule 90 (varcte -> map_access .)
    )               reduce using rule 90 (varcte -> map_access .)
    ,               reduce using rule 90 (varcte -> map_access .)


state 161

    (91) varcte -> map_operation .

    *               reduce using rule 91 (varcte -> map_operation .)
    /               reduce using rule 91 (varcte -> map_operation .)
    +               reduce using rule 91 (varcte -> map_operation .)
    -               reduce using rule 91 (varcte -> map_operation .)
    <               reduce using rule 91 (varcte -> map_operation .)
    >               reduce using rule 91 (varcte -> map_operation .)
    NOT_EQ          reduce using rule 91 (varcte -> map_operation .)
    EQ              reduce using rule 91 (varcte -> map_operation .)
    LEQ             reduce using rule 91 (varcte -> map_operation .)
    GEQ             reduce using rule 91 (varcte -> map_operation .)
    OR              reduce using rule 91 (varcte -> map_operation .)
    AND             reduce using rule 91 (varcte -> map_operation .)
    ;               reduce using rule 91 (varcte -> map_operation .)
    )               reduce using rule 91 (varcte -> map_operation .)
    ,               reduce using rule 91 (varcte -> map_operation .)


state 162

    (92) varcte -> set_operation .

    *               reduce using rule 92 (varcte -> set_operation .)
    /               reduce using rule 92 (varcte -> set_operation .)
    +               reduce using rule 92 (varcte -> set_operation .)
    -               reduce using rule 92 (varcte -> set_operation .)
    <               reduce using rule 92 (varcte -> set_operation .)
    >               reduce using rule 92 (varcte -> set_operation .)
    NOT_EQ          reduce using rule 92 (varcte -> set_operation .)
    EQ              reduce using rule 92 (varcte -> set_operation .)
    LEQ             reduce using rule 92 (varcte -> set_operation .)
    GEQ             reduce using rule 92 (varcte -> set_operation .)
    OR              reduce using rule 92 (varcte -> set_operation .)
    AND             reduce using rule 92 (varcte -> set_operation .)
    ;               reduce using rule 92 (varcte -> set_operation .)
    )               reduce using rule 92 (varcte -> set_operation .)
    ,               reduce using rule 92 (varcte -> set_operation .)


state 163

    (21) condition -> IF ( expression ) . block condition1
    (103) block -> . { statement_aux }

    {               shift and go to state 183

    block                          shift and go to state 182

state 164

    (51) while -> WHILE ( expression ) . block
    (103) block -> . { statement_aux }

    {               shift and go to state 183

    block                          shift and go to state 184

state 165

    (12) proc -> functype ID ( proc1 ) { proc3 proc4 . }

    }               shift and go to state 185


state 166

    (18) proc4 -> statement . proc4
    (18) proc4 -> . statement proc4
    (19) proc4 -> . empty
    (39) statement -> . statement1 ;
    (40) statement -> . statement2
    (113) empty -> .
    (41) statement1 -> . assignment
    (42) statement1 -> . input
    (43) statement1 -> . output
    (44) statement1 -> . set_operation
    (45) statement1 -> . map_definition
    (46) statement1 -> . return
    (47) statement1 -> . map_assignment
    (48) statement1 -> . map_operation
    (49) statement2 -> . condition
    (50) statement2 -> . while
    (20) assignment -> . ID ASSIGNATOR expression
    (24) input -> . READ ( ID input1 )
    (27) output -> . PRINT ( expression output1 )
    (36) set_operation -> . ID . OPERATION ( set_operation1 )
    (109) map_definition -> . MAP < datatype , datatype >
    (35) return -> . RETURN expression
    (111) map_assignment -> . map_access ASSIGNATOR exp
    (112) map_operation -> . ID . OPERATION ( )
    (21) condition -> . IF ( expression ) block condition1
    (51) while -> . WHILE ( expression ) block
    (110) map_access -> . ID ( exp )

    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 66
    READ            shift and go to state 67
    PRINT           shift and go to state 68
    MAP             shift and go to state 18
    RETURN          shift and go to state 69
    IF              shift and go to state 71
    WHILE           shift and go to state 72

    statement                      shift and go to state 166
    proc4                          shift and go to state 186
    empty                          shift and go to state 167
    statement1                     shift and go to state 54
    statement2                     shift and go to state 55
    assignment                     shift and go to state 56
    input                          shift and go to state 57
    output                         shift and go to state 58
    set_operation                  shift and go to state 59
    map_definition                 shift and go to state 60
    return                         shift and go to state 61
    map_assignment                 shift and go to state 62
    map_operation                  shift and go to state 63
    condition                      shift and go to state 64
    while                          shift and go to state 65
    map_access                     shift and go to state 70

state 167

    (19) proc4 -> empty .

    }               reduce using rule 19 (proc4 -> empty .)


state 168

    (36) set_operation -> ID . OPERATION ( set_operation1 . )

    )               shift and go to state 187


state 169

    (112) map_operation -> ID . OPERATION ( ) .

    ;               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    *               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    /               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    +               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    -               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    <               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    >               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    NOT_EQ          reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    EQ              reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    LEQ             reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    GEQ             reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    OR              reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    AND             reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    )               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)
    ,               reduce using rule 112 (map_operation -> ID . OPERATION ( ) .)


state 170

    (37) set_operation1 -> expression .

    )               reduce using rule 37 (set_operation1 -> expression .)


state 171

    (38) set_operation1 -> empty .
    (77) term_not -> empty .

    )               reduce using rule 38 (set_operation1 -> empty .)
    (               reduce using rule 77 (term_not -> empty .)
    +               reduce using rule 77 (term_not -> empty .)
    -               reduce using rule 77 (term_not -> empty .)
    ID              reduce using rule 77 (term_not -> empty .)
    CTE_INT         reduce using rule 77 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 77 (term_not -> empty .)
    CTE_BOOL        reduce using rule 77 (term_not -> empty .)
    CTE_STRING      reduce using rule 77 (term_not -> empty .)
    CTE_CHAR        reduce using rule 77 (term_not -> empty .)


state 172

    (24) input -> READ ( ID input1 ) .

    ;               reduce using rule 24 (input -> READ ( ID input1 ) .)


state 173

    (25) input1 -> , ID . input1
    (25) input1 -> . , ID input1
    (26) input1 -> . empty
    (113) empty -> .

    ,               shift and go to state 138
    )               reduce using rule 113 (empty -> .)

    input1                         shift and go to state 188
    empty                          shift and go to state 139

state 174

    (27) output -> PRINT ( expression output1 ) .

    ;               reduce using rule 27 (output -> PRINT ( expression output1 ) .)


state 175

    (28) output1 -> , expression . output1
    (28) output1 -> . , expression output1
    (29) output1 -> . empty
    (113) empty -> .

    ,               shift and go to state 141
    )               reduce using rule 113 (empty -> .)

    output1                        shift and go to state 189
    empty                          shift and go to state 142

state 176

    (61) expression2 -> logop exp0 expression2 .

    ;               reduce using rule 61 (expression2 -> logop exp0 expression2 .)
    ,               reduce using rule 61 (expression2 -> logop exp0 expression2 .)
    )               reduce using rule 61 (expression2 -> logop exp0 expression2 .)


state 177

    (71) exp2 -> addsub term exp2 .

    <               reduce using rule 71 (exp2 -> addsub term exp2 .)
    >               reduce using rule 71 (exp2 -> addsub term exp2 .)
    NOT_EQ          reduce using rule 71 (exp2 -> addsub term exp2 .)
    EQ              reduce using rule 71 (exp2 -> addsub term exp2 .)
    LEQ             reduce using rule 71 (exp2 -> addsub term exp2 .)
    GEQ             reduce using rule 71 (exp2 -> addsub term exp2 .)
    OR              reduce using rule 71 (exp2 -> addsub term exp2 .)
    AND             reduce using rule 71 (exp2 -> addsub term exp2 .)
    ;               reduce using rule 71 (exp2 -> addsub term exp2 .)
    )               reduce using rule 71 (exp2 -> addsub term exp2 .)
    ,               reduce using rule 71 (exp2 -> addsub term exp2 .)


state 178

    (74) term2 -> muldiv factor . term2
    (74) term2 -> . muldiv factor term2
    (75) term2 -> . empty
    (69) muldiv -> . *
    (70) muldiv -> . /
    (113) empty -> .

    *               shift and go to state 149
    /               shift and go to state 150
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    NOT_EQ          reduce using rule 113 (empty -> .)
    EQ              reduce using rule 113 (empty -> .)
    LEQ             reduce using rule 113 (empty -> .)
    GEQ             reduce using rule 113 (empty -> .)
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    muldiv                         shift and go to state 147
    term2                          shift and go to state 190
    empty                          shift and go to state 148

state 179

    (78) factor -> ( expression ) .

    *               reduce using rule 78 (factor -> ( expression ) .)
    /               reduce using rule 78 (factor -> ( expression ) .)
    +               reduce using rule 78 (factor -> ( expression ) .)
    -               reduce using rule 78 (factor -> ( expression ) .)
    <               reduce using rule 78 (factor -> ( expression ) .)
    >               reduce using rule 78 (factor -> ( expression ) .)
    NOT_EQ          reduce using rule 78 (factor -> ( expression ) .)
    EQ              reduce using rule 78 (factor -> ( expression ) .)
    LEQ             reduce using rule 78 (factor -> ( expression ) .)
    GEQ             reduce using rule 78 (factor -> ( expression ) .)
    OR              reduce using rule 78 (factor -> ( expression ) .)
    AND             reduce using rule 78 (factor -> ( expression ) .)
    ;               reduce using rule 78 (factor -> ( expression ) .)
    )               reduce using rule 78 (factor -> ( expression ) .)
    ,               reduce using rule 78 (factor -> ( expression ) .)


state 180

    (30) function_call -> ID ( . function_call1 )
    (110) map_access -> ID ( . exp )
    (31) function_call1 -> . function_call2
    (32) function_call1 -> . empty
    (66) exp -> . term exp2
    (33) function_call2 -> . expression , function_call2
    (34) function_call2 -> . empty
    (113) empty -> .
    (73) term -> . term_not factor term2
    (60) expression -> . exp0 expression2
    (76) term_not -> . !
    (77) term_not -> . empty
    (63) exp0 -> . exp exp02

    )               reduce using rule 113 (empty -> .)
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    !               shift and go to state 89

    function_call1                 shift and go to state 191
    exp                            shift and go to state 192
    function_call2                 shift and go to state 193
    empty                          shift and go to state 194
    term                           shift and go to state 87
    expression                     shift and go to state 195
    term_not                       shift and go to state 88
    exp0                           shift and go to state 85

state 181

    (112) map_operation -> ID . . OPERATION ( )
    (36) set_operation -> ID . . OPERATION ( set_operation1 )

    OPERATION       shift and go to state 196


state 182

    (21) condition -> IF ( expression ) block . condition1
    (22) condition1 -> . ELSE block
    (23) condition1 -> . empty
    (113) empty -> .

    ELSE            shift and go to state 198
    ID              reduce using rule 113 (empty -> .)
    READ            reduce using rule 113 (empty -> .)
    PRINT           reduce using rule 113 (empty -> .)
    MAP             reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    }               reduce using rule 113 (empty -> .)

    condition1                     shift and go to state 197
    empty                          shift and go to state 199

state 183

    (103) block -> { . statement_aux }
    (104) statement_aux -> . statement statement_aux
    (105) statement_aux -> . empty
    (39) statement -> . statement1 ;
    (40) statement -> . statement2
    (113) empty -> .
    (41) statement1 -> . assignment
    (42) statement1 -> . input
    (43) statement1 -> . output
    (44) statement1 -> . set_operation
    (45) statement1 -> . map_definition
    (46) statement1 -> . return
    (47) statement1 -> . map_assignment
    (48) statement1 -> . map_operation
    (49) statement2 -> . condition
    (50) statement2 -> . while
    (20) assignment -> . ID ASSIGNATOR expression
    (24) input -> . READ ( ID input1 )
    (27) output -> . PRINT ( expression output1 )
    (36) set_operation -> . ID . OPERATION ( set_operation1 )
    (109) map_definition -> . MAP < datatype , datatype >
    (35) return -> . RETURN expression
    (111) map_assignment -> . map_access ASSIGNATOR exp
    (112) map_operation -> . ID . OPERATION ( )
    (21) condition -> . IF ( expression ) block condition1
    (51) while -> . WHILE ( expression ) block
    (110) map_access -> . ID ( exp )

    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 66
    READ            shift and go to state 67
    PRINT           shift and go to state 68
    MAP             shift and go to state 18
    RETURN          shift and go to state 69
    IF              shift and go to state 71
    WHILE           shift and go to state 72

    statement_aux                  shift and go to state 200
    statement                      shift and go to state 52
    empty                          shift and go to state 53
    statement1                     shift and go to state 54
    statement2                     shift and go to state 55
    assignment                     shift and go to state 56
    input                          shift and go to state 57
    output                         shift and go to state 58
    set_operation                  shift and go to state 59
    map_definition                 shift and go to state 60
    return                         shift and go to state 61
    map_assignment                 shift and go to state 62
    map_operation                  shift and go to state 63
    condition                      shift and go to state 64
    while                          shift and go to state 65
    map_access                     shift and go to state 70

state 184

    (51) while -> WHILE ( expression ) block .

    ID              reduce using rule 51 (while -> WHILE ( expression ) block .)
    READ            reduce using rule 51 (while -> WHILE ( expression ) block .)
    PRINT           reduce using rule 51 (while -> WHILE ( expression ) block .)
    MAP             reduce using rule 51 (while -> WHILE ( expression ) block .)
    RETURN          reduce using rule 51 (while -> WHILE ( expression ) block .)
    IF              reduce using rule 51 (while -> WHILE ( expression ) block .)
    WHILE           reduce using rule 51 (while -> WHILE ( expression ) block .)
    }               reduce using rule 51 (while -> WHILE ( expression ) block .)


state 185

    (12) proc -> functype ID ( proc1 ) { proc3 proc4 } .

    VOID            reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    INT             reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    FLOAT           reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    BOOL            reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    STRING          reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    CHAR            reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    SET             reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    MAP             reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)
    MAIN            reduce using rule 12 (proc -> functype ID ( proc1 ) { proc3 proc4 } .)


state 186

    (18) proc4 -> statement proc4 .

    }               reduce using rule 18 (proc4 -> statement proc4 .)


state 187

    (36) set_operation -> ID . OPERATION ( set_operation1 ) .

    ;               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    *               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    /               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    +               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    -               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    <               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    >               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    NOT_EQ          reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    EQ              reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    LEQ             reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    GEQ             reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    OR              reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    AND             reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    )               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    ,               reduce using rule 36 (set_operation -> ID . OPERATION ( set_operation1 ) .)


state 188

    (25) input1 -> , ID input1 .

    )               reduce using rule 25 (input1 -> , ID input1 .)


state 189

    (28) output1 -> , expression output1 .

    )               reduce using rule 28 (output1 -> , expression output1 .)


state 190

    (74) term2 -> muldiv factor term2 .

    +               reduce using rule 74 (term2 -> muldiv factor term2 .)
    -               reduce using rule 74 (term2 -> muldiv factor term2 .)
    <               reduce using rule 74 (term2 -> muldiv factor term2 .)
    >               reduce using rule 74 (term2 -> muldiv factor term2 .)
    NOT_EQ          reduce using rule 74 (term2 -> muldiv factor term2 .)
    EQ              reduce using rule 74 (term2 -> muldiv factor term2 .)
    LEQ             reduce using rule 74 (term2 -> muldiv factor term2 .)
    GEQ             reduce using rule 74 (term2 -> muldiv factor term2 .)
    OR              reduce using rule 74 (term2 -> muldiv factor term2 .)
    AND             reduce using rule 74 (term2 -> muldiv factor term2 .)
    ;               reduce using rule 74 (term2 -> muldiv factor term2 .)
    )               reduce using rule 74 (term2 -> muldiv factor term2 .)
    ,               reduce using rule 74 (term2 -> muldiv factor term2 .)


state 191

    (30) function_call -> ID ( function_call1 . )

    )               shift and go to state 201


state 192

    (110) map_access -> ID ( exp . )
    (63) exp0 -> exp . exp02
    (64) exp02 -> . relop exp02
    (65) exp02 -> . empty
    (52) relop -> . <
    (53) relop -> . >
    (54) relop -> . NOT_EQ
    (55) relop -> . EQ
    (56) relop -> . LEQ
    (57) relop -> . GEQ
    (113) empty -> .

    )               shift and go to state 136
    <               shift and go to state 111
    >               shift and go to state 112
    NOT_EQ          shift and go to state 113
    EQ              shift and go to state 114
    LEQ             shift and go to state 115
    GEQ             shift and go to state 116
    OR              reduce using rule 113 (empty -> .)
    AND             reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    exp02                          shift and go to state 108
    relop                          shift and go to state 109
    empty                          shift and go to state 110

state 193

    (31) function_call1 -> function_call2 .

    )               reduce using rule 31 (function_call1 -> function_call2 .)


state 194

    (32) function_call1 -> empty .
    (34) function_call2 -> empty .
    (77) term_not -> empty .

  ! reduce/reduce conflict for ) resolved using rule 32 (function_call1 -> empty .)
    )               reduce using rule 32 (function_call1 -> empty .)
    (               reduce using rule 77 (term_not -> empty .)
    +               reduce using rule 77 (term_not -> empty .)
    -               reduce using rule 77 (term_not -> empty .)
    ID              reduce using rule 77 (term_not -> empty .)
    CTE_INT         reduce using rule 77 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 77 (term_not -> empty .)
    CTE_BOOL        reduce using rule 77 (term_not -> empty .)
    CTE_STRING      reduce using rule 77 (term_not -> empty .)
    CTE_CHAR        reduce using rule 77 (term_not -> empty .)

  ! )               [ reduce using rule 34 (function_call2 -> empty .) ]


state 195

    (33) function_call2 -> expression . , function_call2

    ,               shift and go to state 202


state 196

    (112) map_operation -> ID . OPERATION . ( )
    (36) set_operation -> ID . OPERATION . ( set_operation1 )

    (               shift and go to state 203


state 197

    (21) condition -> IF ( expression ) block condition1 .

    ID              reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    READ            reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    PRINT           reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    MAP             reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    RETURN          reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    IF              reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    WHILE           reduce using rule 21 (condition -> IF ( expression ) block condition1 .)
    }               reduce using rule 21 (condition -> IF ( expression ) block condition1 .)


state 198

    (22) condition1 -> ELSE . block
    (103) block -> . { statement_aux }

    {               shift and go to state 183

    block                          shift and go to state 204

state 199

    (23) condition1 -> empty .

    ID              reduce using rule 23 (condition1 -> empty .)
    READ            reduce using rule 23 (condition1 -> empty .)
    PRINT           reduce using rule 23 (condition1 -> empty .)
    MAP             reduce using rule 23 (condition1 -> empty .)
    RETURN          reduce using rule 23 (condition1 -> empty .)
    IF              reduce using rule 23 (condition1 -> empty .)
    WHILE           reduce using rule 23 (condition1 -> empty .)
    }               reduce using rule 23 (condition1 -> empty .)


state 200

    (103) block -> { statement_aux . }

    }               shift and go to state 205


state 201

    (30) function_call -> ID ( function_call1 ) .

    *               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    /               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    +               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    -               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    <               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    >               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    NOT_EQ          reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    EQ              reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    LEQ             reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    GEQ             reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    OR              reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    AND             reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    ;               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    )               reduce using rule 30 (function_call -> ID ( function_call1 ) .)
    ,               reduce using rule 30 (function_call -> ID ( function_call1 ) .)


state 202

    (33) function_call2 -> expression , . function_call2
    (33) function_call2 -> . expression , function_call2
    (34) function_call2 -> . empty
    (60) expression -> . exp0 expression2
    (113) empty -> .
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty

    )               reduce using rule 113 (empty -> .)
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    !               shift and go to state 89

    expression                     shift and go to state 195
    function_call2                 shift and go to state 206
    empty                          shift and go to state 207
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88

state 203

    (112) map_operation -> ID . OPERATION ( . )
    (36) set_operation -> ID . OPERATION ( . set_operation1 )
    (37) set_operation1 -> . expression
    (38) set_operation1 -> . empty
    (60) expression -> . exp0 expression2
    (113) empty -> .
    (63) exp0 -> . exp exp02
    (66) exp -> . term exp2
    (73) term -> . term_not factor term2
    (76) term_not -> . !
    (77) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 169
    (               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    ID              reduce using rule 113 (empty -> .)
    CTE_INT         reduce using rule 113 (empty -> .)
    CTE_FLOAT       reduce using rule 113 (empty -> .)
    CTE_BOOL        reduce using rule 113 (empty -> .)
    CTE_STRING      reduce using rule 113 (empty -> .)
    CTE_CHAR        reduce using rule 113 (empty -> .)
    !               shift and go to state 89

  ! )               [ reduce using rule 113 (empty -> .) ]

    set_operation1                 shift and go to state 168
    expression                     shift and go to state 170
    empty                          shift and go to state 171
    exp0                           shift and go to state 85
    exp                            shift and go to state 86
    term                           shift and go to state 87
    term_not                       shift and go to state 88

state 204

    (22) condition1 -> ELSE block .

    ID              reduce using rule 22 (condition1 -> ELSE block .)
    READ            reduce using rule 22 (condition1 -> ELSE block .)
    PRINT           reduce using rule 22 (condition1 -> ELSE block .)
    MAP             reduce using rule 22 (condition1 -> ELSE block .)
    RETURN          reduce using rule 22 (condition1 -> ELSE block .)
    IF              reduce using rule 22 (condition1 -> ELSE block .)
    WHILE           reduce using rule 22 (condition1 -> ELSE block .)
    }               reduce using rule 22 (condition1 -> ELSE block .)


state 205

    (103) block -> { statement_aux } .

    ELSE            reduce using rule 103 (block -> { statement_aux } .)
    ID              reduce using rule 103 (block -> { statement_aux } .)
    READ            reduce using rule 103 (block -> { statement_aux } .)
    PRINT           reduce using rule 103 (block -> { statement_aux } .)
    MAP             reduce using rule 103 (block -> { statement_aux } .)
    RETURN          reduce using rule 103 (block -> { statement_aux } .)
    IF              reduce using rule 103 (block -> { statement_aux } .)
    WHILE           reduce using rule 103 (block -> { statement_aux } .)
    }               reduce using rule 103 (block -> { statement_aux } .)


state 206

    (33) function_call2 -> expression , function_call2 .

    )               reduce using rule 33 (function_call2 -> expression , function_call2 .)


state 207

    (34) function_call2 -> empty .
    (77) term_not -> empty .

    )               reduce using rule 34 (function_call2 -> empty .)
    (               reduce using rule 77 (term_not -> empty .)
    +               reduce using rule 77 (term_not -> empty .)
    -               reduce using rule 77 (term_not -> empty .)
    ID              reduce using rule 77 (term_not -> empty .)
    CTE_INT         reduce using rule 77 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 77 (term_not -> empty .)
    CTE_BOOL        reduce using rule 77 (term_not -> empty .)
    CTE_STRING      reduce using rule 77 (term_not -> empty .)
    CTE_CHAR        reduce using rule 77 (term_not -> empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 4 resolved as shift
WARNING: shift/reduce conflict for SET in state 4 resolved as shift
WARNING: shift/reduce conflict for MAP in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 33 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 33 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 33 resolved as shift
WARNING: shift/reduce conflict for STRING in state 33 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 33 resolved as shift
WARNING: shift/reduce conflict for SET in state 33 resolved as shift
WARNING: shift/reduce conflict for MAP in state 33 resolved as shift
WARNING: shift/reduce conflict for MAP in state 37 resolved as shift
WARNING: shift/reduce conflict for MAP in state 94 resolved as shift
WARNING: shift/reduce conflict for ) in state 135 resolved as shift
WARNING: shift/reduce conflict for ) in state 203 resolved as shift
WARNING: reduce/reduce conflict in state 194 resolved using rule (function_call1 -> empty)
WARNING: rejected rule (function_call2 -> empty) in state 194
