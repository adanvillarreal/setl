Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; program1
Rule 2     program1 -> var program1
Rule 3     program1 -> program2
Rule 4     program2 -> proc program2
Rule 5     program2 -> main
Rule 6     procs -> proc
Rule 7     procs -> proc procs
Rule 8     proc -> proca1 procA
Rule 9     proc -> VOID procA
Rule 10    proc -> empty
Rule 11    proca1 -> datatype ID (
Rule 12    procA -> proc1 ) { proc3 }
Rule 13    proc1 -> datatype ID proc2
Rule 14    proc1 -> empty
Rule 15    proc2 -> , datatype ID proc2
Rule 16    proc2 -> empty
Rule 17    proc3 -> var proc3
Rule 18    proc3 -> proc4
Rule 19    proc4 -> statement proc4
Rule 20    proc4 -> empty
Rule 21    vars -> var vars
Rule 22    vars -> var
Rule 23    var -> datatype var1
Rule 24    var1 -> ID , var1
Rule 25    var1 -> ID var2
Rule 26    var2 -> ;
Rule 27    assignment -> assignment2 ASSIGNATOR n_quad_assign expression
Rule 28    assignment2 -> ID
Rule 29    n_quad_assign -> <empty>
Rule 30    condition -> IF ( expression ) block condition1
Rule 31    condition1 -> ELSE block
Rule 32    condition1 -> empty
Rule 33    while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3
Rule 34    n_while_1 -> <empty>
Rule 35    n_while_2 -> <empty>
Rule 36    n_while_3 -> <empty>
Rule 37    input -> READ ( ID input1 )
Rule 38    input1 -> , ID input1
Rule 39    input1 -> empty
Rule 40    output -> PRINT ( expression output1 )
Rule 41    output1 -> , expression output1
Rule 42    output1 -> empty
Rule 43    function_call -> ID ( function_call1 )
Rule 44    function_call1 -> empty
Rule 45    function_call1 -> function_call2
Rule 46    function_call2 -> expression , function_call2
Rule 47    function_call2 -> expression
Rule 48    return -> RETURN expression
Rule 49    set_operation -> ID . OPERATION ( set_operation1 )
Rule 50    set_operation1 -> expression
Rule 51    set_operation1 -> empty
Rule 52    statement -> statement1 ;
Rule 53    statement -> statement2
Rule 54    statement1 -> assignment
Rule 55    statement1 -> input
Rule 56    statement1 -> output
Rule 57    statement1 -> set_operation
Rule 58    statement1 -> map_definition
Rule 59    statement1 -> return
Rule 60    statement1 -> map_assignment
Rule 61    statement1 -> map_operation
Rule 62    statement1 -> function_call
Rule 63    statement2 -> condition
Rule 64    statement2 -> while
Rule 65    relop -> <
Rule 66    relop -> >
Rule 67    relop -> NOT_EQ
Rule 68    relop -> EQ
Rule 69    relop -> LEQ
Rule 70    relop -> GEQ
Rule 71    logop -> OR
Rule 72    logop -> AND
Rule 73    expression -> exp0 expression2
Rule 74    expression2 -> logop exp0 n_quad_logop expression2
Rule 75    expression2 -> empty
Rule 76    n_quad_logop -> <empty>
Rule 77    exp0 -> exp exp02
Rule 78    exp02 -> relop exp
Rule 79    exp02 -> empty
Rule 80    exp -> term exp2
Rule 81    addsub -> +
Rule 82    addsub -> -
Rule 83    muldiv -> *
Rule 84    muldiv -> /
Rule 85    exp2 -> addsub term n_quad_addsub exp2
Rule 86    exp2 -> empty
Rule 87    term -> term_not factor n_quad_muldiv term2
Rule 88    n_quad_muldiv -> <empty>
Rule 89    n_quad_addsub -> <empty>
Rule 90    term2 -> muldiv factor n_quad_muldiv term2
Rule 91    term2 -> n_quad_not
Rule 92    n_quad_not -> <empty>
Rule 93    term_not -> !
Rule 94    term_not -> empty
Rule 95    factor -> ( n_push_false_bottom expression ) n_pop_false_bottom
Rule 96    factor -> varcte
Rule 97    n_push_false_bottom -> <empty>
Rule 98    n_pop_false_bottom -> <empty>
Rule 99    varcte -> ID empty
Rule 100   varcte -> varcte1
Rule 101   varcte1 -> CTE_INT
Rule 102   varcte1 -> CTE_FLOAT
Rule 103   varcte1 -> CTE_BOOL
Rule 104   varcte1 -> CTE_STRING
Rule 105   varcte1 -> CTE_CHAR
Rule 106   varcte1 -> function_call
Rule 107   varcte1 -> map_access
Rule 108   varcte1 -> map_operation
Rule 109   varcte1 -> set_operation
Rule 110   functype -> datatype
Rule 111   functype -> VOID
Rule 112   datatype -> INT
Rule 113   datatype -> FLOAT
Rule 114   datatype -> BOOL
Rule 115   datatype -> STRING
Rule 116   datatype -> CHAR
Rule 117   datatype -> set_definition
Rule 118   datatype -> map_definition
Rule 119   set_definition -> SET < datatype >
Rule 120   block -> { statement_aux }
Rule 121   statement_aux -> statement statement_aux
Rule 122   statement_aux -> empty
Rule 123   main -> MAIN n_clear_scope { vars_aux statement_aux }
Rule 124   n_clear_scope -> <empty>
Rule 125   vars_aux -> vars
Rule 126   vars_aux -> empty
Rule 127   map_definition -> MAP < datatype , datatype >
Rule 128   map_access -> ID ( exp )
Rule 129   map_assignment -> map_access ASSIGNATOR exp
Rule 130   map_operation -> ID . OPERATION ( )
Rule 131   empty -> <empty>

Terminals, with rules where they appear

!                    : 93
(                    : 11 30 33 37 40 43 49 95 128 130
)                    : 12 30 33 37 40 43 49 95 128 130
*                    : 83
+                    : 81
,                    : 15 24 38 41 46 127
-                    : 82
.                    : 49 130
/                    : 84
;                    : 1 26 52
<                    : 65 119 127
>                    : 66 119 127
AND                  : 72
ASSIGNATOR           : 27 129
BOOL                 : 114
CHAR                 : 116
CTE_BOOL             : 103
CTE_CHAR             : 105
CTE_FLOAT            : 102
CTE_INT              : 101
CTE_STRING           : 104
ELSE                 : 31
EQ                   : 68
FLOAT                : 113
GEQ                  : 70
ID                   : 1 11 13 15 24 25 28 37 38 43 49 99 128 130
IF                   : 30
INT                  : 112
LEQ                  : 69
MAIN                 : 123
MAP                  : 127
NOT_EQ               : 67
OPERATION            : 49 130
OR                   : 71
PRINT                : 40
PROGRAM              : 1
READ                 : 37
RETURN               : 48
SET                  : 119
STRING               : 115
VOID                 : 9 111
WHILE                : 33
error                : 
{                    : 12 120 123
}                    : 12 120 123

Nonterminals, with rules where they appear

addsub               : 85
assignment           : 54
assignment2          : 27
block                : 30 31 33
condition            : 63
condition1           : 30
datatype             : 11 13 15 23 110 119 127 127
empty                : 10 14 16 20 32 39 42 44 51 75 79 86 94 99 122 126
exp                  : 77 78 128 129
exp0                 : 73 74
exp02                : 77
exp2                 : 80 85
expression           : 27 30 33 40 41 46 47 48 50 95
expression2          : 73 74
factor               : 87 90
function_call        : 62 106
function_call1       : 43
function_call2       : 45 46
functype             : 
input                : 55
input1               : 37 38
logop                : 74
main                 : 5
map_access           : 107 129
map_assignment       : 60
map_definition       : 58 118
map_operation        : 61 108
muldiv               : 90
n_clear_scope        : 123
n_pop_false_bottom   : 95
n_push_false_bottom  : 95
n_quad_addsub        : 85
n_quad_assign        : 27
n_quad_logop         : 74
n_quad_muldiv        : 87 90
n_quad_not           : 91
n_while_1            : 33
n_while_2            : 33
n_while_3            : 33
output               : 56
output1              : 40 41
proc                 : 4 6 7
proc1                : 12
proc2                : 13 15
proc3                : 12 17
proc4                : 18 19
procA                : 8 9
proca1               : 8
procs                : 7
program              : 0
program1             : 1 2
program2             : 3 4
relop                : 78
return               : 59
set_definition       : 117
set_operation        : 57 109
set_operation1       : 49
statement            : 19 121
statement1           : 52
statement2           : 53
statement_aux        : 120 121 123
term                 : 80 85
term2                : 87 90
term_not             : 87
var                  : 2 17 21 22
var1                 : 23 24
var2                 : 25
varcte               : 96
varcte1              : 100
vars                 : 21 125
vars_aux             : 123
while                : 64

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; program1

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . ID ; program1

    ID              shift and go to state 3


state 2

    (0) S' -> program .



state 3

    (1) program -> PROGRAM ID . ; program1

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . program1
    (2) program1 -> . var program1
    (3) program1 -> . program2
    (23) var -> . datatype var1
    (4) program2 -> . proc program2
    (5) program2 -> . main
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (8) proc -> . proca1 procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (123) main -> . MAIN n_clear_scope { vars_aux statement_aux }
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >
    (11) proca1 -> . datatype ID (
    (131) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    VOID            shift and go to state 5
    MAIN            shift and go to state 23
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! VOID            [ reduce using rule 131 (empty -> .) ]
  ! MAIN            [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! BOOL            [ reduce using rule 131 (empty -> .) ]
  ! STRING          [ reduce using rule 131 (empty -> .) ]
  ! CHAR            [ reduce using rule 131 (empty -> .) ]
  ! SET             [ reduce using rule 131 (empty -> .) ]
  ! MAP             [ reduce using rule 131 (empty -> .) ]

    program1                       shift and go to state 9
    program2                       shift and go to state 10
    datatype                       shift and go to state 19
    proca1                         shift and go to state 11
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18
    var                            shift and go to state 12
    main                           shift and go to state 13
    proc                           shift and go to state 14
    empty                          shift and go to state 15

state 5

    (9) proc -> VOID . procA
    (12) procA -> . proc1 ) { proc3 }
    (13) proc1 -> . datatype ID proc2
    (14) proc1 -> . empty
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (131) empty -> .
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    )               reduce using rule 131 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17

    set_definition                 shift and go to state 18
    datatype                       shift and go to state 26
    map_definition                 shift and go to state 6
    procA                          shift and go to state 27
    proc1                          shift and go to state 24
    empty                          shift and go to state 25

state 6

    (118) datatype -> map_definition .

    ID              reduce using rule 118 (datatype -> map_definition .)
    >               reduce using rule 118 (datatype -> map_definition .)
    ,               reduce using rule 118 (datatype -> map_definition .)


state 7

    (116) datatype -> CHAR .

    ID              reduce using rule 116 (datatype -> CHAR .)
    >               reduce using rule 116 (datatype -> CHAR .)
    ,               reduce using rule 116 (datatype -> CHAR .)


state 8

    (119) set_definition -> SET . < datatype >

    <               shift and go to state 28


state 9

    (1) program -> PROGRAM ID ; program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID ; program1 .)


state 10

    (3) program1 -> program2 .

    $end            reduce using rule 3 (program1 -> program2 .)


state 11

    (8) proc -> proca1 . procA
    (12) procA -> . proc1 ) { proc3 }
    (13) proc1 -> . datatype ID proc2
    (14) proc1 -> . empty
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (131) empty -> .
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    )               reduce using rule 131 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17

    set_definition                 shift and go to state 18
    datatype                       shift and go to state 26
    procA                          shift and go to state 29
    empty                          shift and go to state 25
    map_definition                 shift and go to state 6
    proc1                          shift and go to state 24

state 12

    (2) program1 -> var . program1
    (2) program1 -> . var program1
    (3) program1 -> . program2
    (23) var -> . datatype var1
    (4) program2 -> . proc program2
    (5) program2 -> . main
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (8) proc -> . proca1 procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (123) main -> . MAIN n_clear_scope { vars_aux statement_aux }
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >
    (11) proca1 -> . datatype ID (
    (131) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    VOID            shift and go to state 5
    MAIN            shift and go to state 23
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! VOID            [ reduce using rule 131 (empty -> .) ]
  ! MAIN            [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! BOOL            [ reduce using rule 131 (empty -> .) ]
  ! STRING          [ reduce using rule 131 (empty -> .) ]
  ! CHAR            [ reduce using rule 131 (empty -> .) ]
  ! SET             [ reduce using rule 131 (empty -> .) ]
  ! MAP             [ reduce using rule 131 (empty -> .) ]

    program1                       shift and go to state 30
    program2                       shift and go to state 10
    datatype                       shift and go to state 19
    proca1                         shift and go to state 11
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18
    var                            shift and go to state 12
    main                           shift and go to state 13
    proc                           shift and go to state 14
    empty                          shift and go to state 15

state 13

    (5) program2 -> main .

    $end            reduce using rule 5 (program2 -> main .)


state 14

    (4) program2 -> proc . program2
    (4) program2 -> . proc program2
    (5) program2 -> . main
    (8) proc -> . proca1 procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (123) main -> . MAIN n_clear_scope { vars_aux statement_aux }
    (11) proca1 -> . datatype ID (
    (131) empty -> .
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    VOID            shift and go to state 5
    MAIN            shift and go to state 23
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! VOID            [ reduce using rule 131 (empty -> .) ]
  ! MAIN            [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! BOOL            [ reduce using rule 131 (empty -> .) ]
  ! STRING          [ reduce using rule 131 (empty -> .) ]
  ! CHAR            [ reduce using rule 131 (empty -> .) ]
  ! SET             [ reduce using rule 131 (empty -> .) ]
  ! MAP             [ reduce using rule 131 (empty -> .) ]

    set_definition                 shift and go to state 18
    program2                       shift and go to state 31
    datatype                       shift and go to state 32
    proca1                         shift and go to state 11
    map_definition                 shift and go to state 6
    main                           shift and go to state 13
    proc                           shift and go to state 14
    empty                          shift and go to state 15

state 15

    (10) proc -> empty .

    VOID            reduce using rule 10 (proc -> empty .)
    MAIN            reduce using rule 10 (proc -> empty .)
    INT             reduce using rule 10 (proc -> empty .)
    FLOAT           reduce using rule 10 (proc -> empty .)
    BOOL            reduce using rule 10 (proc -> empty .)
    STRING          reduce using rule 10 (proc -> empty .)
    CHAR            reduce using rule 10 (proc -> empty .)
    SET             reduce using rule 10 (proc -> empty .)
    MAP             reduce using rule 10 (proc -> empty .)


state 16

    (115) datatype -> STRING .

    ID              reduce using rule 115 (datatype -> STRING .)
    >               reduce using rule 115 (datatype -> STRING .)
    ,               reduce using rule 115 (datatype -> STRING .)


state 17

    (127) map_definition -> MAP . < datatype , datatype >

    <               shift and go to state 33


state 18

    (117) datatype -> set_definition .

    ID              reduce using rule 117 (datatype -> set_definition .)
    >               reduce using rule 117 (datatype -> set_definition .)
    ,               reduce using rule 117 (datatype -> set_definition .)


state 19

    (23) var -> datatype . var1
    (11) proca1 -> datatype . ID (
    (24) var1 -> . ID , var1
    (25) var1 -> . ID var2

    ID              shift and go to state 35

    var1                           shift and go to state 34

state 20

    (113) datatype -> FLOAT .

    ID              reduce using rule 113 (datatype -> FLOAT .)
    >               reduce using rule 113 (datatype -> FLOAT .)
    ,               reduce using rule 113 (datatype -> FLOAT .)


state 21

    (112) datatype -> INT .

    ID              reduce using rule 112 (datatype -> INT .)
    >               reduce using rule 112 (datatype -> INT .)
    ,               reduce using rule 112 (datatype -> INT .)


state 22

    (114) datatype -> BOOL .

    ID              reduce using rule 114 (datatype -> BOOL .)
    >               reduce using rule 114 (datatype -> BOOL .)
    ,               reduce using rule 114 (datatype -> BOOL .)


state 23

    (123) main -> MAIN . n_clear_scope { vars_aux statement_aux }
    (124) n_clear_scope -> .

    {               reduce using rule 124 (n_clear_scope -> .)

    n_clear_scope                  shift and go to state 36

state 24

    (12) procA -> proc1 . ) { proc3 }

    )               shift and go to state 37


state 25

    (14) proc1 -> empty .

    )               reduce using rule 14 (proc1 -> empty .)


state 26

    (13) proc1 -> datatype . ID proc2

    ID              shift and go to state 38


state 27

    (9) proc -> VOID procA .

    VOID            reduce using rule 9 (proc -> VOID procA .)
    MAIN            reduce using rule 9 (proc -> VOID procA .)
    INT             reduce using rule 9 (proc -> VOID procA .)
    FLOAT           reduce using rule 9 (proc -> VOID procA .)
    BOOL            reduce using rule 9 (proc -> VOID procA .)
    STRING          reduce using rule 9 (proc -> VOID procA .)
    CHAR            reduce using rule 9 (proc -> VOID procA .)
    SET             reduce using rule 9 (proc -> VOID procA .)
    MAP             reduce using rule 9 (proc -> VOID procA .)


state 28

    (119) set_definition -> SET < . datatype >
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 39
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 29

    (8) proc -> proca1 procA .

    VOID            reduce using rule 8 (proc -> proca1 procA .)
    MAIN            reduce using rule 8 (proc -> proca1 procA .)
    INT             reduce using rule 8 (proc -> proca1 procA .)
    FLOAT           reduce using rule 8 (proc -> proca1 procA .)
    BOOL            reduce using rule 8 (proc -> proca1 procA .)
    STRING          reduce using rule 8 (proc -> proca1 procA .)
    CHAR            reduce using rule 8 (proc -> proca1 procA .)
    SET             reduce using rule 8 (proc -> proca1 procA .)
    MAP             reduce using rule 8 (proc -> proca1 procA .)


state 30

    (2) program1 -> var program1 .

    $end            reduce using rule 2 (program1 -> var program1 .)


state 31

    (4) program2 -> proc program2 .

    $end            reduce using rule 4 (program2 -> proc program2 .)


state 32

    (11) proca1 -> datatype . ID (

    ID              shift and go to state 40


state 33

    (127) map_definition -> MAP < . datatype , datatype >
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 41
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 34

    (23) var -> datatype var1 .

    INT             reduce using rule 23 (var -> datatype var1 .)
    FLOAT           reduce using rule 23 (var -> datatype var1 .)
    BOOL            reduce using rule 23 (var -> datatype var1 .)
    STRING          reduce using rule 23 (var -> datatype var1 .)
    CHAR            reduce using rule 23 (var -> datatype var1 .)
    SET             reduce using rule 23 (var -> datatype var1 .)
    MAP             reduce using rule 23 (var -> datatype var1 .)
    READ            reduce using rule 23 (var -> datatype var1 .)
    PRINT           reduce using rule 23 (var -> datatype var1 .)
    ID              reduce using rule 23 (var -> datatype var1 .)
    RETURN          reduce using rule 23 (var -> datatype var1 .)
    IF              reduce using rule 23 (var -> datatype var1 .)
    WHILE           reduce using rule 23 (var -> datatype var1 .)
    }               reduce using rule 23 (var -> datatype var1 .)
    VOID            reduce using rule 23 (var -> datatype var1 .)
    MAIN            reduce using rule 23 (var -> datatype var1 .)


state 35

    (11) proca1 -> datatype ID . (
    (24) var1 -> ID . , var1
    (25) var1 -> ID . var2
    (26) var2 -> . ;

    (               shift and go to state 43
    ,               shift and go to state 44
    ;               shift and go to state 45

    var2                           shift and go to state 42

state 36

    (123) main -> MAIN n_clear_scope . { vars_aux statement_aux }

    {               shift and go to state 46


state 37

    (12) procA -> proc1 ) . { proc3 }

    {               shift and go to state 47


state 38

    (13) proc1 -> datatype ID . proc2
    (15) proc2 -> . , datatype ID proc2
    (16) proc2 -> . empty
    (131) empty -> .

    ,               shift and go to state 48
    )               reduce using rule 131 (empty -> .)

    empty                          shift and go to state 49
    proc2                          shift and go to state 50

state 39

    (119) set_definition -> SET < datatype . >

    >               shift and go to state 51


state 40

    (11) proca1 -> datatype ID . (

    (               shift and go to state 43


state 41

    (127) map_definition -> MAP < datatype . , datatype >

    ,               shift and go to state 52


state 42

    (25) var1 -> ID var2 .

    INT             reduce using rule 25 (var1 -> ID var2 .)
    FLOAT           reduce using rule 25 (var1 -> ID var2 .)
    BOOL            reduce using rule 25 (var1 -> ID var2 .)
    STRING          reduce using rule 25 (var1 -> ID var2 .)
    CHAR            reduce using rule 25 (var1 -> ID var2 .)
    VOID            reduce using rule 25 (var1 -> ID var2 .)
    MAIN            reduce using rule 25 (var1 -> ID var2 .)
    SET             reduce using rule 25 (var1 -> ID var2 .)
    MAP             reduce using rule 25 (var1 -> ID var2 .)
    READ            reduce using rule 25 (var1 -> ID var2 .)
    PRINT           reduce using rule 25 (var1 -> ID var2 .)
    ID              reduce using rule 25 (var1 -> ID var2 .)
    RETURN          reduce using rule 25 (var1 -> ID var2 .)
    IF              reduce using rule 25 (var1 -> ID var2 .)
    WHILE           reduce using rule 25 (var1 -> ID var2 .)
    }               reduce using rule 25 (var1 -> ID var2 .)


state 43

    (11) proca1 -> datatype ID ( .

    INT             reduce using rule 11 (proca1 -> datatype ID ( .)
    FLOAT           reduce using rule 11 (proca1 -> datatype ID ( .)
    BOOL            reduce using rule 11 (proca1 -> datatype ID ( .)
    STRING          reduce using rule 11 (proca1 -> datatype ID ( .)
    CHAR            reduce using rule 11 (proca1 -> datatype ID ( .)
    SET             reduce using rule 11 (proca1 -> datatype ID ( .)
    MAP             reduce using rule 11 (proca1 -> datatype ID ( .)
    )               reduce using rule 11 (proca1 -> datatype ID ( .)


state 44

    (24) var1 -> ID , . var1
    (24) var1 -> . ID , var1
    (25) var1 -> . ID var2

    ID              shift and go to state 54

    var1                           shift and go to state 53

state 45

    (26) var2 -> ; .

    INT             reduce using rule 26 (var2 -> ; .)
    FLOAT           reduce using rule 26 (var2 -> ; .)
    BOOL            reduce using rule 26 (var2 -> ; .)
    STRING          reduce using rule 26 (var2 -> ; .)
    CHAR            reduce using rule 26 (var2 -> ; .)
    VOID            reduce using rule 26 (var2 -> ; .)
    MAIN            reduce using rule 26 (var2 -> ; .)
    SET             reduce using rule 26 (var2 -> ; .)
    MAP             reduce using rule 26 (var2 -> ; .)
    READ            reduce using rule 26 (var2 -> ; .)
    PRINT           reduce using rule 26 (var2 -> ; .)
    ID              reduce using rule 26 (var2 -> ; .)
    RETURN          reduce using rule 26 (var2 -> ; .)
    IF              reduce using rule 26 (var2 -> ; .)
    WHILE           reduce using rule 26 (var2 -> ; .)
    }               reduce using rule 26 (var2 -> ; .)


state 46

    (123) main -> MAIN n_clear_scope { . vars_aux statement_aux }
    (125) vars_aux -> . vars
    (126) vars_aux -> . empty
    (21) vars -> . var vars
    (22) vars -> . var
    (131) empty -> .
    (23) var -> . datatype var1
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    READ            reduce using rule 131 (empty -> .)
    PRINT           reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    RETURN          reduce using rule 131 (empty -> .)
    IF              reduce using rule 131 (empty -> .)
    WHILE           reduce using rule 131 (empty -> .)
    }               reduce using rule 131 (empty -> .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! MAP             [ reduce using rule 131 (empty -> .) ]

    set_definition                 shift and go to state 18
    vars                           shift and go to state 55
    datatype                       shift and go to state 59
    map_definition                 shift and go to state 6
    vars_aux                       shift and go to state 56
    var                            shift and go to state 57
    empty                          shift and go to state 58

state 47

    (12) procA -> proc1 ) { . proc3 }
    (17) proc3 -> . var proc3
    (18) proc3 -> . proc4
    (23) var -> . datatype var1
    (19) proc4 -> . statement proc4
    (20) proc4 -> . empty
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (52) statement -> . statement1 ;
    (53) statement -> . statement2
    (131) empty -> .
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >
    (54) statement1 -> . assignment
    (55) statement1 -> . input
    (56) statement1 -> . output
    (57) statement1 -> . set_operation
    (58) statement1 -> . map_definition
    (59) statement1 -> . return
    (60) statement1 -> . map_assignment
    (61) statement1 -> . map_operation
    (62) statement1 -> . function_call
    (63) statement2 -> . condition
    (64) statement2 -> . while
    (27) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (37) input -> . READ ( ID input1 )
    (40) output -> . PRINT ( expression output1 )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )
    (48) return -> . RETURN expression
    (129) map_assignment -> . map_access ASSIGNATOR exp
    (130) map_operation -> . ID . OPERATION ( )
    (43) function_call -> . ID ( function_call1 )
    (30) condition -> . IF ( expression ) block condition1
    (33) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (28) assignment2 -> . ID
    (128) map_access -> . ID ( exp )

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    }               reduce using rule 131 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    ID              shift and go to state 80
    RETURN          shift and go to state 60
    IF              shift and go to state 82
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 63
    function_call                  shift and go to state 64
    proc4                          shift and go to state 67
    return                         shift and go to state 78
    proc3                          shift and go to state 68
    set_definition                 shift and go to state 18
    map_access                     shift and go to state 70
    assignment2                    shift and go to state 71
    statement                      shift and go to state 72
    var                            shift and go to state 73
    input                          shift and go to state 74
    empty                          shift and go to state 75
    statement2                     shift and go to state 69
    statement1                     shift and go to state 76
    assignment                     shift and go to state 77
    map_operation                  shift and go to state 79
    condition                      shift and go to state 81
    set_operation                  shift and go to state 83
    datatype                       shift and go to state 59
    map_assignment                 shift and go to state 62
    while                          shift and go to state 84
    output                         shift and go to state 85

state 48

    (15) proc2 -> , . datatype ID proc2
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 86
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 49

    (16) proc2 -> empty .

    )               reduce using rule 16 (proc2 -> empty .)


state 50

    (13) proc1 -> datatype ID proc2 .

    )               reduce using rule 13 (proc1 -> datatype ID proc2 .)


state 51

    (119) set_definition -> SET < datatype > .

    ID              reduce using rule 119 (set_definition -> SET < datatype > .)
    ,               reduce using rule 119 (set_definition -> SET < datatype > .)
    >               reduce using rule 119 (set_definition -> SET < datatype > .)


state 52

    (127) map_definition -> MAP < datatype , . datatype >
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 87
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 53

    (24) var1 -> ID , var1 .

    INT             reduce using rule 24 (var1 -> ID , var1 .)
    FLOAT           reduce using rule 24 (var1 -> ID , var1 .)
    BOOL            reduce using rule 24 (var1 -> ID , var1 .)
    STRING          reduce using rule 24 (var1 -> ID , var1 .)
    CHAR            reduce using rule 24 (var1 -> ID , var1 .)
    VOID            reduce using rule 24 (var1 -> ID , var1 .)
    MAIN            reduce using rule 24 (var1 -> ID , var1 .)
    SET             reduce using rule 24 (var1 -> ID , var1 .)
    MAP             reduce using rule 24 (var1 -> ID , var1 .)
    READ            reduce using rule 24 (var1 -> ID , var1 .)
    PRINT           reduce using rule 24 (var1 -> ID , var1 .)
    ID              reduce using rule 24 (var1 -> ID , var1 .)
    RETURN          reduce using rule 24 (var1 -> ID , var1 .)
    IF              reduce using rule 24 (var1 -> ID , var1 .)
    WHILE           reduce using rule 24 (var1 -> ID , var1 .)
    }               reduce using rule 24 (var1 -> ID , var1 .)


state 54

    (24) var1 -> ID . , var1
    (25) var1 -> ID . var2
    (26) var2 -> . ;

    ,               shift and go to state 44
    ;               shift and go to state 45

    var2                           shift and go to state 42

state 55

    (125) vars_aux -> vars .

    READ            reduce using rule 125 (vars_aux -> vars .)
    PRINT           reduce using rule 125 (vars_aux -> vars .)
    ID              reduce using rule 125 (vars_aux -> vars .)
    MAP             reduce using rule 125 (vars_aux -> vars .)
    RETURN          reduce using rule 125 (vars_aux -> vars .)
    IF              reduce using rule 125 (vars_aux -> vars .)
    WHILE           reduce using rule 125 (vars_aux -> vars .)
    }               reduce using rule 125 (vars_aux -> vars .)


state 56

    (123) main -> MAIN n_clear_scope { vars_aux . statement_aux }
    (121) statement_aux -> . statement statement_aux
    (122) statement_aux -> . empty
    (52) statement -> . statement1 ;
    (53) statement -> . statement2
    (131) empty -> .
    (54) statement1 -> . assignment
    (55) statement1 -> . input
    (56) statement1 -> . output
    (57) statement1 -> . set_operation
    (58) statement1 -> . map_definition
    (59) statement1 -> . return
    (60) statement1 -> . map_assignment
    (61) statement1 -> . map_operation
    (62) statement1 -> . function_call
    (63) statement2 -> . condition
    (64) statement2 -> . while
    (27) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (37) input -> . READ ( ID input1 )
    (40) output -> . PRINT ( expression output1 )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )
    (127) map_definition -> . MAP < datatype , datatype >
    (48) return -> . RETURN expression
    (129) map_assignment -> . map_access ASSIGNATOR exp
    (130) map_operation -> . ID . OPERATION ( )
    (43) function_call -> . ID ( function_call1 )
    (30) condition -> . IF ( expression ) block condition1
    (33) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (28) assignment2 -> . ID
    (128) map_access -> . ID ( exp )

    }               reduce using rule 131 (empty -> .)
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    ID              shift and go to state 80
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 82
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 88
    function_call                  shift and go to state 64
    statement_aux                  shift and go to state 89
    map_access                     shift and go to state 70
    assignment2                    shift and go to state 71
    statement                      shift and go to state 90
    input                          shift and go to state 74
    empty                          shift and go to state 91
    return                         shift and go to state 78
    statement2                     shift and go to state 69
    statement1                     shift and go to state 76
    assignment                     shift and go to state 77
    map_operation                  shift and go to state 79
    condition                      shift and go to state 81
    set_operation                  shift and go to state 83
    map_assignment                 shift and go to state 62
    while                          shift and go to state 84
    output                         shift and go to state 85

state 57

    (21) vars -> var . vars
    (22) vars -> var .
    (21) vars -> . var vars
    (22) vars -> . var
    (23) var -> . datatype var1
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    READ            reduce using rule 22 (vars -> var .)
    PRINT           reduce using rule 22 (vars -> var .)
    ID              reduce using rule 22 (vars -> var .)
    RETURN          reduce using rule 22 (vars -> var .)
    IF              reduce using rule 22 (vars -> var .)
    WHILE           reduce using rule 22 (vars -> var .)
    }               reduce using rule 22 (vars -> var .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! MAP             [ reduce using rule 22 (vars -> var .) ]

    vars                           shift and go to state 92
    set_definition                 shift and go to state 18
    datatype                       shift and go to state 59
    map_definition                 shift and go to state 6
    var                            shift and go to state 57

state 58

    (126) vars_aux -> empty .

    READ            reduce using rule 126 (vars_aux -> empty .)
    PRINT           reduce using rule 126 (vars_aux -> empty .)
    ID              reduce using rule 126 (vars_aux -> empty .)
    MAP             reduce using rule 126 (vars_aux -> empty .)
    RETURN          reduce using rule 126 (vars_aux -> empty .)
    IF              reduce using rule 126 (vars_aux -> empty .)
    WHILE           reduce using rule 126 (vars_aux -> empty .)
    }               reduce using rule 126 (vars_aux -> empty .)


state 59

    (23) var -> datatype . var1
    (24) var1 -> . ID , var1
    (25) var1 -> . ID var2

    ID              shift and go to state 54

    var1                           shift and go to state 34

state 60

    (48) return -> RETURN . expression
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 98
    empty                          shift and go to state 99

state 61

    (37) input -> READ . ( ID input1 )

    (               shift and go to state 100


state 62

    (60) statement1 -> map_assignment .

    ;               reduce using rule 60 (statement1 -> map_assignment .)


state 63

    (118) datatype -> map_definition .
    (58) statement1 -> map_definition .

    ID              reduce using rule 118 (datatype -> map_definition .)
    ;               reduce using rule 58 (statement1 -> map_definition .)


state 64

    (62) statement1 -> function_call .

    ;               reduce using rule 62 (statement1 -> function_call .)


state 65

    (33) while -> WHILE . n_while_1 ( expression ) n_while_2 block n_while_3
    (34) n_while_1 -> .

    (               reduce using rule 34 (n_while_1 -> .)

    n_while_1                      shift and go to state 101

state 66

    (40) output -> PRINT . ( expression output1 )

    (               shift and go to state 102


state 67

    (18) proc3 -> proc4 .

    }               reduce using rule 18 (proc3 -> proc4 .)


state 68

    (12) procA -> proc1 ) { proc3 . }

    }               shift and go to state 103


state 69

    (53) statement -> statement2 .

    READ            reduce using rule 53 (statement -> statement2 .)
    PRINT           reduce using rule 53 (statement -> statement2 .)
    ID              reduce using rule 53 (statement -> statement2 .)
    MAP             reduce using rule 53 (statement -> statement2 .)
    RETURN          reduce using rule 53 (statement -> statement2 .)
    IF              reduce using rule 53 (statement -> statement2 .)
    WHILE           reduce using rule 53 (statement -> statement2 .)
    }               reduce using rule 53 (statement -> statement2 .)


state 70

    (129) map_assignment -> map_access . ASSIGNATOR exp

    ASSIGNATOR      shift and go to state 104


state 71

    (27) assignment -> assignment2 . ASSIGNATOR n_quad_assign expression

    ASSIGNATOR      shift and go to state 105


state 72

    (19) proc4 -> statement . proc4
    (19) proc4 -> . statement proc4
    (20) proc4 -> . empty
    (52) statement -> . statement1 ;
    (53) statement -> . statement2
    (131) empty -> .
    (54) statement1 -> . assignment
    (55) statement1 -> . input
    (56) statement1 -> . output
    (57) statement1 -> . set_operation
    (58) statement1 -> . map_definition
    (59) statement1 -> . return
    (60) statement1 -> . map_assignment
    (61) statement1 -> . map_operation
    (62) statement1 -> . function_call
    (63) statement2 -> . condition
    (64) statement2 -> . while
    (27) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (37) input -> . READ ( ID input1 )
    (40) output -> . PRINT ( expression output1 )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )
    (127) map_definition -> . MAP < datatype , datatype >
    (48) return -> . RETURN expression
    (129) map_assignment -> . map_access ASSIGNATOR exp
    (130) map_operation -> . ID . OPERATION ( )
    (43) function_call -> . ID ( function_call1 )
    (30) condition -> . IF ( expression ) block condition1
    (33) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (28) assignment2 -> . ID
    (128) map_access -> . ID ( exp )

    }               reduce using rule 131 (empty -> .)
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    ID              shift and go to state 80
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 82
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 88
    function_call                  shift and go to state 64
    proc4                          shift and go to state 106
    map_access                     shift and go to state 70
    assignment2                    shift and go to state 71
    statement                      shift and go to state 72
    input                          shift and go to state 74
    empty                          shift and go to state 75
    return                         shift and go to state 78
    statement2                     shift and go to state 69
    statement1                     shift and go to state 76
    assignment                     shift and go to state 77
    map_operation                  shift and go to state 79
    condition                      shift and go to state 81
    set_operation                  shift and go to state 83
    map_assignment                 shift and go to state 62
    while                          shift and go to state 84
    output                         shift and go to state 85

state 73

    (17) proc3 -> var . proc3
    (17) proc3 -> . var proc3
    (18) proc3 -> . proc4
    (23) var -> . datatype var1
    (19) proc4 -> . statement proc4
    (20) proc4 -> . empty
    (112) datatype -> . INT
    (113) datatype -> . FLOAT
    (114) datatype -> . BOOL
    (115) datatype -> . STRING
    (116) datatype -> . CHAR
    (117) datatype -> . set_definition
    (118) datatype -> . map_definition
    (52) statement -> . statement1 ;
    (53) statement -> . statement2
    (131) empty -> .
    (119) set_definition -> . SET < datatype >
    (127) map_definition -> . MAP < datatype , datatype >
    (54) statement1 -> . assignment
    (55) statement1 -> . input
    (56) statement1 -> . output
    (57) statement1 -> . set_operation
    (58) statement1 -> . map_definition
    (59) statement1 -> . return
    (60) statement1 -> . map_assignment
    (61) statement1 -> . map_operation
    (62) statement1 -> . function_call
    (63) statement2 -> . condition
    (64) statement2 -> . while
    (27) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (37) input -> . READ ( ID input1 )
    (40) output -> . PRINT ( expression output1 )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )
    (48) return -> . RETURN expression
    (129) map_assignment -> . map_access ASSIGNATOR exp
    (130) map_operation -> . ID . OPERATION ( )
    (43) function_call -> . ID ( function_call1 )
    (30) condition -> . IF ( expression ) block condition1
    (33) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (28) assignment2 -> . ID
    (128) map_access -> . ID ( exp )

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    }               reduce using rule 131 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    ID              shift and go to state 80
    RETURN          shift and go to state 60
    IF              shift and go to state 82
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 63
    function_call                  shift and go to state 64
    proc4                          shift and go to state 67
    return                         shift and go to state 78
    proc3                          shift and go to state 107
    set_definition                 shift and go to state 18
    map_access                     shift and go to state 70
    assignment2                    shift and go to state 71
    statement                      shift and go to state 72
    var                            shift and go to state 73
    input                          shift and go to state 74
    empty                          shift and go to state 75
    statement2                     shift and go to state 69
    statement1                     shift and go to state 76
    assignment                     shift and go to state 77
    map_operation                  shift and go to state 79
    condition                      shift and go to state 81
    set_operation                  shift and go to state 83
    datatype                       shift and go to state 59
    map_assignment                 shift and go to state 62
    while                          shift and go to state 84
    output                         shift and go to state 85

state 74

    (55) statement1 -> input .

    ;               reduce using rule 55 (statement1 -> input .)


state 75

    (20) proc4 -> empty .

    }               reduce using rule 20 (proc4 -> empty .)


state 76

    (52) statement -> statement1 . ;

    ;               shift and go to state 108


state 77

    (54) statement1 -> assignment .

    ;               reduce using rule 54 (statement1 -> assignment .)


state 78

    (59) statement1 -> return .

    ;               reduce using rule 59 (statement1 -> return .)


state 79

    (61) statement1 -> map_operation .

    ;               reduce using rule 61 (statement1 -> map_operation .)


state 80

    (49) set_operation -> ID . . OPERATION ( set_operation1 )
    (130) map_operation -> ID . . OPERATION ( )
    (43) function_call -> ID . ( function_call1 )
    (28) assignment2 -> ID .
    (128) map_access -> ID . ( exp )

    .               shift and go to state 110
    (               shift and go to state 109
    ASSIGNATOR      reduce using rule 28 (assignment2 -> ID .)


state 81

    (63) statement2 -> condition .

    READ            reduce using rule 63 (statement2 -> condition .)
    PRINT           reduce using rule 63 (statement2 -> condition .)
    ID              reduce using rule 63 (statement2 -> condition .)
    MAP             reduce using rule 63 (statement2 -> condition .)
    RETURN          reduce using rule 63 (statement2 -> condition .)
    IF              reduce using rule 63 (statement2 -> condition .)
    WHILE           reduce using rule 63 (statement2 -> condition .)
    }               reduce using rule 63 (statement2 -> condition .)


state 82

    (30) condition -> IF . ( expression ) block condition1

    (               shift and go to state 111


state 83

    (57) statement1 -> set_operation .

    ;               reduce using rule 57 (statement1 -> set_operation .)


state 84

    (64) statement2 -> while .

    READ            reduce using rule 64 (statement2 -> while .)
    PRINT           reduce using rule 64 (statement2 -> while .)
    ID              reduce using rule 64 (statement2 -> while .)
    MAP             reduce using rule 64 (statement2 -> while .)
    RETURN          reduce using rule 64 (statement2 -> while .)
    IF              reduce using rule 64 (statement2 -> while .)
    WHILE           reduce using rule 64 (statement2 -> while .)
    }               reduce using rule 64 (statement2 -> while .)


state 85

    (56) statement1 -> output .

    ;               reduce using rule 56 (statement1 -> output .)


state 86

    (15) proc2 -> , datatype . ID proc2

    ID              shift and go to state 112


state 87

    (127) map_definition -> MAP < datatype , datatype . >

    >               shift and go to state 113


state 88

    (58) statement1 -> map_definition .

    ;               reduce using rule 58 (statement1 -> map_definition .)


state 89

    (123) main -> MAIN n_clear_scope { vars_aux statement_aux . }

    }               shift and go to state 114


state 90

    (121) statement_aux -> statement . statement_aux
    (121) statement_aux -> . statement statement_aux
    (122) statement_aux -> . empty
    (52) statement -> . statement1 ;
    (53) statement -> . statement2
    (131) empty -> .
    (54) statement1 -> . assignment
    (55) statement1 -> . input
    (56) statement1 -> . output
    (57) statement1 -> . set_operation
    (58) statement1 -> . map_definition
    (59) statement1 -> . return
    (60) statement1 -> . map_assignment
    (61) statement1 -> . map_operation
    (62) statement1 -> . function_call
    (63) statement2 -> . condition
    (64) statement2 -> . while
    (27) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (37) input -> . READ ( ID input1 )
    (40) output -> . PRINT ( expression output1 )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )
    (127) map_definition -> . MAP < datatype , datatype >
    (48) return -> . RETURN expression
    (129) map_assignment -> . map_access ASSIGNATOR exp
    (130) map_operation -> . ID . OPERATION ( )
    (43) function_call -> . ID ( function_call1 )
    (30) condition -> . IF ( expression ) block condition1
    (33) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (28) assignment2 -> . ID
    (128) map_access -> . ID ( exp )

    }               reduce using rule 131 (empty -> .)
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    ID              shift and go to state 80
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 82
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 88
    function_call                  shift and go to state 64
    statement_aux                  shift and go to state 115
    map_access                     shift and go to state 70
    assignment2                    shift and go to state 71
    statement                      shift and go to state 90
    input                          shift and go to state 74
    empty                          shift and go to state 91
    return                         shift and go to state 78
    statement2                     shift and go to state 69
    statement1                     shift and go to state 76
    assignment                     shift and go to state 77
    map_operation                  shift and go to state 79
    condition                      shift and go to state 81
    set_operation                  shift and go to state 83
    map_assignment                 shift and go to state 62
    while                          shift and go to state 84
    output                         shift and go to state 85

state 91

    (122) statement_aux -> empty .

    }               reduce using rule 122 (statement_aux -> empty .)


state 92

    (21) vars -> var vars .

    READ            reduce using rule 21 (vars -> var vars .)
    PRINT           reduce using rule 21 (vars -> var vars .)
    ID              reduce using rule 21 (vars -> var vars .)
    MAP             reduce using rule 21 (vars -> var vars .)
    RETURN          reduce using rule 21 (vars -> var vars .)
    IF              reduce using rule 21 (vars -> var vars .)
    WHILE           reduce using rule 21 (vars -> var vars .)
    }               reduce using rule 21 (vars -> var vars .)


state 93

    (87) term -> term_not . factor n_quad_muldiv term2
    (95) factor -> . ( n_push_false_bottom expression ) n_pop_false_bottom
    (96) factor -> . varcte
    (99) varcte -> . ID empty
    (100) varcte -> . varcte1
    (101) varcte1 -> . CTE_INT
    (102) varcte1 -> . CTE_FLOAT
    (103) varcte1 -> . CTE_BOOL
    (104) varcte1 -> . CTE_STRING
    (105) varcte1 -> . CTE_CHAR
    (106) varcte1 -> . function_call
    (107) varcte1 -> . map_access
    (108) varcte1 -> . map_operation
    (109) varcte1 -> . set_operation
    (43) function_call -> . ID ( function_call1 )
    (128) map_access -> . ID ( exp )
    (130) map_operation -> . ID . OPERATION ( )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )

    (               shift and go to state 119
    ID              shift and go to state 124
    CTE_INT         shift and go to state 123
    CTE_FLOAT       shift and go to state 126
    CTE_BOOL        shift and go to state 127
    CTE_STRING      shift and go to state 128
    CTE_CHAR        shift and go to state 121

    map_operation                  shift and go to state 122
    set_operation                  shift and go to state 125
    map_access                     shift and go to state 129
    function_call                  shift and go to state 116
    factor                         shift and go to state 120
    varcte1                        shift and go to state 117
    varcte                         shift and go to state 118

state 94

    (80) exp -> term . exp2
    (85) exp2 -> . addsub term n_quad_addsub exp2
    (86) exp2 -> . empty
    (81) addsub -> . +
    (82) addsub -> . -
    (131) empty -> .

    +               shift and go to state 131
    -               shift and go to state 132
    <               reduce using rule 131 (empty -> .)
    >               reduce using rule 131 (empty -> .)
    NOT_EQ          reduce using rule 131 (empty -> .)
    EQ              reduce using rule 131 (empty -> .)
    LEQ             reduce using rule 131 (empty -> .)
    GEQ             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)

    exp2                           shift and go to state 130
    addsub                         shift and go to state 133
    empty                          shift and go to state 134

state 95

    (73) expression -> exp0 . expression2
    (74) expression2 -> . logop exp0 n_quad_logop expression2
    (75) expression2 -> . empty
    (71) logop -> . OR
    (72) logop -> . AND
    (131) empty -> .

    OR              shift and go to state 138
    AND             shift and go to state 135
    ;               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)

    empty                          shift and go to state 139
    expression2                    shift and go to state 137
    logop                          shift and go to state 136

state 96

    (93) term_not -> ! .

    (               reduce using rule 93 (term_not -> ! .)
    ID              reduce using rule 93 (term_not -> ! .)
    CTE_INT         reduce using rule 93 (term_not -> ! .)
    CTE_FLOAT       reduce using rule 93 (term_not -> ! .)
    CTE_BOOL        reduce using rule 93 (term_not -> ! .)
    CTE_STRING      reduce using rule 93 (term_not -> ! .)
    CTE_CHAR        reduce using rule 93 (term_not -> ! .)


state 97

    (77) exp0 -> exp . exp02
    (78) exp02 -> . relop exp
    (79) exp02 -> . empty
    (65) relop -> . <
    (66) relop -> . >
    (67) relop -> . NOT_EQ
    (68) relop -> . EQ
    (69) relop -> . LEQ
    (70) relop -> . GEQ
    (131) empty -> .

    <               shift and go to state 146
    >               shift and go to state 148
    NOT_EQ          shift and go to state 142
    EQ              shift and go to state 145
    LEQ             shift and go to state 143
    GEQ             shift and go to state 140
    OR              reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)

    exp02                          shift and go to state 144
    empty                          shift and go to state 147
    relop                          shift and go to state 141

state 98

    (48) return -> RETURN expression .

    ;               reduce using rule 48 (return -> RETURN expression .)


state 99

    (94) term_not -> empty .

    (               reduce using rule 94 (term_not -> empty .)
    ID              reduce using rule 94 (term_not -> empty .)
    CTE_INT         reduce using rule 94 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 94 (term_not -> empty .)
    CTE_BOOL        reduce using rule 94 (term_not -> empty .)
    CTE_STRING      reduce using rule 94 (term_not -> empty .)
    CTE_CHAR        reduce using rule 94 (term_not -> empty .)


state 100

    (37) input -> READ ( . ID input1 )

    ID              shift and go to state 149


state 101

    (33) while -> WHILE n_while_1 . ( expression ) n_while_2 block n_while_3

    (               shift and go to state 150


state 102

    (40) output -> PRINT ( . expression output1 )
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 151
    empty                          shift and go to state 99

state 103

    (12) procA -> proc1 ) { proc3 } .

    VOID            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    MAIN            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    INT             reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    FLOAT           reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    BOOL            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    STRING          reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    CHAR            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    SET             reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    MAP             reduce using rule 12 (procA -> proc1 ) { proc3 } .)


state 104

    (129) map_assignment -> map_access ASSIGNATOR . exp
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp                            shift and go to state 152
    empty                          shift and go to state 99

state 105

    (27) assignment -> assignment2 ASSIGNATOR . n_quad_assign expression
    (29) n_quad_assign -> .

    !               reduce using rule 29 (n_quad_assign -> .)
    (               reduce using rule 29 (n_quad_assign -> .)
    ID              reduce using rule 29 (n_quad_assign -> .)
    CTE_INT         reduce using rule 29 (n_quad_assign -> .)
    CTE_FLOAT       reduce using rule 29 (n_quad_assign -> .)
    CTE_BOOL        reduce using rule 29 (n_quad_assign -> .)
    CTE_STRING      reduce using rule 29 (n_quad_assign -> .)
    CTE_CHAR        reduce using rule 29 (n_quad_assign -> .)

    n_quad_assign                  shift and go to state 153

state 106

    (19) proc4 -> statement proc4 .

    }               reduce using rule 19 (proc4 -> statement proc4 .)


state 107

    (17) proc3 -> var proc3 .

    }               reduce using rule 17 (proc3 -> var proc3 .)


state 108

    (52) statement -> statement1 ; .

    READ            reduce using rule 52 (statement -> statement1 ; .)
    PRINT           reduce using rule 52 (statement -> statement1 ; .)
    ID              reduce using rule 52 (statement -> statement1 ; .)
    MAP             reduce using rule 52 (statement -> statement1 ; .)
    RETURN          reduce using rule 52 (statement -> statement1 ; .)
    IF              reduce using rule 52 (statement -> statement1 ; .)
    WHILE           reduce using rule 52 (statement -> statement1 ; .)
    }               reduce using rule 52 (statement -> statement1 ; .)


state 109

    (43) function_call -> ID ( . function_call1 )
    (128) map_access -> ID ( . exp )
    (44) function_call1 -> . empty
    (45) function_call1 -> . function_call2
    (80) exp -> . term exp2
    (131) empty -> .
    (46) function_call2 -> . expression , function_call2
    (47) function_call2 -> . expression
    (87) term -> . term_not factor n_quad_muldiv term2
    (73) expression -> . exp0 expression2
    (93) term_not -> . !
    (94) term_not -> . empty
    (77) exp0 -> . exp exp02

    )               reduce using rule 131 (empty -> .)
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)
    !               shift and go to state 96

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    function_call1                 shift and go to state 154
    exp0                           shift and go to state 95
    function_call2                 shift and go to state 155
    exp                            shift and go to state 156
    expression                     shift and go to state 157
    empty                          shift and go to state 158

state 110

    (49) set_operation -> ID . . OPERATION ( set_operation1 )
    (130) map_operation -> ID . . OPERATION ( )

    OPERATION       shift and go to state 159


state 111

    (30) condition -> IF ( . expression ) block condition1
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    empty                          shift and go to state 99
    exp                            shift and go to state 97
    expression                     shift and go to state 160

state 112

    (15) proc2 -> , datatype ID . proc2
    (15) proc2 -> . , datatype ID proc2
    (16) proc2 -> . empty
    (131) empty -> .

    ,               shift and go to state 48
    )               reduce using rule 131 (empty -> .)

    empty                          shift and go to state 49
    proc2                          shift and go to state 161

state 113

    (127) map_definition -> MAP < datatype , datatype > .

    ID              reduce using rule 127 (map_definition -> MAP < datatype , datatype > .)
    ,               reduce using rule 127 (map_definition -> MAP < datatype , datatype > .)
    ;               reduce using rule 127 (map_definition -> MAP < datatype , datatype > .)
    >               reduce using rule 127 (map_definition -> MAP < datatype , datatype > .)


state 114

    (123) main -> MAIN n_clear_scope { vars_aux statement_aux } .

    $end            reduce using rule 123 (main -> MAIN n_clear_scope { vars_aux statement_aux } .)


state 115

    (121) statement_aux -> statement statement_aux .

    }               reduce using rule 121 (statement_aux -> statement statement_aux .)


state 116

    (106) varcte1 -> function_call .

    *               reduce using rule 106 (varcte1 -> function_call .)
    /               reduce using rule 106 (varcte1 -> function_call .)
    +               reduce using rule 106 (varcte1 -> function_call .)
    -               reduce using rule 106 (varcte1 -> function_call .)
    <               reduce using rule 106 (varcte1 -> function_call .)
    >               reduce using rule 106 (varcte1 -> function_call .)
    NOT_EQ          reduce using rule 106 (varcte1 -> function_call .)
    EQ              reduce using rule 106 (varcte1 -> function_call .)
    LEQ             reduce using rule 106 (varcte1 -> function_call .)
    GEQ             reduce using rule 106 (varcte1 -> function_call .)
    OR              reduce using rule 106 (varcte1 -> function_call .)
    AND             reduce using rule 106 (varcte1 -> function_call .)
    ;               reduce using rule 106 (varcte1 -> function_call .)
    ,               reduce using rule 106 (varcte1 -> function_call .)
    )               reduce using rule 106 (varcte1 -> function_call .)


state 117

    (100) varcte -> varcte1 .

    *               reduce using rule 100 (varcte -> varcte1 .)
    /               reduce using rule 100 (varcte -> varcte1 .)
    +               reduce using rule 100 (varcte -> varcte1 .)
    -               reduce using rule 100 (varcte -> varcte1 .)
    <               reduce using rule 100 (varcte -> varcte1 .)
    >               reduce using rule 100 (varcte -> varcte1 .)
    NOT_EQ          reduce using rule 100 (varcte -> varcte1 .)
    EQ              reduce using rule 100 (varcte -> varcte1 .)
    LEQ             reduce using rule 100 (varcte -> varcte1 .)
    GEQ             reduce using rule 100 (varcte -> varcte1 .)
    OR              reduce using rule 100 (varcte -> varcte1 .)
    AND             reduce using rule 100 (varcte -> varcte1 .)
    ;               reduce using rule 100 (varcte -> varcte1 .)
    ,               reduce using rule 100 (varcte -> varcte1 .)
    )               reduce using rule 100 (varcte -> varcte1 .)


state 118

    (96) factor -> varcte .

    *               reduce using rule 96 (factor -> varcte .)
    /               reduce using rule 96 (factor -> varcte .)
    +               reduce using rule 96 (factor -> varcte .)
    -               reduce using rule 96 (factor -> varcte .)
    <               reduce using rule 96 (factor -> varcte .)
    >               reduce using rule 96 (factor -> varcte .)
    NOT_EQ          reduce using rule 96 (factor -> varcte .)
    EQ              reduce using rule 96 (factor -> varcte .)
    LEQ             reduce using rule 96 (factor -> varcte .)
    GEQ             reduce using rule 96 (factor -> varcte .)
    OR              reduce using rule 96 (factor -> varcte .)
    AND             reduce using rule 96 (factor -> varcte .)
    ;               reduce using rule 96 (factor -> varcte .)
    ,               reduce using rule 96 (factor -> varcte .)
    )               reduce using rule 96 (factor -> varcte .)


state 119

    (95) factor -> ( . n_push_false_bottom expression ) n_pop_false_bottom
    (97) n_push_false_bottom -> .

    !               reduce using rule 97 (n_push_false_bottom -> .)
    (               reduce using rule 97 (n_push_false_bottom -> .)
    ID              reduce using rule 97 (n_push_false_bottom -> .)
    CTE_INT         reduce using rule 97 (n_push_false_bottom -> .)
    CTE_FLOAT       reduce using rule 97 (n_push_false_bottom -> .)
    CTE_BOOL        reduce using rule 97 (n_push_false_bottom -> .)
    CTE_STRING      reduce using rule 97 (n_push_false_bottom -> .)
    CTE_CHAR        reduce using rule 97 (n_push_false_bottom -> .)

    n_push_false_bottom            shift and go to state 162

state 120

    (87) term -> term_not factor . n_quad_muldiv term2
    (88) n_quad_muldiv -> .

    *               reduce using rule 88 (n_quad_muldiv -> .)
    /               reduce using rule 88 (n_quad_muldiv -> .)
    +               reduce using rule 88 (n_quad_muldiv -> .)
    -               reduce using rule 88 (n_quad_muldiv -> .)
    <               reduce using rule 88 (n_quad_muldiv -> .)
    >               reduce using rule 88 (n_quad_muldiv -> .)
    NOT_EQ          reduce using rule 88 (n_quad_muldiv -> .)
    EQ              reduce using rule 88 (n_quad_muldiv -> .)
    LEQ             reduce using rule 88 (n_quad_muldiv -> .)
    GEQ             reduce using rule 88 (n_quad_muldiv -> .)
    OR              reduce using rule 88 (n_quad_muldiv -> .)
    AND             reduce using rule 88 (n_quad_muldiv -> .)
    ;               reduce using rule 88 (n_quad_muldiv -> .)
    ,               reduce using rule 88 (n_quad_muldiv -> .)
    )               reduce using rule 88 (n_quad_muldiv -> .)

    n_quad_muldiv                  shift and go to state 163

state 121

    (105) varcte1 -> CTE_CHAR .

    *               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    /               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    +               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    -               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    <               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    >               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    NOT_EQ          reduce using rule 105 (varcte1 -> CTE_CHAR .)
    EQ              reduce using rule 105 (varcte1 -> CTE_CHAR .)
    LEQ             reduce using rule 105 (varcte1 -> CTE_CHAR .)
    GEQ             reduce using rule 105 (varcte1 -> CTE_CHAR .)
    OR              reduce using rule 105 (varcte1 -> CTE_CHAR .)
    AND             reduce using rule 105 (varcte1 -> CTE_CHAR .)
    ;               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    ,               reduce using rule 105 (varcte1 -> CTE_CHAR .)
    )               reduce using rule 105 (varcte1 -> CTE_CHAR .)


state 122

    (108) varcte1 -> map_operation .

    *               reduce using rule 108 (varcte1 -> map_operation .)
    /               reduce using rule 108 (varcte1 -> map_operation .)
    +               reduce using rule 108 (varcte1 -> map_operation .)
    -               reduce using rule 108 (varcte1 -> map_operation .)
    <               reduce using rule 108 (varcte1 -> map_operation .)
    >               reduce using rule 108 (varcte1 -> map_operation .)
    NOT_EQ          reduce using rule 108 (varcte1 -> map_operation .)
    EQ              reduce using rule 108 (varcte1 -> map_operation .)
    LEQ             reduce using rule 108 (varcte1 -> map_operation .)
    GEQ             reduce using rule 108 (varcte1 -> map_operation .)
    OR              reduce using rule 108 (varcte1 -> map_operation .)
    AND             reduce using rule 108 (varcte1 -> map_operation .)
    ;               reduce using rule 108 (varcte1 -> map_operation .)
    ,               reduce using rule 108 (varcte1 -> map_operation .)
    )               reduce using rule 108 (varcte1 -> map_operation .)


state 123

    (101) varcte1 -> CTE_INT .

    *               reduce using rule 101 (varcte1 -> CTE_INT .)
    /               reduce using rule 101 (varcte1 -> CTE_INT .)
    +               reduce using rule 101 (varcte1 -> CTE_INT .)
    -               reduce using rule 101 (varcte1 -> CTE_INT .)
    <               reduce using rule 101 (varcte1 -> CTE_INT .)
    >               reduce using rule 101 (varcte1 -> CTE_INT .)
    NOT_EQ          reduce using rule 101 (varcte1 -> CTE_INT .)
    EQ              reduce using rule 101 (varcte1 -> CTE_INT .)
    LEQ             reduce using rule 101 (varcte1 -> CTE_INT .)
    GEQ             reduce using rule 101 (varcte1 -> CTE_INT .)
    OR              reduce using rule 101 (varcte1 -> CTE_INT .)
    AND             reduce using rule 101 (varcte1 -> CTE_INT .)
    ;               reduce using rule 101 (varcte1 -> CTE_INT .)
    ,               reduce using rule 101 (varcte1 -> CTE_INT .)
    )               reduce using rule 101 (varcte1 -> CTE_INT .)


state 124

    (99) varcte -> ID . empty
    (43) function_call -> ID . ( function_call1 )
    (128) map_access -> ID . ( exp )
    (130) map_operation -> ID . . OPERATION ( )
    (49) set_operation -> ID . . OPERATION ( set_operation1 )
    (131) empty -> .

    (               shift and go to state 109
    .               shift and go to state 164
    *               reduce using rule 131 (empty -> .)
    /               reduce using rule 131 (empty -> .)
    +               reduce using rule 131 (empty -> .)
    -               reduce using rule 131 (empty -> .)
    <               reduce using rule 131 (empty -> .)
    >               reduce using rule 131 (empty -> .)
    NOT_EQ          reduce using rule 131 (empty -> .)
    EQ              reduce using rule 131 (empty -> .)
    LEQ             reduce using rule 131 (empty -> .)
    GEQ             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)

    empty                          shift and go to state 165

state 125

    (109) varcte1 -> set_operation .

    *               reduce using rule 109 (varcte1 -> set_operation .)
    /               reduce using rule 109 (varcte1 -> set_operation .)
    +               reduce using rule 109 (varcte1 -> set_operation .)
    -               reduce using rule 109 (varcte1 -> set_operation .)
    <               reduce using rule 109 (varcte1 -> set_operation .)
    >               reduce using rule 109 (varcte1 -> set_operation .)
    NOT_EQ          reduce using rule 109 (varcte1 -> set_operation .)
    EQ              reduce using rule 109 (varcte1 -> set_operation .)
    LEQ             reduce using rule 109 (varcte1 -> set_operation .)
    GEQ             reduce using rule 109 (varcte1 -> set_operation .)
    OR              reduce using rule 109 (varcte1 -> set_operation .)
    AND             reduce using rule 109 (varcte1 -> set_operation .)
    ;               reduce using rule 109 (varcte1 -> set_operation .)
    ,               reduce using rule 109 (varcte1 -> set_operation .)
    )               reduce using rule 109 (varcte1 -> set_operation .)


state 126

    (102) varcte1 -> CTE_FLOAT .

    *               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    /               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    +               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    -               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    <               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    >               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    NOT_EQ          reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    EQ              reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    LEQ             reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    GEQ             reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    OR              reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    AND             reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    ;               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    ,               reduce using rule 102 (varcte1 -> CTE_FLOAT .)
    )               reduce using rule 102 (varcte1 -> CTE_FLOAT .)


state 127

    (103) varcte1 -> CTE_BOOL .

    *               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    /               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    +               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    -               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    <               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    >               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    NOT_EQ          reduce using rule 103 (varcte1 -> CTE_BOOL .)
    EQ              reduce using rule 103 (varcte1 -> CTE_BOOL .)
    LEQ             reduce using rule 103 (varcte1 -> CTE_BOOL .)
    GEQ             reduce using rule 103 (varcte1 -> CTE_BOOL .)
    OR              reduce using rule 103 (varcte1 -> CTE_BOOL .)
    AND             reduce using rule 103 (varcte1 -> CTE_BOOL .)
    ;               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    ,               reduce using rule 103 (varcte1 -> CTE_BOOL .)
    )               reduce using rule 103 (varcte1 -> CTE_BOOL .)


state 128

    (104) varcte1 -> CTE_STRING .

    *               reduce using rule 104 (varcte1 -> CTE_STRING .)
    /               reduce using rule 104 (varcte1 -> CTE_STRING .)
    +               reduce using rule 104 (varcte1 -> CTE_STRING .)
    -               reduce using rule 104 (varcte1 -> CTE_STRING .)
    <               reduce using rule 104 (varcte1 -> CTE_STRING .)
    >               reduce using rule 104 (varcte1 -> CTE_STRING .)
    NOT_EQ          reduce using rule 104 (varcte1 -> CTE_STRING .)
    EQ              reduce using rule 104 (varcte1 -> CTE_STRING .)
    LEQ             reduce using rule 104 (varcte1 -> CTE_STRING .)
    GEQ             reduce using rule 104 (varcte1 -> CTE_STRING .)
    OR              reduce using rule 104 (varcte1 -> CTE_STRING .)
    AND             reduce using rule 104 (varcte1 -> CTE_STRING .)
    ;               reduce using rule 104 (varcte1 -> CTE_STRING .)
    ,               reduce using rule 104 (varcte1 -> CTE_STRING .)
    )               reduce using rule 104 (varcte1 -> CTE_STRING .)


state 129

    (107) varcte1 -> map_access .

    *               reduce using rule 107 (varcte1 -> map_access .)
    /               reduce using rule 107 (varcte1 -> map_access .)
    +               reduce using rule 107 (varcte1 -> map_access .)
    -               reduce using rule 107 (varcte1 -> map_access .)
    <               reduce using rule 107 (varcte1 -> map_access .)
    >               reduce using rule 107 (varcte1 -> map_access .)
    NOT_EQ          reduce using rule 107 (varcte1 -> map_access .)
    EQ              reduce using rule 107 (varcte1 -> map_access .)
    LEQ             reduce using rule 107 (varcte1 -> map_access .)
    GEQ             reduce using rule 107 (varcte1 -> map_access .)
    OR              reduce using rule 107 (varcte1 -> map_access .)
    AND             reduce using rule 107 (varcte1 -> map_access .)
    ;               reduce using rule 107 (varcte1 -> map_access .)
    ,               reduce using rule 107 (varcte1 -> map_access .)
    )               reduce using rule 107 (varcte1 -> map_access .)


state 130

    (80) exp -> term exp2 .

    )               reduce using rule 80 (exp -> term exp2 .)
    <               reduce using rule 80 (exp -> term exp2 .)
    >               reduce using rule 80 (exp -> term exp2 .)
    NOT_EQ          reduce using rule 80 (exp -> term exp2 .)
    EQ              reduce using rule 80 (exp -> term exp2 .)
    LEQ             reduce using rule 80 (exp -> term exp2 .)
    GEQ             reduce using rule 80 (exp -> term exp2 .)
    OR              reduce using rule 80 (exp -> term exp2 .)
    AND             reduce using rule 80 (exp -> term exp2 .)
    ,               reduce using rule 80 (exp -> term exp2 .)
    ;               reduce using rule 80 (exp -> term exp2 .)


state 131

    (81) addsub -> + .

    !               reduce using rule 81 (addsub -> + .)
    (               reduce using rule 81 (addsub -> + .)
    ID              reduce using rule 81 (addsub -> + .)
    CTE_INT         reduce using rule 81 (addsub -> + .)
    CTE_FLOAT       reduce using rule 81 (addsub -> + .)
    CTE_BOOL        reduce using rule 81 (addsub -> + .)
    CTE_STRING      reduce using rule 81 (addsub -> + .)
    CTE_CHAR        reduce using rule 81 (addsub -> + .)


state 132

    (82) addsub -> - .

    !               reduce using rule 82 (addsub -> - .)
    (               reduce using rule 82 (addsub -> - .)
    ID              reduce using rule 82 (addsub -> - .)
    CTE_INT         reduce using rule 82 (addsub -> - .)
    CTE_FLOAT       reduce using rule 82 (addsub -> - .)
    CTE_BOOL        reduce using rule 82 (addsub -> - .)
    CTE_STRING      reduce using rule 82 (addsub -> - .)
    CTE_CHAR        reduce using rule 82 (addsub -> - .)


state 133

    (85) exp2 -> addsub . term n_quad_addsub exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 166
    empty                          shift and go to state 99

state 134

    (86) exp2 -> empty .

    <               reduce using rule 86 (exp2 -> empty .)
    >               reduce using rule 86 (exp2 -> empty .)
    NOT_EQ          reduce using rule 86 (exp2 -> empty .)
    EQ              reduce using rule 86 (exp2 -> empty .)
    LEQ             reduce using rule 86 (exp2 -> empty .)
    GEQ             reduce using rule 86 (exp2 -> empty .)
    OR              reduce using rule 86 (exp2 -> empty .)
    AND             reduce using rule 86 (exp2 -> empty .)
    ;               reduce using rule 86 (exp2 -> empty .)
    ,               reduce using rule 86 (exp2 -> empty .)
    )               reduce using rule 86 (exp2 -> empty .)


state 135

    (72) logop -> AND .

    !               reduce using rule 72 (logop -> AND .)
    (               reduce using rule 72 (logop -> AND .)
    ID              reduce using rule 72 (logop -> AND .)
    CTE_INT         reduce using rule 72 (logop -> AND .)
    CTE_FLOAT       reduce using rule 72 (logop -> AND .)
    CTE_BOOL        reduce using rule 72 (logop -> AND .)
    CTE_STRING      reduce using rule 72 (logop -> AND .)
    CTE_CHAR        reduce using rule 72 (logop -> AND .)


state 136

    (74) expression2 -> logop . exp0 n_quad_logop expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    exp0                           shift and go to state 167
    term                           shift and go to state 94
    exp                            shift and go to state 97
    empty                          shift and go to state 99

state 137

    (73) expression -> exp0 expression2 .

    )               reduce using rule 73 (expression -> exp0 expression2 .)
    ;               reduce using rule 73 (expression -> exp0 expression2 .)
    ,               reduce using rule 73 (expression -> exp0 expression2 .)


state 138

    (71) logop -> OR .

    !               reduce using rule 71 (logop -> OR .)
    (               reduce using rule 71 (logop -> OR .)
    ID              reduce using rule 71 (logop -> OR .)
    CTE_INT         reduce using rule 71 (logop -> OR .)
    CTE_FLOAT       reduce using rule 71 (logop -> OR .)
    CTE_BOOL        reduce using rule 71 (logop -> OR .)
    CTE_STRING      reduce using rule 71 (logop -> OR .)
    CTE_CHAR        reduce using rule 71 (logop -> OR .)


state 139

    (75) expression2 -> empty .

    ;               reduce using rule 75 (expression2 -> empty .)
    ,               reduce using rule 75 (expression2 -> empty .)
    )               reduce using rule 75 (expression2 -> empty .)


state 140

    (70) relop -> GEQ .

    !               reduce using rule 70 (relop -> GEQ .)
    (               reduce using rule 70 (relop -> GEQ .)
    ID              reduce using rule 70 (relop -> GEQ .)
    CTE_INT         reduce using rule 70 (relop -> GEQ .)
    CTE_FLOAT       reduce using rule 70 (relop -> GEQ .)
    CTE_BOOL        reduce using rule 70 (relop -> GEQ .)
    CTE_STRING      reduce using rule 70 (relop -> GEQ .)
    CTE_CHAR        reduce using rule 70 (relop -> GEQ .)


state 141

    (78) exp02 -> relop . exp
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp                            shift and go to state 168
    empty                          shift and go to state 99

state 142

    (67) relop -> NOT_EQ .

    !               reduce using rule 67 (relop -> NOT_EQ .)
    (               reduce using rule 67 (relop -> NOT_EQ .)
    ID              reduce using rule 67 (relop -> NOT_EQ .)
    CTE_INT         reduce using rule 67 (relop -> NOT_EQ .)
    CTE_FLOAT       reduce using rule 67 (relop -> NOT_EQ .)
    CTE_BOOL        reduce using rule 67 (relop -> NOT_EQ .)
    CTE_STRING      reduce using rule 67 (relop -> NOT_EQ .)
    CTE_CHAR        reduce using rule 67 (relop -> NOT_EQ .)


state 143

    (69) relop -> LEQ .

    !               reduce using rule 69 (relop -> LEQ .)
    (               reduce using rule 69 (relop -> LEQ .)
    ID              reduce using rule 69 (relop -> LEQ .)
    CTE_INT         reduce using rule 69 (relop -> LEQ .)
    CTE_FLOAT       reduce using rule 69 (relop -> LEQ .)
    CTE_BOOL        reduce using rule 69 (relop -> LEQ .)
    CTE_STRING      reduce using rule 69 (relop -> LEQ .)
    CTE_CHAR        reduce using rule 69 (relop -> LEQ .)


state 144

    (77) exp0 -> exp exp02 .

    OR              reduce using rule 77 (exp0 -> exp exp02 .)
    AND             reduce using rule 77 (exp0 -> exp exp02 .)
    )               reduce using rule 77 (exp0 -> exp exp02 .)
    ;               reduce using rule 77 (exp0 -> exp exp02 .)
    ,               reduce using rule 77 (exp0 -> exp exp02 .)


state 145

    (68) relop -> EQ .

    !               reduce using rule 68 (relop -> EQ .)
    (               reduce using rule 68 (relop -> EQ .)
    ID              reduce using rule 68 (relop -> EQ .)
    CTE_INT         reduce using rule 68 (relop -> EQ .)
    CTE_FLOAT       reduce using rule 68 (relop -> EQ .)
    CTE_BOOL        reduce using rule 68 (relop -> EQ .)
    CTE_STRING      reduce using rule 68 (relop -> EQ .)
    CTE_CHAR        reduce using rule 68 (relop -> EQ .)


state 146

    (65) relop -> < .

    !               reduce using rule 65 (relop -> < .)
    (               reduce using rule 65 (relop -> < .)
    ID              reduce using rule 65 (relop -> < .)
    CTE_INT         reduce using rule 65 (relop -> < .)
    CTE_FLOAT       reduce using rule 65 (relop -> < .)
    CTE_BOOL        reduce using rule 65 (relop -> < .)
    CTE_STRING      reduce using rule 65 (relop -> < .)
    CTE_CHAR        reduce using rule 65 (relop -> < .)


state 147

    (79) exp02 -> empty .

    OR              reduce using rule 79 (exp02 -> empty .)
    AND             reduce using rule 79 (exp02 -> empty .)
    ,               reduce using rule 79 (exp02 -> empty .)
    )               reduce using rule 79 (exp02 -> empty .)
    ;               reduce using rule 79 (exp02 -> empty .)


state 148

    (66) relop -> > .

    !               reduce using rule 66 (relop -> > .)
    (               reduce using rule 66 (relop -> > .)
    ID              reduce using rule 66 (relop -> > .)
    CTE_INT         reduce using rule 66 (relop -> > .)
    CTE_FLOAT       reduce using rule 66 (relop -> > .)
    CTE_BOOL        reduce using rule 66 (relop -> > .)
    CTE_STRING      reduce using rule 66 (relop -> > .)
    CTE_CHAR        reduce using rule 66 (relop -> > .)


state 149

    (37) input -> READ ( ID . input1 )
    (38) input1 -> . , ID input1
    (39) input1 -> . empty
    (131) empty -> .

    ,               shift and go to state 170
    )               reduce using rule 131 (empty -> .)

    input1                         shift and go to state 169
    empty                          shift and go to state 171

state 150

    (33) while -> WHILE n_while_1 ( . expression ) n_while_2 block n_while_3
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp                            shift and go to state 97
    exp0                           shift and go to state 95
    empty                          shift and go to state 99
    expression                     shift and go to state 172

state 151

    (40) output -> PRINT ( expression . output1 )
    (41) output1 -> . , expression output1
    (42) output1 -> . empty
    (131) empty -> .

    ,               shift and go to state 174
    )               reduce using rule 131 (empty -> .)

    output1                        shift and go to state 173
    empty                          shift and go to state 175

state 152

    (129) map_assignment -> map_access ASSIGNATOR exp .

    ;               reduce using rule 129 (map_assignment -> map_access ASSIGNATOR exp .)


state 153

    (27) assignment -> assignment2 ASSIGNATOR n_quad_assign . expression
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 176
    empty                          shift and go to state 99

state 154

    (43) function_call -> ID ( function_call1 . )

    )               shift and go to state 177


state 155

    (45) function_call1 -> function_call2 .

    )               reduce using rule 45 (function_call1 -> function_call2 .)


state 156

    (128) map_access -> ID ( exp . )
    (77) exp0 -> exp . exp02
    (78) exp02 -> . relop exp
    (79) exp02 -> . empty
    (65) relop -> . <
    (66) relop -> . >
    (67) relop -> . NOT_EQ
    (68) relop -> . EQ
    (69) relop -> . LEQ
    (70) relop -> . GEQ
    (131) empty -> .

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 178
    <               shift and go to state 146
    >               shift and go to state 148
    NOT_EQ          shift and go to state 142
    EQ              shift and go to state 145
    LEQ             shift and go to state 143
    GEQ             shift and go to state 140
    OR              reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)

  ! )               [ reduce using rule 131 (empty -> .) ]

    exp02                          shift and go to state 144
    empty                          shift and go to state 147
    relop                          shift and go to state 141

state 157

    (46) function_call2 -> expression . , function_call2
    (47) function_call2 -> expression .

    ,               shift and go to state 179
    )               reduce using rule 47 (function_call2 -> expression .)


state 158

    (44) function_call1 -> empty .
    (94) term_not -> empty .

    )               reduce using rule 44 (function_call1 -> empty .)
    (               reduce using rule 94 (term_not -> empty .)
    ID              reduce using rule 94 (term_not -> empty .)
    CTE_INT         reduce using rule 94 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 94 (term_not -> empty .)
    CTE_BOOL        reduce using rule 94 (term_not -> empty .)
    CTE_STRING      reduce using rule 94 (term_not -> empty .)
    CTE_CHAR        reduce using rule 94 (term_not -> empty .)


state 159

    (49) set_operation -> ID . OPERATION . ( set_operation1 )
    (130) map_operation -> ID . OPERATION . ( )

    (               shift and go to state 180


state 160

    (30) condition -> IF ( expression . ) block condition1

    )               shift and go to state 181


state 161

    (15) proc2 -> , datatype ID proc2 .

    )               reduce using rule 15 (proc2 -> , datatype ID proc2 .)


state 162

    (95) factor -> ( n_push_false_bottom . expression ) n_pop_false_bottom
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 182
    empty                          shift and go to state 99

state 163

    (87) term -> term_not factor n_quad_muldiv . term2
    (90) term2 -> . muldiv factor n_quad_muldiv term2
    (91) term2 -> . n_quad_not
    (83) muldiv -> . *
    (84) muldiv -> . /
    (92) n_quad_not -> .

    *               shift and go to state 184
    /               shift and go to state 186
    +               reduce using rule 92 (n_quad_not -> .)
    -               reduce using rule 92 (n_quad_not -> .)
    <               reduce using rule 92 (n_quad_not -> .)
    >               reduce using rule 92 (n_quad_not -> .)
    NOT_EQ          reduce using rule 92 (n_quad_not -> .)
    EQ              reduce using rule 92 (n_quad_not -> .)
    LEQ             reduce using rule 92 (n_quad_not -> .)
    GEQ             reduce using rule 92 (n_quad_not -> .)
    OR              reduce using rule 92 (n_quad_not -> .)
    AND             reduce using rule 92 (n_quad_not -> .)
    ;               reduce using rule 92 (n_quad_not -> .)
    ,               reduce using rule 92 (n_quad_not -> .)
    )               reduce using rule 92 (n_quad_not -> .)

    term2                          shift and go to state 183
    n_quad_not                     shift and go to state 185
    muldiv                         shift and go to state 187

state 164

    (130) map_operation -> ID . . OPERATION ( )
    (49) set_operation -> ID . . OPERATION ( set_operation1 )

    OPERATION       shift and go to state 188


state 165

    (99) varcte -> ID empty .

    *               reduce using rule 99 (varcte -> ID empty .)
    /               reduce using rule 99 (varcte -> ID empty .)
    +               reduce using rule 99 (varcte -> ID empty .)
    -               reduce using rule 99 (varcte -> ID empty .)
    <               reduce using rule 99 (varcte -> ID empty .)
    >               reduce using rule 99 (varcte -> ID empty .)
    NOT_EQ          reduce using rule 99 (varcte -> ID empty .)
    EQ              reduce using rule 99 (varcte -> ID empty .)
    LEQ             reduce using rule 99 (varcte -> ID empty .)
    GEQ             reduce using rule 99 (varcte -> ID empty .)
    OR              reduce using rule 99 (varcte -> ID empty .)
    AND             reduce using rule 99 (varcte -> ID empty .)
    ;               reduce using rule 99 (varcte -> ID empty .)
    ,               reduce using rule 99 (varcte -> ID empty .)
    )               reduce using rule 99 (varcte -> ID empty .)


state 166

    (85) exp2 -> addsub term . n_quad_addsub exp2
    (89) n_quad_addsub -> .

    +               reduce using rule 89 (n_quad_addsub -> .)
    -               reduce using rule 89 (n_quad_addsub -> .)
    <               reduce using rule 89 (n_quad_addsub -> .)
    >               reduce using rule 89 (n_quad_addsub -> .)
    NOT_EQ          reduce using rule 89 (n_quad_addsub -> .)
    EQ              reduce using rule 89 (n_quad_addsub -> .)
    LEQ             reduce using rule 89 (n_quad_addsub -> .)
    GEQ             reduce using rule 89 (n_quad_addsub -> .)
    OR              reduce using rule 89 (n_quad_addsub -> .)
    AND             reduce using rule 89 (n_quad_addsub -> .)
    ;               reduce using rule 89 (n_quad_addsub -> .)
    ,               reduce using rule 89 (n_quad_addsub -> .)
    )               reduce using rule 89 (n_quad_addsub -> .)

    n_quad_addsub                  shift and go to state 189

state 167

    (74) expression2 -> logop exp0 . n_quad_logop expression2
    (76) n_quad_logop -> .

    OR              reduce using rule 76 (n_quad_logop -> .)
    AND             reduce using rule 76 (n_quad_logop -> .)
    ;               reduce using rule 76 (n_quad_logop -> .)
    ,               reduce using rule 76 (n_quad_logop -> .)
    )               reduce using rule 76 (n_quad_logop -> .)

    n_quad_logop                   shift and go to state 190

state 168

    (78) exp02 -> relop exp .

    OR              reduce using rule 78 (exp02 -> relop exp .)
    AND             reduce using rule 78 (exp02 -> relop exp .)
    ,               reduce using rule 78 (exp02 -> relop exp .)
    )               reduce using rule 78 (exp02 -> relop exp .)
    ;               reduce using rule 78 (exp02 -> relop exp .)


state 169

    (37) input -> READ ( ID input1 . )

    )               shift and go to state 191


state 170

    (38) input1 -> , . ID input1

    ID              shift and go to state 192


state 171

    (39) input1 -> empty .

    )               reduce using rule 39 (input1 -> empty .)


state 172

    (33) while -> WHILE n_while_1 ( expression . ) n_while_2 block n_while_3

    )               shift and go to state 193


state 173

    (40) output -> PRINT ( expression output1 . )

    )               shift and go to state 194


state 174

    (41) output1 -> , . expression output1
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 195
    empty                          shift and go to state 99

state 175

    (42) output1 -> empty .

    )               reduce using rule 42 (output1 -> empty .)


state 176

    (27) assignment -> assignment2 ASSIGNATOR n_quad_assign expression .

    ;               reduce using rule 27 (assignment -> assignment2 ASSIGNATOR n_quad_assign expression .)


state 177

    (43) function_call -> ID ( function_call1 ) .

    ;               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    *               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    /               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    +               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    -               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    <               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    >               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    NOT_EQ          reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    EQ              reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    LEQ             reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    GEQ             reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    OR              reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    AND             reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    ,               reduce using rule 43 (function_call -> ID ( function_call1 ) .)
    )               reduce using rule 43 (function_call -> ID ( function_call1 ) .)


state 178

    (128) map_access -> ID ( exp ) .

    ASSIGNATOR      reduce using rule 128 (map_access -> ID ( exp ) .)
    *               reduce using rule 128 (map_access -> ID ( exp ) .)
    /               reduce using rule 128 (map_access -> ID ( exp ) .)
    +               reduce using rule 128 (map_access -> ID ( exp ) .)
    -               reduce using rule 128 (map_access -> ID ( exp ) .)
    <               reduce using rule 128 (map_access -> ID ( exp ) .)
    >               reduce using rule 128 (map_access -> ID ( exp ) .)
    NOT_EQ          reduce using rule 128 (map_access -> ID ( exp ) .)
    EQ              reduce using rule 128 (map_access -> ID ( exp ) .)
    LEQ             reduce using rule 128 (map_access -> ID ( exp ) .)
    GEQ             reduce using rule 128 (map_access -> ID ( exp ) .)
    OR              reduce using rule 128 (map_access -> ID ( exp ) .)
    AND             reduce using rule 128 (map_access -> ID ( exp ) .)
    ;               reduce using rule 128 (map_access -> ID ( exp ) .)
    ,               reduce using rule 128 (map_access -> ID ( exp ) .)
    )               reduce using rule 128 (map_access -> ID ( exp ) .)


state 179

    (46) function_call2 -> expression , . function_call2
    (46) function_call2 -> . expression , function_call2
    (47) function_call2 -> . expression
    (73) expression -> . exp0 expression2
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty
    (131) empty -> .

    !               shift and go to state 96
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)

    term_not                       shift and go to state 93
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    function_call2                 shift and go to state 196
    exp                            shift and go to state 97
    expression                     shift and go to state 157
    empty                          shift and go to state 99

state 180

    (49) set_operation -> ID . OPERATION ( . set_operation1 )
    (130) map_operation -> ID . OPERATION ( . )
    (50) set_operation1 -> . expression
    (51) set_operation1 -> . empty
    (73) expression -> . exp0 expression2
    (131) empty -> .
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 198
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)
    !               shift and go to state 96

  ! )               [ reduce using rule 131 (empty -> .) ]

    term_not                       shift and go to state 93
    set_operation1                 shift and go to state 197
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 199
    empty                          shift and go to state 200

state 181

    (30) condition -> IF ( expression ) . block condition1
    (120) block -> . { statement_aux }

    {               shift and go to state 202

    block                          shift and go to state 201

state 182

    (95) factor -> ( n_push_false_bottom expression . ) n_pop_false_bottom

    )               shift and go to state 203


state 183

    (87) term -> term_not factor n_quad_muldiv term2 .

    +               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    -               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    <               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    >               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    NOT_EQ          reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    EQ              reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    LEQ             reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    GEQ             reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    OR              reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    AND             reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    ;               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    ,               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)
    )               reduce using rule 87 (term -> term_not factor n_quad_muldiv term2 .)


state 184

    (83) muldiv -> * .

    (               reduce using rule 83 (muldiv -> * .)
    ID              reduce using rule 83 (muldiv -> * .)
    CTE_INT         reduce using rule 83 (muldiv -> * .)
    CTE_FLOAT       reduce using rule 83 (muldiv -> * .)
    CTE_BOOL        reduce using rule 83 (muldiv -> * .)
    CTE_STRING      reduce using rule 83 (muldiv -> * .)
    CTE_CHAR        reduce using rule 83 (muldiv -> * .)


state 185

    (91) term2 -> n_quad_not .

    +               reduce using rule 91 (term2 -> n_quad_not .)
    -               reduce using rule 91 (term2 -> n_quad_not .)
    <               reduce using rule 91 (term2 -> n_quad_not .)
    >               reduce using rule 91 (term2 -> n_quad_not .)
    NOT_EQ          reduce using rule 91 (term2 -> n_quad_not .)
    EQ              reduce using rule 91 (term2 -> n_quad_not .)
    LEQ             reduce using rule 91 (term2 -> n_quad_not .)
    GEQ             reduce using rule 91 (term2 -> n_quad_not .)
    OR              reduce using rule 91 (term2 -> n_quad_not .)
    AND             reduce using rule 91 (term2 -> n_quad_not .)
    ;               reduce using rule 91 (term2 -> n_quad_not .)
    ,               reduce using rule 91 (term2 -> n_quad_not .)
    )               reduce using rule 91 (term2 -> n_quad_not .)


state 186

    (84) muldiv -> / .

    (               reduce using rule 84 (muldiv -> / .)
    ID              reduce using rule 84 (muldiv -> / .)
    CTE_INT         reduce using rule 84 (muldiv -> / .)
    CTE_FLOAT       reduce using rule 84 (muldiv -> / .)
    CTE_BOOL        reduce using rule 84 (muldiv -> / .)
    CTE_STRING      reduce using rule 84 (muldiv -> / .)
    CTE_CHAR        reduce using rule 84 (muldiv -> / .)


state 187

    (90) term2 -> muldiv . factor n_quad_muldiv term2
    (95) factor -> . ( n_push_false_bottom expression ) n_pop_false_bottom
    (96) factor -> . varcte
    (99) varcte -> . ID empty
    (100) varcte -> . varcte1
    (101) varcte1 -> . CTE_INT
    (102) varcte1 -> . CTE_FLOAT
    (103) varcte1 -> . CTE_BOOL
    (104) varcte1 -> . CTE_STRING
    (105) varcte1 -> . CTE_CHAR
    (106) varcte1 -> . function_call
    (107) varcte1 -> . map_access
    (108) varcte1 -> . map_operation
    (109) varcte1 -> . set_operation
    (43) function_call -> . ID ( function_call1 )
    (128) map_access -> . ID ( exp )
    (130) map_operation -> . ID . OPERATION ( )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )

    (               shift and go to state 119
    ID              shift and go to state 124
    CTE_INT         shift and go to state 123
    CTE_FLOAT       shift and go to state 126
    CTE_BOOL        shift and go to state 127
    CTE_STRING      shift and go to state 128
    CTE_CHAR        shift and go to state 121

    map_operation                  shift and go to state 122
    set_operation                  shift and go to state 125
    map_access                     shift and go to state 129
    function_call                  shift and go to state 116
    factor                         shift and go to state 204
    varcte1                        shift and go to state 117
    varcte                         shift and go to state 118

state 188

    (130) map_operation -> ID . OPERATION . ( )
    (49) set_operation -> ID . OPERATION . ( set_operation1 )

    (               shift and go to state 205


state 189

    (85) exp2 -> addsub term n_quad_addsub . exp2
    (85) exp2 -> . addsub term n_quad_addsub exp2
    (86) exp2 -> . empty
    (81) addsub -> . +
    (82) addsub -> . -
    (131) empty -> .

    +               shift and go to state 131
    -               shift and go to state 132
    <               reduce using rule 131 (empty -> .)
    >               reduce using rule 131 (empty -> .)
    NOT_EQ          reduce using rule 131 (empty -> .)
    EQ              reduce using rule 131 (empty -> .)
    LEQ             reduce using rule 131 (empty -> .)
    GEQ             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)

    exp2                           shift and go to state 206
    addsub                         shift and go to state 133
    empty                          shift and go to state 134

state 190

    (74) expression2 -> logop exp0 n_quad_logop . expression2
    (74) expression2 -> . logop exp0 n_quad_logop expression2
    (75) expression2 -> . empty
    (71) logop -> . OR
    (72) logop -> . AND
    (131) empty -> .

    OR              shift and go to state 138
    AND             shift and go to state 135
    ;               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)

    logop                          shift and go to state 136
    empty                          shift and go to state 139
    expression2                    shift and go to state 207

state 191

    (37) input -> READ ( ID input1 ) .

    ;               reduce using rule 37 (input -> READ ( ID input1 ) .)


state 192

    (38) input1 -> , ID . input1
    (38) input1 -> . , ID input1
    (39) input1 -> . empty
    (131) empty -> .

    ,               shift and go to state 170
    )               reduce using rule 131 (empty -> .)

    input1                         shift and go to state 208
    empty                          shift and go to state 171

state 193

    (33) while -> WHILE n_while_1 ( expression ) . n_while_2 block n_while_3
    (35) n_while_2 -> .

    {               reduce using rule 35 (n_while_2 -> .)

    n_while_2                      shift and go to state 209

state 194

    (40) output -> PRINT ( expression output1 ) .

    ;               reduce using rule 40 (output -> PRINT ( expression output1 ) .)


state 195

    (41) output1 -> , expression . output1
    (41) output1 -> . , expression output1
    (42) output1 -> . empty
    (131) empty -> .

    ,               shift and go to state 174
    )               reduce using rule 131 (empty -> .)

    output1                        shift and go to state 210
    empty                          shift and go to state 175

state 196

    (46) function_call2 -> expression , function_call2 .

    )               reduce using rule 46 (function_call2 -> expression , function_call2 .)


state 197

    (49) set_operation -> ID . OPERATION ( set_operation1 . )

    )               shift and go to state 211


state 198

    (130) map_operation -> ID . OPERATION ( ) .

    ;               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    *               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    /               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    +               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    -               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    <               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    >               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    NOT_EQ          reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    EQ              reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    LEQ             reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    GEQ             reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    OR              reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    AND             reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    ,               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)
    )               reduce using rule 130 (map_operation -> ID . OPERATION ( ) .)


state 199

    (50) set_operation1 -> expression .

    )               reduce using rule 50 (set_operation1 -> expression .)


state 200

    (51) set_operation1 -> empty .
    (94) term_not -> empty .

    )               reduce using rule 51 (set_operation1 -> empty .)
    (               reduce using rule 94 (term_not -> empty .)
    ID              reduce using rule 94 (term_not -> empty .)
    CTE_INT         reduce using rule 94 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 94 (term_not -> empty .)
    CTE_BOOL        reduce using rule 94 (term_not -> empty .)
    CTE_STRING      reduce using rule 94 (term_not -> empty .)
    CTE_CHAR        reduce using rule 94 (term_not -> empty .)


state 201

    (30) condition -> IF ( expression ) block . condition1
    (31) condition1 -> . ELSE block
    (32) condition1 -> . empty
    (131) empty -> .

    ELSE            shift and go to state 212
    READ            reduce using rule 131 (empty -> .)
    PRINT           reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    MAP             reduce using rule 131 (empty -> .)
    RETURN          reduce using rule 131 (empty -> .)
    IF              reduce using rule 131 (empty -> .)
    WHILE           reduce using rule 131 (empty -> .)
    }               reduce using rule 131 (empty -> .)

    empty                          shift and go to state 213
    condition1                     shift and go to state 214

state 202

    (120) block -> { . statement_aux }
    (121) statement_aux -> . statement statement_aux
    (122) statement_aux -> . empty
    (52) statement -> . statement1 ;
    (53) statement -> . statement2
    (131) empty -> .
    (54) statement1 -> . assignment
    (55) statement1 -> . input
    (56) statement1 -> . output
    (57) statement1 -> . set_operation
    (58) statement1 -> . map_definition
    (59) statement1 -> . return
    (60) statement1 -> . map_assignment
    (61) statement1 -> . map_operation
    (62) statement1 -> . function_call
    (63) statement2 -> . condition
    (64) statement2 -> . while
    (27) assignment -> . assignment2 ASSIGNATOR n_quad_assign expression
    (37) input -> . READ ( ID input1 )
    (40) output -> . PRINT ( expression output1 )
    (49) set_operation -> . ID . OPERATION ( set_operation1 )
    (127) map_definition -> . MAP < datatype , datatype >
    (48) return -> . RETURN expression
    (129) map_assignment -> . map_access ASSIGNATOR exp
    (130) map_operation -> . ID . OPERATION ( )
    (43) function_call -> . ID ( function_call1 )
    (30) condition -> . IF ( expression ) block condition1
    (33) while -> . WHILE n_while_1 ( expression ) n_while_2 block n_while_3
    (28) assignment2 -> . ID
    (128) map_access -> . ID ( exp )

    }               reduce using rule 131 (empty -> .)
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    ID              shift and go to state 80
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 82
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 88
    function_call                  shift and go to state 64
    statement_aux                  shift and go to state 215
    map_access                     shift and go to state 70
    assignment2                    shift and go to state 71
    statement                      shift and go to state 90
    input                          shift and go to state 74
    empty                          shift and go to state 91
    return                         shift and go to state 78
    statement2                     shift and go to state 69
    statement1                     shift and go to state 76
    assignment                     shift and go to state 77
    map_operation                  shift and go to state 79
    condition                      shift and go to state 81
    set_operation                  shift and go to state 83
    map_assignment                 shift and go to state 62
    while                          shift and go to state 84
    output                         shift and go to state 85

state 203

    (95) factor -> ( n_push_false_bottom expression ) . n_pop_false_bottom
    (98) n_pop_false_bottom -> .

    *               reduce using rule 98 (n_pop_false_bottom -> .)
    /               reduce using rule 98 (n_pop_false_bottom -> .)
    +               reduce using rule 98 (n_pop_false_bottom -> .)
    -               reduce using rule 98 (n_pop_false_bottom -> .)
    <               reduce using rule 98 (n_pop_false_bottom -> .)
    >               reduce using rule 98 (n_pop_false_bottom -> .)
    NOT_EQ          reduce using rule 98 (n_pop_false_bottom -> .)
    EQ              reduce using rule 98 (n_pop_false_bottom -> .)
    LEQ             reduce using rule 98 (n_pop_false_bottom -> .)
    GEQ             reduce using rule 98 (n_pop_false_bottom -> .)
    OR              reduce using rule 98 (n_pop_false_bottom -> .)
    AND             reduce using rule 98 (n_pop_false_bottom -> .)
    ;               reduce using rule 98 (n_pop_false_bottom -> .)
    ,               reduce using rule 98 (n_pop_false_bottom -> .)
    )               reduce using rule 98 (n_pop_false_bottom -> .)

    n_pop_false_bottom             shift and go to state 216

state 204

    (90) term2 -> muldiv factor . n_quad_muldiv term2
    (88) n_quad_muldiv -> .

    *               reduce using rule 88 (n_quad_muldiv -> .)
    /               reduce using rule 88 (n_quad_muldiv -> .)
    +               reduce using rule 88 (n_quad_muldiv -> .)
    -               reduce using rule 88 (n_quad_muldiv -> .)
    <               reduce using rule 88 (n_quad_muldiv -> .)
    >               reduce using rule 88 (n_quad_muldiv -> .)
    NOT_EQ          reduce using rule 88 (n_quad_muldiv -> .)
    EQ              reduce using rule 88 (n_quad_muldiv -> .)
    LEQ             reduce using rule 88 (n_quad_muldiv -> .)
    GEQ             reduce using rule 88 (n_quad_muldiv -> .)
    OR              reduce using rule 88 (n_quad_muldiv -> .)
    AND             reduce using rule 88 (n_quad_muldiv -> .)
    ;               reduce using rule 88 (n_quad_muldiv -> .)
    ,               reduce using rule 88 (n_quad_muldiv -> .)
    )               reduce using rule 88 (n_quad_muldiv -> .)

    n_quad_muldiv                  shift and go to state 217

state 205

    (130) map_operation -> ID . OPERATION ( . )
    (49) set_operation -> ID . OPERATION ( . set_operation1 )
    (50) set_operation1 -> . expression
    (51) set_operation1 -> . empty
    (73) expression -> . exp0 expression2
    (131) empty -> .
    (77) exp0 -> . exp exp02
    (80) exp -> . term exp2
    (87) term -> . term_not factor n_quad_muldiv term2
    (93) term_not -> . !
    (94) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 198
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTE_INT         reduce using rule 131 (empty -> .)
    CTE_FLOAT       reduce using rule 131 (empty -> .)
    CTE_BOOL        reduce using rule 131 (empty -> .)
    CTE_STRING      reduce using rule 131 (empty -> .)
    CTE_CHAR        reduce using rule 131 (empty -> .)
    !               shift and go to state 96

  ! )               [ reduce using rule 131 (empty -> .) ]

    term_not                       shift and go to state 93
    set_operation1                 shift and go to state 197
    term                           shift and go to state 94
    exp0                           shift and go to state 95
    exp                            shift and go to state 97
    expression                     shift and go to state 199
    empty                          shift and go to state 200

state 206

    (85) exp2 -> addsub term n_quad_addsub exp2 .

    <               reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    >               reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    NOT_EQ          reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    EQ              reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    LEQ             reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    GEQ             reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    OR              reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    AND             reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    ;               reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    ,               reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)
    )               reduce using rule 85 (exp2 -> addsub term n_quad_addsub exp2 .)


state 207

    (74) expression2 -> logop exp0 n_quad_logop expression2 .

    ;               reduce using rule 74 (expression2 -> logop exp0 n_quad_logop expression2 .)
    ,               reduce using rule 74 (expression2 -> logop exp0 n_quad_logop expression2 .)
    )               reduce using rule 74 (expression2 -> logop exp0 n_quad_logop expression2 .)


state 208

    (38) input1 -> , ID input1 .

    )               reduce using rule 38 (input1 -> , ID input1 .)


state 209

    (33) while -> WHILE n_while_1 ( expression ) n_while_2 . block n_while_3
    (120) block -> . { statement_aux }

    {               shift and go to state 202

    block                          shift and go to state 218

state 210

    (41) output1 -> , expression output1 .

    )               reduce using rule 41 (output1 -> , expression output1 .)


state 211

    (49) set_operation -> ID . OPERATION ( set_operation1 ) .

    ;               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    *               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    /               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    +               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    -               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    <               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    >               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    NOT_EQ          reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    EQ              reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    LEQ             reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    GEQ             reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    OR              reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    AND             reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    ,               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    )               reduce using rule 49 (set_operation -> ID . OPERATION ( set_operation1 ) .)


state 212

    (31) condition1 -> ELSE . block
    (120) block -> . { statement_aux }

    {               shift and go to state 202

    block                          shift and go to state 219

state 213

    (32) condition1 -> empty .

    READ            reduce using rule 32 (condition1 -> empty .)
    PRINT           reduce using rule 32 (condition1 -> empty .)
    ID              reduce using rule 32 (condition1 -> empty .)
    MAP             reduce using rule 32 (condition1 -> empty .)
    RETURN          reduce using rule 32 (condition1 -> empty .)
    IF              reduce using rule 32 (condition1 -> empty .)
    WHILE           reduce using rule 32 (condition1 -> empty .)
    }               reduce using rule 32 (condition1 -> empty .)


state 214

    (30) condition -> IF ( expression ) block condition1 .

    READ            reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    PRINT           reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    ID              reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    MAP             reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    RETURN          reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    IF              reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    WHILE           reduce using rule 30 (condition -> IF ( expression ) block condition1 .)
    }               reduce using rule 30 (condition -> IF ( expression ) block condition1 .)


state 215

    (120) block -> { statement_aux . }

    }               shift and go to state 220


state 216

    (95) factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .

    *               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    /               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    +               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    -               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    <               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    >               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    NOT_EQ          reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    EQ              reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    LEQ             reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    GEQ             reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    OR              reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    AND             reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ;               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ,               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    )               reduce using rule 95 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)


state 217

    (90) term2 -> muldiv factor n_quad_muldiv . term2
    (90) term2 -> . muldiv factor n_quad_muldiv term2
    (91) term2 -> . n_quad_not
    (83) muldiv -> . *
    (84) muldiv -> . /
    (92) n_quad_not -> .

    *               shift and go to state 184
    /               shift and go to state 186
    +               reduce using rule 92 (n_quad_not -> .)
    -               reduce using rule 92 (n_quad_not -> .)
    <               reduce using rule 92 (n_quad_not -> .)
    >               reduce using rule 92 (n_quad_not -> .)
    NOT_EQ          reduce using rule 92 (n_quad_not -> .)
    EQ              reduce using rule 92 (n_quad_not -> .)
    LEQ             reduce using rule 92 (n_quad_not -> .)
    GEQ             reduce using rule 92 (n_quad_not -> .)
    OR              reduce using rule 92 (n_quad_not -> .)
    AND             reduce using rule 92 (n_quad_not -> .)
    ;               reduce using rule 92 (n_quad_not -> .)
    ,               reduce using rule 92 (n_quad_not -> .)
    )               reduce using rule 92 (n_quad_not -> .)

    term2                          shift and go to state 221
    n_quad_not                     shift and go to state 185
    muldiv                         shift and go to state 187

state 218

    (33) while -> WHILE n_while_1 ( expression ) n_while_2 block . n_while_3
    (36) n_while_3 -> .

    READ            reduce using rule 36 (n_while_3 -> .)
    PRINT           reduce using rule 36 (n_while_3 -> .)
    ID              reduce using rule 36 (n_while_3 -> .)
    MAP             reduce using rule 36 (n_while_3 -> .)
    RETURN          reduce using rule 36 (n_while_3 -> .)
    IF              reduce using rule 36 (n_while_3 -> .)
    WHILE           reduce using rule 36 (n_while_3 -> .)
    }               reduce using rule 36 (n_while_3 -> .)

    n_while_3                      shift and go to state 222

state 219

    (31) condition1 -> ELSE block .

    READ            reduce using rule 31 (condition1 -> ELSE block .)
    PRINT           reduce using rule 31 (condition1 -> ELSE block .)
    ID              reduce using rule 31 (condition1 -> ELSE block .)
    MAP             reduce using rule 31 (condition1 -> ELSE block .)
    RETURN          reduce using rule 31 (condition1 -> ELSE block .)
    IF              reduce using rule 31 (condition1 -> ELSE block .)
    WHILE           reduce using rule 31 (condition1 -> ELSE block .)
    }               reduce using rule 31 (condition1 -> ELSE block .)


state 220

    (120) block -> { statement_aux } .

    READ            reduce using rule 120 (block -> { statement_aux } .)
    PRINT           reduce using rule 120 (block -> { statement_aux } .)
    ID              reduce using rule 120 (block -> { statement_aux } .)
    MAP             reduce using rule 120 (block -> { statement_aux } .)
    RETURN          reduce using rule 120 (block -> { statement_aux } .)
    IF              reduce using rule 120 (block -> { statement_aux } .)
    WHILE           reduce using rule 120 (block -> { statement_aux } .)
    }               reduce using rule 120 (block -> { statement_aux } .)
    ELSE            reduce using rule 120 (block -> { statement_aux } .)


state 221

    (90) term2 -> muldiv factor n_quad_muldiv term2 .

    +               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    -               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    <               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    >               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    NOT_EQ          reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    EQ              reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    LEQ             reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    GEQ             reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    OR              reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    AND             reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ;               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ,               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)
    )               reduce using rule 90 (term2 -> muldiv factor n_quad_muldiv term2 .)


state 222

    (33) while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .

    READ            reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    PRINT           reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    ID              reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    MAP             reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    RETURN          reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    IF              reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    WHILE           reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)
    }               reduce using rule 33 (while -> WHILE n_while_1 ( expression ) n_while_2 block n_while_3 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 4 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 4 resolved as shift
WARNING: shift/reduce conflict for SET in state 4 resolved as shift
WARNING: shift/reduce conflict for MAP in state 4 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 12 resolved as shift
WARNING: shift/reduce conflict for INT in state 12 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 12 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 12 resolved as shift
WARNING: shift/reduce conflict for STRING in state 12 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 12 resolved as shift
WARNING: shift/reduce conflict for SET in state 12 resolved as shift
WARNING: shift/reduce conflict for MAP in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 14 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 14 resolved as shift
WARNING: shift/reduce conflict for INT in state 14 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 14 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 14 resolved as shift
WARNING: shift/reduce conflict for STRING in state 14 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 14 resolved as shift
WARNING: shift/reduce conflict for SET in state 14 resolved as shift
WARNING: shift/reduce conflict for MAP in state 14 resolved as shift
WARNING: shift/reduce conflict for MAP in state 46 resolved as shift
WARNING: shift/reduce conflict for MAP in state 57 resolved as shift
WARNING: shift/reduce conflict for ) in state 156 resolved as shift
WARNING: shift/reduce conflict for ) in state 180 resolved as shift
WARNING: shift/reduce conflict for ) in state 205 resolved as shift
