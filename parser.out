Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; program1
Rule 2     program1 -> var program1
Rule 3     program1 -> program2
Rule 4     program2 -> procs main
Rule 5     program2 -> main
Rule 6     procs -> proc
Rule 7     procs -> proc procs
Rule 8     proc -> datatype procA
Rule 9     proc -> VOID procA
Rule 10    proc -> empty
Rule 11    procA -> ID ( proc1 ) { proc3 }
Rule 12    proc1 -> datatype ID proc2
Rule 13    proc1 -> empty
Rule 14    proc2 -> , datatype ID proc2
Rule 15    proc2 -> empty
Rule 16    proc3 -> var proc3
Rule 17    proc3 -> proc4
Rule 18    proc4 -> statement proc4
Rule 19    proc4 -> empty
Rule 20    vars -> var vars
Rule 21    vars -> var
Rule 22    var -> datatype var1
Rule 23    var1 -> ID , var1
Rule 24    var1 -> ID var2
Rule 25    var2 -> ;
Rule 26    assignment -> ID ASSIGNATOR expression
Rule 27    condition -> IF ( expression ) block condition1
Rule 28    condition1 -> ELSE block
Rule 29    condition1 -> empty
Rule 30    input -> READ ( ID input1 )
Rule 31    input1 -> , ID input1
Rule 32    input1 -> empty
Rule 33    output -> PRINT ( expression output1 )
Rule 34    output1 -> , expression output1
Rule 35    output1 -> empty
Rule 36    function_call -> ID ( function_call1 )
Rule 37    function_call1 -> function_call2
Rule 38    function_call1 -> empty
Rule 39    function_call2 -> expression , function_call2
Rule 40    function_call2 -> empty
Rule 41    return -> RETURN expression
Rule 42    set_operation -> ID . OPERATION ( set_operation1 )
Rule 43    set_operation1 -> expression
Rule 44    set_operation1 -> empty
Rule 45    statement -> statement1 ;
Rule 46    statement -> statement2
Rule 47    statement1 -> assignment
Rule 48    statement1 -> input
Rule 49    statement1 -> output
Rule 50    statement1 -> set_operation
Rule 51    statement1 -> map_definition
Rule 52    statement1 -> return
Rule 53    statement1 -> map_assignment
Rule 54    statement1 -> map_operation
Rule 55    statement1 -> function_call
Rule 56    statement2 -> condition
Rule 57    statement2 -> while
Rule 58    while -> WHILE ( expression ) block
Rule 59    relop -> <
Rule 60    relop -> >
Rule 61    relop -> NOT_EQ
Rule 62    relop -> EQ
Rule 63    relop -> LEQ
Rule 64    relop -> GEQ
Rule 65    logop -> OR
Rule 66    logop -> AND
Rule 67    expression -> exp0 expression2
Rule 68    expression2 -> logop exp0 expression2
Rule 69    expression2 -> empty
Rule 70    exp0 -> exp exp02
Rule 71    exp02 -> relop exp0
Rule 72    exp02 -> empty
Rule 73    exp -> term exp2
Rule 74    addsub -> +
Rule 75    addsub -> -
Rule 76    muldiv -> *
Rule 77    muldiv -> /
Rule 78    exp2 -> addsub term exp2
Rule 79    exp2 -> empty
Rule 80    term -> term_not factor term2
Rule 81    term2 -> muldiv factor term2
Rule 82    term2 -> empty
Rule 83    term_not -> !
Rule 84    term_not -> empty
Rule 85    factor -> ( expression )
Rule 86    factor -> factor2
Rule 87    factor2 -> factor3 varcte
Rule 88    factor3 -> addsub
Rule 89    factor3 -> empty
Rule 90    varcte -> ID
Rule 91    varcte -> CTE_INT
Rule 92    varcte -> CTE_FLOAT
Rule 93    varcte -> CTE_BOOL
Rule 94    varcte -> CTE_STRING
Rule 95    varcte -> CTE_CHAR
Rule 96    varcte -> function_call
Rule 97    varcte -> map_access
Rule 98    varcte -> map_operation
Rule 99    varcte -> set_operation
Rule 100   functype -> datatype
Rule 101   functype -> VOID
Rule 102   datatype -> INT
Rule 103   datatype -> FLOAT
Rule 104   datatype -> BOOL
Rule 105   datatype -> STRING
Rule 106   datatype -> CHAR
Rule 107   datatype -> set_definition
Rule 108   datatype -> map_definition
Rule 109   set_definition -> SET < datatype >
Rule 110   block -> { statement_aux }
Rule 111   statement_aux -> statement statement_aux
Rule 112   statement_aux -> empty
Rule 113   main -> MAIN { vars_aux statement_aux }
Rule 114   vars_aux -> vars
Rule 115   vars_aux -> empty
Rule 116   map_definition -> MAP < datatype , datatype >
Rule 117   map_access -> ID ( exp )
Rule 118   map_assignment -> map_access ASSIGNATOR exp
Rule 119   map_operation -> ID . OPERATION ( )
Rule 120   empty -> <empty>

Terminals, with rules where they appear

!                    : 83
(                    : 11 27 30 33 36 42 58 85 117 119
)                    : 11 27 30 33 36 42 58 85 117 119
*                    : 76
+                    : 74
,                    : 14 23 31 34 39 116
-                    : 75
.                    : 42 119
/                    : 77
;                    : 1 25 45
<                    : 59 109 116
>                    : 60 109 116
AND                  : 66
ASSIGNATOR           : 26 118
BOOL                 : 104
CHAR                 : 106
CTE_BOOL             : 93
CTE_CHAR             : 95
CTE_FLOAT            : 92
CTE_INT              : 91
CTE_STRING           : 94
ELSE                 : 28
EQ                   : 62
FLOAT                : 103
GEQ                  : 64
ID                   : 1 11 12 14 23 24 26 30 31 36 42 90 117 119
IF                   : 27
INT                  : 102
LEQ                  : 63
MAIN                 : 113
MAP                  : 116
NOT_EQ               : 61
OPERATION            : 42 119
OR                   : 65
PRINT                : 33
PROGRAM              : 1
READ                 : 30
RETURN               : 41
SET                  : 109
STRING               : 105
VOID                 : 9 101
WHILE                : 58
error                : 
{                    : 11 110 113
}                    : 11 110 113

Nonterminals, with rules where they appear

addsub               : 78 88
assignment           : 47
block                : 27 28 58
condition            : 56
condition1           : 27
datatype             : 8 12 14 22 100 109 116 116
empty                : 10 13 15 19 29 32 35 38 40 44 69 72 79 82 84 89 112 115
exp                  : 70 117 118
exp0                 : 67 68 71
exp02                : 70
exp2                 : 73 78
expression           : 26 27 33 34 39 41 43 58 85
expression2          : 67 68
factor               : 80 81
factor2              : 86
factor3              : 87
function_call        : 55 96
function_call1       : 36
function_call2       : 37 39
functype             : 
input                : 48
input1               : 30 31
logop                : 68
main                 : 4 5
map_access           : 97 118
map_assignment       : 53
map_definition       : 51 108
map_operation        : 54 98
muldiv               : 81
output               : 49
output1              : 33 34
proc                 : 6 7
proc1                : 11
proc2                : 12 14
proc3                : 11 16
proc4                : 17 18
procA                : 8 9
procs                : 4 7
program              : 0
program1             : 1 2
program2             : 3
relop                : 71
return               : 52
set_definition       : 107
set_operation        : 50 99
set_operation1       : 42
statement            : 18 111
statement1           : 45
statement2           : 46
statement_aux        : 110 111 113
term                 : 73 78
term2                : 80 81
term_not             : 80
var                  : 2 16 20 21
var1                 : 22 23
var2                 : 24
varcte               : 87
vars                 : 20 114
vars_aux             : 113
while                : 57

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID ; program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . ; program1

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . program1
    (2) program1 -> . var program1
    (3) program1 -> . program2
    (22) var -> . datatype var1
    (4) program2 -> . procs main
    (5) program2 -> . main
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (6) procs -> . proc
    (7) procs -> . proc procs
    (113) main -> . MAIN { vars_aux statement_aux }
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >
    (8) proc -> . datatype procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (120) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    MAIN            shift and go to state 19
    SET             shift and go to state 20
    MAP             shift and go to state 21
    VOID            shift and go to state 22

  ! VOID            [ reduce using rule 120 (empty -> .) ]
  ! INT             [ reduce using rule 120 (empty -> .) ]
  ! FLOAT           [ reduce using rule 120 (empty -> .) ]
  ! BOOL            [ reduce using rule 120 (empty -> .) ]
  ! STRING          [ reduce using rule 120 (empty -> .) ]
  ! CHAR            [ reduce using rule 120 (empty -> .) ]
  ! SET             [ reduce using rule 120 (empty -> .) ]
  ! MAP             [ reduce using rule 120 (empty -> .) ]
  ! MAIN            [ reduce using rule 120 (empty -> .) ]

    program1                       shift and go to state 5
    var                            shift and go to state 6
    program2                       shift and go to state 7
    datatype                       shift and go to state 8
    procs                          shift and go to state 9
    main                           shift and go to state 10
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17
    proc                           shift and go to state 18
    empty                          shift and go to state 23

state 5

    (1) program -> PROGRAM ID ; program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID ; program1 .)


state 6

    (2) program1 -> var . program1
    (2) program1 -> . var program1
    (3) program1 -> . program2
    (22) var -> . datatype var1
    (4) program2 -> . procs main
    (5) program2 -> . main
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (6) procs -> . proc
    (7) procs -> . proc procs
    (113) main -> . MAIN { vars_aux statement_aux }
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >
    (8) proc -> . datatype procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (120) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    MAIN            shift and go to state 19
    SET             shift and go to state 20
    MAP             shift and go to state 21
    VOID            shift and go to state 22

  ! VOID            [ reduce using rule 120 (empty -> .) ]
  ! INT             [ reduce using rule 120 (empty -> .) ]
  ! FLOAT           [ reduce using rule 120 (empty -> .) ]
  ! BOOL            [ reduce using rule 120 (empty -> .) ]
  ! STRING          [ reduce using rule 120 (empty -> .) ]
  ! CHAR            [ reduce using rule 120 (empty -> .) ]
  ! SET             [ reduce using rule 120 (empty -> .) ]
  ! MAP             [ reduce using rule 120 (empty -> .) ]
  ! MAIN            [ reduce using rule 120 (empty -> .) ]

    var                            shift and go to state 6
    program1                       shift and go to state 24
    program2                       shift and go to state 7
    datatype                       shift and go to state 8
    procs                          shift and go to state 9
    main                           shift and go to state 10
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17
    proc                           shift and go to state 18
    empty                          shift and go to state 23

state 7

    (3) program1 -> program2 .

    $end            reduce using rule 3 (program1 -> program2 .)


state 8

    (22) var -> datatype . var1
    (8) proc -> datatype . procA
    (23) var1 -> . ID , var1
    (24) var1 -> . ID var2
    (11) procA -> . ID ( proc1 ) { proc3 }

    ID              shift and go to state 27

    var1                           shift and go to state 25
    procA                          shift and go to state 26

state 9

    (4) program2 -> procs . main
    (113) main -> . MAIN { vars_aux statement_aux }

    MAIN            shift and go to state 19

    main                           shift and go to state 28

state 10

    (5) program2 -> main .

    $end            reduce using rule 5 (program2 -> main .)


state 11

    (102) datatype -> INT .

    ID              reduce using rule 102 (datatype -> INT .)
    >               reduce using rule 102 (datatype -> INT .)
    ,               reduce using rule 102 (datatype -> INT .)


state 12

    (103) datatype -> FLOAT .

    ID              reduce using rule 103 (datatype -> FLOAT .)
    >               reduce using rule 103 (datatype -> FLOAT .)
    ,               reduce using rule 103 (datatype -> FLOAT .)


state 13

    (104) datatype -> BOOL .

    ID              reduce using rule 104 (datatype -> BOOL .)
    >               reduce using rule 104 (datatype -> BOOL .)
    ,               reduce using rule 104 (datatype -> BOOL .)


state 14

    (105) datatype -> STRING .

    ID              reduce using rule 105 (datatype -> STRING .)
    >               reduce using rule 105 (datatype -> STRING .)
    ,               reduce using rule 105 (datatype -> STRING .)


state 15

    (106) datatype -> CHAR .

    ID              reduce using rule 106 (datatype -> CHAR .)
    >               reduce using rule 106 (datatype -> CHAR .)
    ,               reduce using rule 106 (datatype -> CHAR .)


state 16

    (107) datatype -> set_definition .

    ID              reduce using rule 107 (datatype -> set_definition .)
    >               reduce using rule 107 (datatype -> set_definition .)
    ,               reduce using rule 107 (datatype -> set_definition .)


state 17

    (108) datatype -> map_definition .

    ID              reduce using rule 108 (datatype -> map_definition .)
    >               reduce using rule 108 (datatype -> map_definition .)
    ,               reduce using rule 108 (datatype -> map_definition .)


state 18

    (6) procs -> proc .
    (7) procs -> proc . procs
    (6) procs -> . proc
    (7) procs -> . proc procs
    (8) proc -> . datatype procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (120) empty -> .
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! reduce/reduce conflict for MAIN resolved using rule 6 (procs -> proc .)
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    MAIN            reduce using rule 6 (procs -> proc .)
    VOID            shift and go to state 22
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

  ! VOID            [ reduce using rule 120 (empty -> .) ]
  ! INT             [ reduce using rule 120 (empty -> .) ]
  ! FLOAT           [ reduce using rule 120 (empty -> .) ]
  ! BOOL            [ reduce using rule 120 (empty -> .) ]
  ! STRING          [ reduce using rule 120 (empty -> .) ]
  ! CHAR            [ reduce using rule 120 (empty -> .) ]
  ! SET             [ reduce using rule 120 (empty -> .) ]
  ! MAP             [ reduce using rule 120 (empty -> .) ]
  ! MAIN            [ reduce using rule 120 (empty -> .) ]

    proc                           shift and go to state 18
    procs                          shift and go to state 29
    datatype                       shift and go to state 30
    empty                          shift and go to state 23
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 19

    (113) main -> MAIN . { vars_aux statement_aux }

    {               shift and go to state 31


state 20

    (109) set_definition -> SET . < datatype >

    <               shift and go to state 32


state 21

    (116) map_definition -> MAP . < datatype , datatype >

    <               shift and go to state 33


state 22

    (9) proc -> VOID . procA
    (11) procA -> . ID ( proc1 ) { proc3 }

    ID              shift and go to state 35

    procA                          shift and go to state 34

state 23

    (10) proc -> empty .

    VOID            reduce using rule 10 (proc -> empty .)
    INT             reduce using rule 10 (proc -> empty .)
    FLOAT           reduce using rule 10 (proc -> empty .)
    BOOL            reduce using rule 10 (proc -> empty .)
    STRING          reduce using rule 10 (proc -> empty .)
    CHAR            reduce using rule 10 (proc -> empty .)
    SET             reduce using rule 10 (proc -> empty .)
    MAP             reduce using rule 10 (proc -> empty .)
    MAIN            reduce using rule 10 (proc -> empty .)


state 24

    (2) program1 -> var program1 .

    $end            reduce using rule 2 (program1 -> var program1 .)


state 25

    (22) var -> datatype var1 .

    INT             reduce using rule 22 (var -> datatype var1 .)
    FLOAT           reduce using rule 22 (var -> datatype var1 .)
    BOOL            reduce using rule 22 (var -> datatype var1 .)
    STRING          reduce using rule 22 (var -> datatype var1 .)
    CHAR            reduce using rule 22 (var -> datatype var1 .)
    MAIN            reduce using rule 22 (var -> datatype var1 .)
    SET             reduce using rule 22 (var -> datatype var1 .)
    MAP             reduce using rule 22 (var -> datatype var1 .)
    VOID            reduce using rule 22 (var -> datatype var1 .)
    ID              reduce using rule 22 (var -> datatype var1 .)
    READ            reduce using rule 22 (var -> datatype var1 .)
    PRINT           reduce using rule 22 (var -> datatype var1 .)
    RETURN          reduce using rule 22 (var -> datatype var1 .)
    IF              reduce using rule 22 (var -> datatype var1 .)
    WHILE           reduce using rule 22 (var -> datatype var1 .)
    }               reduce using rule 22 (var -> datatype var1 .)


state 26

    (8) proc -> datatype procA .

    VOID            reduce using rule 8 (proc -> datatype procA .)
    INT             reduce using rule 8 (proc -> datatype procA .)
    FLOAT           reduce using rule 8 (proc -> datatype procA .)
    BOOL            reduce using rule 8 (proc -> datatype procA .)
    STRING          reduce using rule 8 (proc -> datatype procA .)
    CHAR            reduce using rule 8 (proc -> datatype procA .)
    SET             reduce using rule 8 (proc -> datatype procA .)
    MAP             reduce using rule 8 (proc -> datatype procA .)
    MAIN            reduce using rule 8 (proc -> datatype procA .)


state 27

    (23) var1 -> ID . , var1
    (24) var1 -> ID . var2
    (11) procA -> ID . ( proc1 ) { proc3 }
    (25) var2 -> . ;

    ,               shift and go to state 36
    (               shift and go to state 38
    ;               shift and go to state 39

    var2                           shift and go to state 37

state 28

    (4) program2 -> procs main .

    $end            reduce using rule 4 (program2 -> procs main .)


state 29

    (7) procs -> proc procs .

    MAIN            reduce using rule 7 (procs -> proc procs .)


state 30

    (8) proc -> datatype . procA
    (11) procA -> . ID ( proc1 ) { proc3 }

    ID              shift and go to state 35

    procA                          shift and go to state 26

state 31

    (113) main -> MAIN { . vars_aux statement_aux }
    (114) vars_aux -> . vars
    (115) vars_aux -> . empty
    (20) vars -> . var vars
    (21) vars -> . var
    (120) empty -> .
    (22) var -> . datatype var1
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    ID              reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    PRINT           reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    }               reduce using rule 120 (empty -> .)
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

  ! MAP             [ reduce using rule 120 (empty -> .) ]

    vars_aux                       shift and go to state 40
    vars                           shift and go to state 41
    empty                          shift and go to state 42
    var                            shift and go to state 43
    datatype                       shift and go to state 44
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 32

    (109) set_definition -> SET < . datatype >
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

    datatype                       shift and go to state 45
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 33

    (116) map_definition -> MAP < . datatype , datatype >
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

    datatype                       shift and go to state 46
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 34

    (9) proc -> VOID procA .

    VOID            reduce using rule 9 (proc -> VOID procA .)
    INT             reduce using rule 9 (proc -> VOID procA .)
    FLOAT           reduce using rule 9 (proc -> VOID procA .)
    BOOL            reduce using rule 9 (proc -> VOID procA .)
    STRING          reduce using rule 9 (proc -> VOID procA .)
    CHAR            reduce using rule 9 (proc -> VOID procA .)
    SET             reduce using rule 9 (proc -> VOID procA .)
    MAP             reduce using rule 9 (proc -> VOID procA .)
    MAIN            reduce using rule 9 (proc -> VOID procA .)


state 35

    (11) procA -> ID . ( proc1 ) { proc3 }

    (               shift and go to state 38


state 36

    (23) var1 -> ID , . var1
    (23) var1 -> . ID , var1
    (24) var1 -> . ID var2

    ID              shift and go to state 47

    var1                           shift and go to state 48

state 37

    (24) var1 -> ID var2 .

    INT             reduce using rule 24 (var1 -> ID var2 .)
    FLOAT           reduce using rule 24 (var1 -> ID var2 .)
    BOOL            reduce using rule 24 (var1 -> ID var2 .)
    STRING          reduce using rule 24 (var1 -> ID var2 .)
    CHAR            reduce using rule 24 (var1 -> ID var2 .)
    MAIN            reduce using rule 24 (var1 -> ID var2 .)
    SET             reduce using rule 24 (var1 -> ID var2 .)
    MAP             reduce using rule 24 (var1 -> ID var2 .)
    VOID            reduce using rule 24 (var1 -> ID var2 .)
    ID              reduce using rule 24 (var1 -> ID var2 .)
    READ            reduce using rule 24 (var1 -> ID var2 .)
    PRINT           reduce using rule 24 (var1 -> ID var2 .)
    RETURN          reduce using rule 24 (var1 -> ID var2 .)
    IF              reduce using rule 24 (var1 -> ID var2 .)
    WHILE           reduce using rule 24 (var1 -> ID var2 .)
    }               reduce using rule 24 (var1 -> ID var2 .)


state 38

    (11) procA -> ID ( . proc1 ) { proc3 }
    (12) proc1 -> . datatype ID proc2
    (13) proc1 -> . empty
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (120) empty -> .
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    )               reduce using rule 120 (empty -> .)
    SET             shift and go to state 20
    MAP             shift and go to state 21

    proc1                          shift and go to state 49
    datatype                       shift and go to state 50
    empty                          shift and go to state 51
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 39

    (25) var2 -> ; .

    INT             reduce using rule 25 (var2 -> ; .)
    FLOAT           reduce using rule 25 (var2 -> ; .)
    BOOL            reduce using rule 25 (var2 -> ; .)
    STRING          reduce using rule 25 (var2 -> ; .)
    CHAR            reduce using rule 25 (var2 -> ; .)
    MAIN            reduce using rule 25 (var2 -> ; .)
    SET             reduce using rule 25 (var2 -> ; .)
    MAP             reduce using rule 25 (var2 -> ; .)
    VOID            reduce using rule 25 (var2 -> ; .)
    ID              reduce using rule 25 (var2 -> ; .)
    READ            reduce using rule 25 (var2 -> ; .)
    PRINT           reduce using rule 25 (var2 -> ; .)
    RETURN          reduce using rule 25 (var2 -> ; .)
    IF              reduce using rule 25 (var2 -> ; .)
    WHILE           reduce using rule 25 (var2 -> ; .)
    }               reduce using rule 25 (var2 -> ; .)


state 40

    (113) main -> MAIN { vars_aux . statement_aux }
    (111) statement_aux -> . statement statement_aux
    (112) statement_aux -> . empty
    (45) statement -> . statement1 ;
    (46) statement -> . statement2
    (120) empty -> .
    (47) statement1 -> . assignment
    (48) statement1 -> . input
    (49) statement1 -> . output
    (50) statement1 -> . set_operation
    (51) statement1 -> . map_definition
    (52) statement1 -> . return
    (53) statement1 -> . map_assignment
    (54) statement1 -> . map_operation
    (55) statement1 -> . function_call
    (56) statement2 -> . condition
    (57) statement2 -> . while
    (26) assignment -> . ID ASSIGNATOR expression
    (30) input -> . READ ( ID input1 )
    (33) output -> . PRINT ( expression output1 )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )
    (116) map_definition -> . MAP < datatype , datatype >
    (41) return -> . RETURN expression
    (118) map_assignment -> . map_access ASSIGNATOR exp
    (119) map_operation -> . ID . OPERATION ( )
    (36) function_call -> . ID ( function_call1 )
    (27) condition -> . IF ( expression ) block condition1
    (58) while -> . WHILE ( expression ) block
    (117) map_access -> . ID ( exp )

    }               reduce using rule 120 (empty -> .)
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    MAP             shift and go to state 21
    RETURN          shift and go to state 71
    IF              shift and go to state 73
    WHILE           shift and go to state 74

    statement_aux                  shift and go to state 52
    statement                      shift and go to state 53
    empty                          shift and go to state 54
    statement1                     shift and go to state 55
    statement2                     shift and go to state 56
    assignment                     shift and go to state 57
    input                          shift and go to state 58
    output                         shift and go to state 59
    set_operation                  shift and go to state 60
    map_definition                 shift and go to state 61
    return                         shift and go to state 62
    map_assignment                 shift and go to state 63
    map_operation                  shift and go to state 64
    function_call                  shift and go to state 65
    condition                      shift and go to state 66
    while                          shift and go to state 67
    map_access                     shift and go to state 72

state 41

    (114) vars_aux -> vars .

    ID              reduce using rule 114 (vars_aux -> vars .)
    READ            reduce using rule 114 (vars_aux -> vars .)
    PRINT           reduce using rule 114 (vars_aux -> vars .)
    MAP             reduce using rule 114 (vars_aux -> vars .)
    RETURN          reduce using rule 114 (vars_aux -> vars .)
    IF              reduce using rule 114 (vars_aux -> vars .)
    WHILE           reduce using rule 114 (vars_aux -> vars .)
    }               reduce using rule 114 (vars_aux -> vars .)


state 42

    (115) vars_aux -> empty .

    ID              reduce using rule 115 (vars_aux -> empty .)
    READ            reduce using rule 115 (vars_aux -> empty .)
    PRINT           reduce using rule 115 (vars_aux -> empty .)
    MAP             reduce using rule 115 (vars_aux -> empty .)
    RETURN          reduce using rule 115 (vars_aux -> empty .)
    IF              reduce using rule 115 (vars_aux -> empty .)
    WHILE           reduce using rule 115 (vars_aux -> empty .)
    }               reduce using rule 115 (vars_aux -> empty .)


state 43

    (20) vars -> var . vars
    (21) vars -> var .
    (20) vars -> . var vars
    (21) vars -> . var
    (22) var -> . datatype var1
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    ID              reduce using rule 21 (vars -> var .)
    READ            reduce using rule 21 (vars -> var .)
    PRINT           reduce using rule 21 (vars -> var .)
    RETURN          reduce using rule 21 (vars -> var .)
    IF              reduce using rule 21 (vars -> var .)
    WHILE           reduce using rule 21 (vars -> var .)
    }               reduce using rule 21 (vars -> var .)
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

  ! MAP             [ reduce using rule 21 (vars -> var .) ]

    var                            shift and go to state 43
    vars                           shift and go to state 75
    datatype                       shift and go to state 44
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 44

    (22) var -> datatype . var1
    (23) var1 -> . ID , var1
    (24) var1 -> . ID var2

    ID              shift and go to state 47

    var1                           shift and go to state 25

state 45

    (109) set_definition -> SET < datatype . >

    >               shift and go to state 76


state 46

    (116) map_definition -> MAP < datatype . , datatype >

    ,               shift and go to state 77


state 47

    (23) var1 -> ID . , var1
    (24) var1 -> ID . var2
    (25) var2 -> . ;

    ,               shift and go to state 36
    ;               shift and go to state 39

    var2                           shift and go to state 37

state 48

    (23) var1 -> ID , var1 .

    INT             reduce using rule 23 (var1 -> ID , var1 .)
    FLOAT           reduce using rule 23 (var1 -> ID , var1 .)
    BOOL            reduce using rule 23 (var1 -> ID , var1 .)
    STRING          reduce using rule 23 (var1 -> ID , var1 .)
    CHAR            reduce using rule 23 (var1 -> ID , var1 .)
    MAIN            reduce using rule 23 (var1 -> ID , var1 .)
    SET             reduce using rule 23 (var1 -> ID , var1 .)
    MAP             reduce using rule 23 (var1 -> ID , var1 .)
    VOID            reduce using rule 23 (var1 -> ID , var1 .)
    ID              reduce using rule 23 (var1 -> ID , var1 .)
    READ            reduce using rule 23 (var1 -> ID , var1 .)
    PRINT           reduce using rule 23 (var1 -> ID , var1 .)
    RETURN          reduce using rule 23 (var1 -> ID , var1 .)
    IF              reduce using rule 23 (var1 -> ID , var1 .)
    WHILE           reduce using rule 23 (var1 -> ID , var1 .)
    }               reduce using rule 23 (var1 -> ID , var1 .)


state 49

    (11) procA -> ID ( proc1 . ) { proc3 }

    )               shift and go to state 78


state 50

    (12) proc1 -> datatype . ID proc2

    ID              shift and go to state 79


state 51

    (13) proc1 -> empty .

    )               reduce using rule 13 (proc1 -> empty .)


state 52

    (113) main -> MAIN { vars_aux statement_aux . }

    }               shift and go to state 80


state 53

    (111) statement_aux -> statement . statement_aux
    (111) statement_aux -> . statement statement_aux
    (112) statement_aux -> . empty
    (45) statement -> . statement1 ;
    (46) statement -> . statement2
    (120) empty -> .
    (47) statement1 -> . assignment
    (48) statement1 -> . input
    (49) statement1 -> . output
    (50) statement1 -> . set_operation
    (51) statement1 -> . map_definition
    (52) statement1 -> . return
    (53) statement1 -> . map_assignment
    (54) statement1 -> . map_operation
    (55) statement1 -> . function_call
    (56) statement2 -> . condition
    (57) statement2 -> . while
    (26) assignment -> . ID ASSIGNATOR expression
    (30) input -> . READ ( ID input1 )
    (33) output -> . PRINT ( expression output1 )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )
    (116) map_definition -> . MAP < datatype , datatype >
    (41) return -> . RETURN expression
    (118) map_assignment -> . map_access ASSIGNATOR exp
    (119) map_operation -> . ID . OPERATION ( )
    (36) function_call -> . ID ( function_call1 )
    (27) condition -> . IF ( expression ) block condition1
    (58) while -> . WHILE ( expression ) block
    (117) map_access -> . ID ( exp )

    }               reduce using rule 120 (empty -> .)
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    MAP             shift and go to state 21
    RETURN          shift and go to state 71
    IF              shift and go to state 73
    WHILE           shift and go to state 74

    statement                      shift and go to state 53
    statement_aux                  shift and go to state 81
    empty                          shift and go to state 54
    statement1                     shift and go to state 55
    statement2                     shift and go to state 56
    assignment                     shift and go to state 57
    input                          shift and go to state 58
    output                         shift and go to state 59
    set_operation                  shift and go to state 60
    map_definition                 shift and go to state 61
    return                         shift and go to state 62
    map_assignment                 shift and go to state 63
    map_operation                  shift and go to state 64
    function_call                  shift and go to state 65
    condition                      shift and go to state 66
    while                          shift and go to state 67
    map_access                     shift and go to state 72

state 54

    (112) statement_aux -> empty .

    }               reduce using rule 112 (statement_aux -> empty .)


state 55

    (45) statement -> statement1 . ;

    ;               shift and go to state 82


state 56

    (46) statement -> statement2 .

    ID              reduce using rule 46 (statement -> statement2 .)
    READ            reduce using rule 46 (statement -> statement2 .)
    PRINT           reduce using rule 46 (statement -> statement2 .)
    MAP             reduce using rule 46 (statement -> statement2 .)
    RETURN          reduce using rule 46 (statement -> statement2 .)
    IF              reduce using rule 46 (statement -> statement2 .)
    WHILE           reduce using rule 46 (statement -> statement2 .)
    }               reduce using rule 46 (statement -> statement2 .)


state 57

    (47) statement1 -> assignment .

    ;               reduce using rule 47 (statement1 -> assignment .)


state 58

    (48) statement1 -> input .

    ;               reduce using rule 48 (statement1 -> input .)


state 59

    (49) statement1 -> output .

    ;               reduce using rule 49 (statement1 -> output .)


state 60

    (50) statement1 -> set_operation .

    ;               reduce using rule 50 (statement1 -> set_operation .)


state 61

    (51) statement1 -> map_definition .

    ;               reduce using rule 51 (statement1 -> map_definition .)


state 62

    (52) statement1 -> return .

    ;               reduce using rule 52 (statement1 -> return .)


state 63

    (53) statement1 -> map_assignment .

    ;               reduce using rule 53 (statement1 -> map_assignment .)


state 64

    (54) statement1 -> map_operation .

    ;               reduce using rule 54 (statement1 -> map_operation .)


state 65

    (55) statement1 -> function_call .

    ;               reduce using rule 55 (statement1 -> function_call .)


state 66

    (56) statement2 -> condition .

    ID              reduce using rule 56 (statement2 -> condition .)
    READ            reduce using rule 56 (statement2 -> condition .)
    PRINT           reduce using rule 56 (statement2 -> condition .)
    MAP             reduce using rule 56 (statement2 -> condition .)
    RETURN          reduce using rule 56 (statement2 -> condition .)
    IF              reduce using rule 56 (statement2 -> condition .)
    WHILE           reduce using rule 56 (statement2 -> condition .)
    }               reduce using rule 56 (statement2 -> condition .)


state 67

    (57) statement2 -> while .

    ID              reduce using rule 57 (statement2 -> while .)
    READ            reduce using rule 57 (statement2 -> while .)
    PRINT           reduce using rule 57 (statement2 -> while .)
    MAP             reduce using rule 57 (statement2 -> while .)
    RETURN          reduce using rule 57 (statement2 -> while .)
    IF              reduce using rule 57 (statement2 -> while .)
    WHILE           reduce using rule 57 (statement2 -> while .)
    }               reduce using rule 57 (statement2 -> while .)


state 68

    (26) assignment -> ID . ASSIGNATOR expression
    (42) set_operation -> ID . . OPERATION ( set_operation1 )
    (119) map_operation -> ID . . OPERATION ( )
    (36) function_call -> ID . ( function_call1 )
    (117) map_access -> ID . ( exp )

    ASSIGNATOR      shift and go to state 83
    .               shift and go to state 84
    (               shift and go to state 85


state 69

    (30) input -> READ . ( ID input1 )

    (               shift and go to state 86


state 70

    (33) output -> PRINT . ( expression output1 )

    (               shift and go to state 87


state 71

    (41) return -> RETURN . expression
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 88
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 72

    (118) map_assignment -> map_access . ASSIGNATOR exp

    ASSIGNATOR      shift and go to state 95


state 73

    (27) condition -> IF . ( expression ) block condition1

    (               shift and go to state 96


state 74

    (58) while -> WHILE . ( expression ) block

    (               shift and go to state 97


state 75

    (20) vars -> var vars .

    ID              reduce using rule 20 (vars -> var vars .)
    READ            reduce using rule 20 (vars -> var vars .)
    PRINT           reduce using rule 20 (vars -> var vars .)
    MAP             reduce using rule 20 (vars -> var vars .)
    RETURN          reduce using rule 20 (vars -> var vars .)
    IF              reduce using rule 20 (vars -> var vars .)
    WHILE           reduce using rule 20 (vars -> var vars .)
    }               reduce using rule 20 (vars -> var vars .)


state 76

    (109) set_definition -> SET < datatype > .

    ID              reduce using rule 109 (set_definition -> SET < datatype > .)
    >               reduce using rule 109 (set_definition -> SET < datatype > .)
    ,               reduce using rule 109 (set_definition -> SET < datatype > .)


state 77

    (116) map_definition -> MAP < datatype , . datatype >
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

    datatype                       shift and go to state 98
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 78

    (11) procA -> ID ( proc1 ) . { proc3 }

    {               shift and go to state 99


state 79

    (12) proc1 -> datatype ID . proc2
    (14) proc2 -> . , datatype ID proc2
    (15) proc2 -> . empty
    (120) empty -> .

    ,               shift and go to state 101
    )               reduce using rule 120 (empty -> .)

    proc2                          shift and go to state 100
    empty                          shift and go to state 102

state 80

    (113) main -> MAIN { vars_aux statement_aux } .

    $end            reduce using rule 113 (main -> MAIN { vars_aux statement_aux } .)


state 81

    (111) statement_aux -> statement statement_aux .

    }               reduce using rule 111 (statement_aux -> statement statement_aux .)


state 82

    (45) statement -> statement1 ; .

    ID              reduce using rule 45 (statement -> statement1 ; .)
    READ            reduce using rule 45 (statement -> statement1 ; .)
    PRINT           reduce using rule 45 (statement -> statement1 ; .)
    MAP             reduce using rule 45 (statement -> statement1 ; .)
    RETURN          reduce using rule 45 (statement -> statement1 ; .)
    IF              reduce using rule 45 (statement -> statement1 ; .)
    WHILE           reduce using rule 45 (statement -> statement1 ; .)
    }               reduce using rule 45 (statement -> statement1 ; .)


state 83

    (26) assignment -> ID ASSIGNATOR . expression
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 103
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 84

    (42) set_operation -> ID . . OPERATION ( set_operation1 )
    (119) map_operation -> ID . . OPERATION ( )

    OPERATION       shift and go to state 104


state 85

    (36) function_call -> ID ( . function_call1 )
    (117) map_access -> ID ( . exp )
    (37) function_call1 -> . function_call2
    (38) function_call1 -> . empty
    (73) exp -> . term exp2
    (39) function_call2 -> . expression , function_call2
    (40) function_call2 -> . empty
    (120) empty -> .
    (80) term -> . term_not factor term2
    (67) expression -> . exp0 expression2
    (83) term_not -> . !
    (84) term_not -> . empty
    (70) exp0 -> . exp exp02

    )               reduce using rule 120 (empty -> .)
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    !               shift and go to state 93

    function_call1                 shift and go to state 105
    exp                            shift and go to state 106
    function_call2                 shift and go to state 107
    empty                          shift and go to state 108
    term                           shift and go to state 91
    expression                     shift and go to state 109
    term_not                       shift and go to state 92
    exp0                           shift and go to state 89

state 86

    (30) input -> READ ( . ID input1 )

    ID              shift and go to state 110


state 87

    (33) output -> PRINT ( . expression output1 )
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 111
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 88

    (41) return -> RETURN expression .

    ;               reduce using rule 41 (return -> RETURN expression .)


state 89

    (67) expression -> exp0 . expression2
    (68) expression2 -> . logop exp0 expression2
    (69) expression2 -> . empty
    (65) logop -> . OR
    (66) logop -> . AND
    (120) empty -> .

    OR              shift and go to state 115
    AND             shift and go to state 116
    ;               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)

    expression2                    shift and go to state 112
    logop                          shift and go to state 113
    empty                          shift and go to state 114

state 90

    (70) exp0 -> exp . exp02
    (71) exp02 -> . relop exp0
    (72) exp02 -> . empty
    (59) relop -> . <
    (60) relop -> . >
    (61) relop -> . NOT_EQ
    (62) relop -> . EQ
    (63) relop -> . LEQ
    (64) relop -> . GEQ
    (120) empty -> .

    <               shift and go to state 120
    >               shift and go to state 121
    NOT_EQ          shift and go to state 122
    EQ              shift and go to state 123
    LEQ             shift and go to state 124
    GEQ             shift and go to state 125
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    ;               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)

    exp02                          shift and go to state 117
    relop                          shift and go to state 118
    empty                          shift and go to state 119

state 91

    (73) exp -> term . exp2
    (78) exp2 -> . addsub term exp2
    (79) exp2 -> . empty
    (74) addsub -> . +
    (75) addsub -> . -
    (120) empty -> .

    +               shift and go to state 129
    -               shift and go to state 130
    <               reduce using rule 120 (empty -> .)
    >               reduce using rule 120 (empty -> .)
    NOT_EQ          reduce using rule 120 (empty -> .)
    EQ              reduce using rule 120 (empty -> .)
    LEQ             reduce using rule 120 (empty -> .)
    GEQ             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    ;               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)

    exp2                           shift and go to state 126
    addsub                         shift and go to state 127
    empty                          shift and go to state 128

state 92

    (80) term -> term_not . factor term2
    (85) factor -> . ( expression )
    (86) factor -> . factor2
    (87) factor2 -> . factor3 varcte
    (88) factor3 -> . addsub
    (89) factor3 -> . empty
    (74) addsub -> . +
    (75) addsub -> . -
    (120) empty -> .

    (               shift and go to state 132
    +               shift and go to state 129
    -               shift and go to state 130
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    factor                         shift and go to state 131
    factor2                        shift and go to state 133
    factor3                        shift and go to state 134
    addsub                         shift and go to state 135
    empty                          shift and go to state 136

state 93

    (83) term_not -> ! .

    (               reduce using rule 83 (term_not -> ! .)
    +               reduce using rule 83 (term_not -> ! .)
    -               reduce using rule 83 (term_not -> ! .)
    ID              reduce using rule 83 (term_not -> ! .)
    CTE_INT         reduce using rule 83 (term_not -> ! .)
    CTE_FLOAT       reduce using rule 83 (term_not -> ! .)
    CTE_BOOL        reduce using rule 83 (term_not -> ! .)
    CTE_STRING      reduce using rule 83 (term_not -> ! .)
    CTE_CHAR        reduce using rule 83 (term_not -> ! .)


state 94

    (84) term_not -> empty .

    (               reduce using rule 84 (term_not -> empty .)
    +               reduce using rule 84 (term_not -> empty .)
    -               reduce using rule 84 (term_not -> empty .)
    ID              reduce using rule 84 (term_not -> empty .)
    CTE_INT         reduce using rule 84 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 84 (term_not -> empty .)
    CTE_BOOL        reduce using rule 84 (term_not -> empty .)
    CTE_STRING      reduce using rule 84 (term_not -> empty .)
    CTE_CHAR        reduce using rule 84 (term_not -> empty .)


state 95

    (118) map_assignment -> map_access ASSIGNATOR . exp
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    exp                            shift and go to state 137
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 96

    (27) condition -> IF ( . expression ) block condition1
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 138
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 97

    (58) while -> WHILE ( . expression ) block
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 139
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 98

    (116) map_definition -> MAP < datatype , datatype . >

    >               shift and go to state 140


state 99

    (11) procA -> ID ( proc1 ) { . proc3 }
    (16) proc3 -> . var proc3
    (17) proc3 -> . proc4
    (22) var -> . datatype var1
    (18) proc4 -> . statement proc4
    (19) proc4 -> . empty
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (45) statement -> . statement1 ;
    (46) statement -> . statement2
    (120) empty -> .
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >
    (47) statement1 -> . assignment
    (48) statement1 -> . input
    (49) statement1 -> . output
    (50) statement1 -> . set_operation
    (51) statement1 -> . map_definition
    (52) statement1 -> . return
    (53) statement1 -> . map_assignment
    (54) statement1 -> . map_operation
    (55) statement1 -> . function_call
    (56) statement2 -> . condition
    (57) statement2 -> . while
    (26) assignment -> . ID ASSIGNATOR expression
    (30) input -> . READ ( ID input1 )
    (33) output -> . PRINT ( expression output1 )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )
    (41) return -> . RETURN expression
    (118) map_assignment -> . map_access ASSIGNATOR exp
    (119) map_operation -> . ID . OPERATION ( )
    (36) function_call -> . ID ( function_call1 )
    (27) condition -> . IF ( expression ) block condition1
    (58) while -> . WHILE ( expression ) block
    (117) map_access -> . ID ( exp )

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    }               reduce using rule 120 (empty -> .)
    SET             shift and go to state 20
    MAP             shift and go to state 21
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    RETURN          shift and go to state 71
    IF              shift and go to state 73
    WHILE           shift and go to state 74

    proc3                          shift and go to state 141
    var                            shift and go to state 142
    proc4                          shift and go to state 143
    datatype                       shift and go to state 44
    statement                      shift and go to state 144
    empty                          shift and go to state 145
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 146
    statement1                     shift and go to state 55
    statement2                     shift and go to state 56
    assignment                     shift and go to state 57
    input                          shift and go to state 58
    output                         shift and go to state 59
    set_operation                  shift and go to state 60
    return                         shift and go to state 62
    map_assignment                 shift and go to state 63
    map_operation                  shift and go to state 64
    function_call                  shift and go to state 65
    condition                      shift and go to state 66
    while                          shift and go to state 67
    map_access                     shift and go to state 72

state 100

    (12) proc1 -> datatype ID proc2 .

    )               reduce using rule 12 (proc1 -> datatype ID proc2 .)


state 101

    (14) proc2 -> , . datatype ID proc2
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    SET             shift and go to state 20
    MAP             shift and go to state 21

    datatype                       shift and go to state 147
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 17

state 102

    (15) proc2 -> empty .

    )               reduce using rule 15 (proc2 -> empty .)


state 103

    (26) assignment -> ID ASSIGNATOR expression .

    ;               reduce using rule 26 (assignment -> ID ASSIGNATOR expression .)


state 104

    (42) set_operation -> ID . OPERATION . ( set_operation1 )
    (119) map_operation -> ID . OPERATION . ( )

    (               shift and go to state 148


state 105

    (36) function_call -> ID ( function_call1 . )

    )               shift and go to state 149


state 106

    (117) map_access -> ID ( exp . )
    (70) exp0 -> exp . exp02
    (71) exp02 -> . relop exp0
    (72) exp02 -> . empty
    (59) relop -> . <
    (60) relop -> . >
    (61) relop -> . NOT_EQ
    (62) relop -> . EQ
    (63) relop -> . LEQ
    (64) relop -> . GEQ
    (120) empty -> .

    )               shift and go to state 150
    <               shift and go to state 120
    >               shift and go to state 121
    NOT_EQ          shift and go to state 122
    EQ              shift and go to state 123
    LEQ             shift and go to state 124
    GEQ             shift and go to state 125
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)

    exp02                          shift and go to state 117
    relop                          shift and go to state 118
    empty                          shift and go to state 119

state 107

    (37) function_call1 -> function_call2 .

    )               reduce using rule 37 (function_call1 -> function_call2 .)


state 108

    (38) function_call1 -> empty .
    (40) function_call2 -> empty .
    (84) term_not -> empty .

  ! reduce/reduce conflict for ) resolved using rule 38 (function_call1 -> empty .)
    )               reduce using rule 38 (function_call1 -> empty .)
    (               reduce using rule 84 (term_not -> empty .)
    +               reduce using rule 84 (term_not -> empty .)
    -               reduce using rule 84 (term_not -> empty .)
    ID              reduce using rule 84 (term_not -> empty .)
    CTE_INT         reduce using rule 84 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 84 (term_not -> empty .)
    CTE_BOOL        reduce using rule 84 (term_not -> empty .)
    CTE_STRING      reduce using rule 84 (term_not -> empty .)
    CTE_CHAR        reduce using rule 84 (term_not -> empty .)

  ! )               [ reduce using rule 40 (function_call2 -> empty .) ]


state 109

    (39) function_call2 -> expression . , function_call2

    ,               shift and go to state 151


state 110

    (30) input -> READ ( ID . input1 )
    (31) input1 -> . , ID input1
    (32) input1 -> . empty
    (120) empty -> .

    ,               shift and go to state 153
    )               reduce using rule 120 (empty -> .)

    input1                         shift and go to state 152
    empty                          shift and go to state 154

state 111

    (33) output -> PRINT ( expression . output1 )
    (34) output1 -> . , expression output1
    (35) output1 -> . empty
    (120) empty -> .

    ,               shift and go to state 156
    )               reduce using rule 120 (empty -> .)

    output1                        shift and go to state 155
    empty                          shift and go to state 157

state 112

    (67) expression -> exp0 expression2 .

    ;               reduce using rule 67 (expression -> exp0 expression2 .)
    ,               reduce using rule 67 (expression -> exp0 expression2 .)
    )               reduce using rule 67 (expression -> exp0 expression2 .)


state 113

    (68) expression2 -> logop . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    exp0                           shift and go to state 158
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 114

    (69) expression2 -> empty .

    ;               reduce using rule 69 (expression2 -> empty .)
    ,               reduce using rule 69 (expression2 -> empty .)
    )               reduce using rule 69 (expression2 -> empty .)


state 115

    (65) logop -> OR .

    !               reduce using rule 65 (logop -> OR .)
    (               reduce using rule 65 (logop -> OR .)
    +               reduce using rule 65 (logop -> OR .)
    -               reduce using rule 65 (logop -> OR .)
    ID              reduce using rule 65 (logop -> OR .)
    CTE_INT         reduce using rule 65 (logop -> OR .)
    CTE_FLOAT       reduce using rule 65 (logop -> OR .)
    CTE_BOOL        reduce using rule 65 (logop -> OR .)
    CTE_STRING      reduce using rule 65 (logop -> OR .)
    CTE_CHAR        reduce using rule 65 (logop -> OR .)


state 116

    (66) logop -> AND .

    !               reduce using rule 66 (logop -> AND .)
    (               reduce using rule 66 (logop -> AND .)
    +               reduce using rule 66 (logop -> AND .)
    -               reduce using rule 66 (logop -> AND .)
    ID              reduce using rule 66 (logop -> AND .)
    CTE_INT         reduce using rule 66 (logop -> AND .)
    CTE_FLOAT       reduce using rule 66 (logop -> AND .)
    CTE_BOOL        reduce using rule 66 (logop -> AND .)
    CTE_STRING      reduce using rule 66 (logop -> AND .)
    CTE_CHAR        reduce using rule 66 (logop -> AND .)


state 117

    (70) exp0 -> exp exp02 .

    OR              reduce using rule 70 (exp0 -> exp exp02 .)
    AND             reduce using rule 70 (exp0 -> exp exp02 .)
    ;               reduce using rule 70 (exp0 -> exp exp02 .)
    ,               reduce using rule 70 (exp0 -> exp exp02 .)
    )               reduce using rule 70 (exp0 -> exp exp02 .)


state 118

    (71) exp02 -> relop . exp0
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    exp0                           shift and go to state 159
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 119

    (72) exp02 -> empty .

    OR              reduce using rule 72 (exp02 -> empty .)
    AND             reduce using rule 72 (exp02 -> empty .)
    ;               reduce using rule 72 (exp02 -> empty .)
    ,               reduce using rule 72 (exp02 -> empty .)
    )               reduce using rule 72 (exp02 -> empty .)


state 120

    (59) relop -> < .

    !               reduce using rule 59 (relop -> < .)
    (               reduce using rule 59 (relop -> < .)
    +               reduce using rule 59 (relop -> < .)
    -               reduce using rule 59 (relop -> < .)
    ID              reduce using rule 59 (relop -> < .)
    CTE_INT         reduce using rule 59 (relop -> < .)
    CTE_FLOAT       reduce using rule 59 (relop -> < .)
    CTE_BOOL        reduce using rule 59 (relop -> < .)
    CTE_STRING      reduce using rule 59 (relop -> < .)
    CTE_CHAR        reduce using rule 59 (relop -> < .)


state 121

    (60) relop -> > .

    !               reduce using rule 60 (relop -> > .)
    (               reduce using rule 60 (relop -> > .)
    +               reduce using rule 60 (relop -> > .)
    -               reduce using rule 60 (relop -> > .)
    ID              reduce using rule 60 (relop -> > .)
    CTE_INT         reduce using rule 60 (relop -> > .)
    CTE_FLOAT       reduce using rule 60 (relop -> > .)
    CTE_BOOL        reduce using rule 60 (relop -> > .)
    CTE_STRING      reduce using rule 60 (relop -> > .)
    CTE_CHAR        reduce using rule 60 (relop -> > .)


state 122

    (61) relop -> NOT_EQ .

    !               reduce using rule 61 (relop -> NOT_EQ .)
    (               reduce using rule 61 (relop -> NOT_EQ .)
    +               reduce using rule 61 (relop -> NOT_EQ .)
    -               reduce using rule 61 (relop -> NOT_EQ .)
    ID              reduce using rule 61 (relop -> NOT_EQ .)
    CTE_INT         reduce using rule 61 (relop -> NOT_EQ .)
    CTE_FLOAT       reduce using rule 61 (relop -> NOT_EQ .)
    CTE_BOOL        reduce using rule 61 (relop -> NOT_EQ .)
    CTE_STRING      reduce using rule 61 (relop -> NOT_EQ .)
    CTE_CHAR        reduce using rule 61 (relop -> NOT_EQ .)


state 123

    (62) relop -> EQ .

    !               reduce using rule 62 (relop -> EQ .)
    (               reduce using rule 62 (relop -> EQ .)
    +               reduce using rule 62 (relop -> EQ .)
    -               reduce using rule 62 (relop -> EQ .)
    ID              reduce using rule 62 (relop -> EQ .)
    CTE_INT         reduce using rule 62 (relop -> EQ .)
    CTE_FLOAT       reduce using rule 62 (relop -> EQ .)
    CTE_BOOL        reduce using rule 62 (relop -> EQ .)
    CTE_STRING      reduce using rule 62 (relop -> EQ .)
    CTE_CHAR        reduce using rule 62 (relop -> EQ .)


state 124

    (63) relop -> LEQ .

    !               reduce using rule 63 (relop -> LEQ .)
    (               reduce using rule 63 (relop -> LEQ .)
    +               reduce using rule 63 (relop -> LEQ .)
    -               reduce using rule 63 (relop -> LEQ .)
    ID              reduce using rule 63 (relop -> LEQ .)
    CTE_INT         reduce using rule 63 (relop -> LEQ .)
    CTE_FLOAT       reduce using rule 63 (relop -> LEQ .)
    CTE_BOOL        reduce using rule 63 (relop -> LEQ .)
    CTE_STRING      reduce using rule 63 (relop -> LEQ .)
    CTE_CHAR        reduce using rule 63 (relop -> LEQ .)


state 125

    (64) relop -> GEQ .

    !               reduce using rule 64 (relop -> GEQ .)
    (               reduce using rule 64 (relop -> GEQ .)
    +               reduce using rule 64 (relop -> GEQ .)
    -               reduce using rule 64 (relop -> GEQ .)
    ID              reduce using rule 64 (relop -> GEQ .)
    CTE_INT         reduce using rule 64 (relop -> GEQ .)
    CTE_FLOAT       reduce using rule 64 (relop -> GEQ .)
    CTE_BOOL        reduce using rule 64 (relop -> GEQ .)
    CTE_STRING      reduce using rule 64 (relop -> GEQ .)
    CTE_CHAR        reduce using rule 64 (relop -> GEQ .)


state 126

    (73) exp -> term exp2 .

    <               reduce using rule 73 (exp -> term exp2 .)
    >               reduce using rule 73 (exp -> term exp2 .)
    NOT_EQ          reduce using rule 73 (exp -> term exp2 .)
    EQ              reduce using rule 73 (exp -> term exp2 .)
    LEQ             reduce using rule 73 (exp -> term exp2 .)
    GEQ             reduce using rule 73 (exp -> term exp2 .)
    OR              reduce using rule 73 (exp -> term exp2 .)
    AND             reduce using rule 73 (exp -> term exp2 .)
    ;               reduce using rule 73 (exp -> term exp2 .)
    )               reduce using rule 73 (exp -> term exp2 .)
    ,               reduce using rule 73 (exp -> term exp2 .)


state 127

    (78) exp2 -> addsub . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    term                           shift and go to state 160
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 128

    (79) exp2 -> empty .

    <               reduce using rule 79 (exp2 -> empty .)
    >               reduce using rule 79 (exp2 -> empty .)
    NOT_EQ          reduce using rule 79 (exp2 -> empty .)
    EQ              reduce using rule 79 (exp2 -> empty .)
    LEQ             reduce using rule 79 (exp2 -> empty .)
    GEQ             reduce using rule 79 (exp2 -> empty .)
    OR              reduce using rule 79 (exp2 -> empty .)
    AND             reduce using rule 79 (exp2 -> empty .)
    ;               reduce using rule 79 (exp2 -> empty .)
    )               reduce using rule 79 (exp2 -> empty .)
    ,               reduce using rule 79 (exp2 -> empty .)


state 129

    (74) addsub -> + .

    !               reduce using rule 74 (addsub -> + .)
    (               reduce using rule 74 (addsub -> + .)
    +               reduce using rule 74 (addsub -> + .)
    -               reduce using rule 74 (addsub -> + .)
    ID              reduce using rule 74 (addsub -> + .)
    CTE_INT         reduce using rule 74 (addsub -> + .)
    CTE_FLOAT       reduce using rule 74 (addsub -> + .)
    CTE_BOOL        reduce using rule 74 (addsub -> + .)
    CTE_STRING      reduce using rule 74 (addsub -> + .)
    CTE_CHAR        reduce using rule 74 (addsub -> + .)


state 130

    (75) addsub -> - .

    !               reduce using rule 75 (addsub -> - .)
    (               reduce using rule 75 (addsub -> - .)
    +               reduce using rule 75 (addsub -> - .)
    -               reduce using rule 75 (addsub -> - .)
    ID              reduce using rule 75 (addsub -> - .)
    CTE_INT         reduce using rule 75 (addsub -> - .)
    CTE_FLOAT       reduce using rule 75 (addsub -> - .)
    CTE_BOOL        reduce using rule 75 (addsub -> - .)
    CTE_STRING      reduce using rule 75 (addsub -> - .)
    CTE_CHAR        reduce using rule 75 (addsub -> - .)


state 131

    (80) term -> term_not factor . term2
    (81) term2 -> . muldiv factor term2
    (82) term2 -> . empty
    (76) muldiv -> . *
    (77) muldiv -> . /
    (120) empty -> .

    *               shift and go to state 164
    /               shift and go to state 165
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    <               reduce using rule 120 (empty -> .)
    >               reduce using rule 120 (empty -> .)
    NOT_EQ          reduce using rule 120 (empty -> .)
    EQ              reduce using rule 120 (empty -> .)
    LEQ             reduce using rule 120 (empty -> .)
    GEQ             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    ;               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)

    term2                          shift and go to state 161
    muldiv                         shift and go to state 162
    empty                          shift and go to state 163

state 132

    (85) factor -> ( . expression )
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 166
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 133

    (86) factor -> factor2 .

    *               reduce using rule 86 (factor -> factor2 .)
    /               reduce using rule 86 (factor -> factor2 .)
    +               reduce using rule 86 (factor -> factor2 .)
    -               reduce using rule 86 (factor -> factor2 .)
    <               reduce using rule 86 (factor -> factor2 .)
    >               reduce using rule 86 (factor -> factor2 .)
    NOT_EQ          reduce using rule 86 (factor -> factor2 .)
    EQ              reduce using rule 86 (factor -> factor2 .)
    LEQ             reduce using rule 86 (factor -> factor2 .)
    GEQ             reduce using rule 86 (factor -> factor2 .)
    OR              reduce using rule 86 (factor -> factor2 .)
    AND             reduce using rule 86 (factor -> factor2 .)
    ;               reduce using rule 86 (factor -> factor2 .)
    )               reduce using rule 86 (factor -> factor2 .)
    ,               reduce using rule 86 (factor -> factor2 .)


state 134

    (87) factor2 -> factor3 . varcte
    (90) varcte -> . ID
    (91) varcte -> . CTE_INT
    (92) varcte -> . CTE_FLOAT
    (93) varcte -> . CTE_BOOL
    (94) varcte -> . CTE_STRING
    (95) varcte -> . CTE_CHAR
    (96) varcte -> . function_call
    (97) varcte -> . map_access
    (98) varcte -> . map_operation
    (99) varcte -> . set_operation
    (36) function_call -> . ID ( function_call1 )
    (117) map_access -> . ID ( exp )
    (119) map_operation -> . ID . OPERATION ( )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )

    ID              shift and go to state 168
    CTE_INT         shift and go to state 169
    CTE_FLOAT       shift and go to state 170
    CTE_BOOL        shift and go to state 171
    CTE_STRING      shift and go to state 172
    CTE_CHAR        shift and go to state 173

    varcte                         shift and go to state 167
    function_call                  shift and go to state 174
    map_access                     shift and go to state 175
    map_operation                  shift and go to state 176
    set_operation                  shift and go to state 177

state 135

    (88) factor3 -> addsub .

    ID              reduce using rule 88 (factor3 -> addsub .)
    CTE_INT         reduce using rule 88 (factor3 -> addsub .)
    CTE_FLOAT       reduce using rule 88 (factor3 -> addsub .)
    CTE_BOOL        reduce using rule 88 (factor3 -> addsub .)
    CTE_STRING      reduce using rule 88 (factor3 -> addsub .)
    CTE_CHAR        reduce using rule 88 (factor3 -> addsub .)


state 136

    (89) factor3 -> empty .

    ID              reduce using rule 89 (factor3 -> empty .)
    CTE_INT         reduce using rule 89 (factor3 -> empty .)
    CTE_FLOAT       reduce using rule 89 (factor3 -> empty .)
    CTE_BOOL        reduce using rule 89 (factor3 -> empty .)
    CTE_STRING      reduce using rule 89 (factor3 -> empty .)
    CTE_CHAR        reduce using rule 89 (factor3 -> empty .)


state 137

    (118) map_assignment -> map_access ASSIGNATOR exp .

    ;               reduce using rule 118 (map_assignment -> map_access ASSIGNATOR exp .)


state 138

    (27) condition -> IF ( expression . ) block condition1

    )               shift and go to state 178


state 139

    (58) while -> WHILE ( expression . ) block

    )               shift and go to state 179


state 140

    (116) map_definition -> MAP < datatype , datatype > .

    ID              reduce using rule 116 (map_definition -> MAP < datatype , datatype > .)
    >               reduce using rule 116 (map_definition -> MAP < datatype , datatype > .)
    ,               reduce using rule 116 (map_definition -> MAP < datatype , datatype > .)
    ;               reduce using rule 116 (map_definition -> MAP < datatype , datatype > .)


state 141

    (11) procA -> ID ( proc1 ) { proc3 . }

    }               shift and go to state 180


state 142

    (16) proc3 -> var . proc3
    (16) proc3 -> . var proc3
    (17) proc3 -> . proc4
    (22) var -> . datatype var1
    (18) proc4 -> . statement proc4
    (19) proc4 -> . empty
    (102) datatype -> . INT
    (103) datatype -> . FLOAT
    (104) datatype -> . BOOL
    (105) datatype -> . STRING
    (106) datatype -> . CHAR
    (107) datatype -> . set_definition
    (108) datatype -> . map_definition
    (45) statement -> . statement1 ;
    (46) statement -> . statement2
    (120) empty -> .
    (109) set_definition -> . SET < datatype >
    (116) map_definition -> . MAP < datatype , datatype >
    (47) statement1 -> . assignment
    (48) statement1 -> . input
    (49) statement1 -> . output
    (50) statement1 -> . set_operation
    (51) statement1 -> . map_definition
    (52) statement1 -> . return
    (53) statement1 -> . map_assignment
    (54) statement1 -> . map_operation
    (55) statement1 -> . function_call
    (56) statement2 -> . condition
    (57) statement2 -> . while
    (26) assignment -> . ID ASSIGNATOR expression
    (30) input -> . READ ( ID input1 )
    (33) output -> . PRINT ( expression output1 )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )
    (41) return -> . RETURN expression
    (118) map_assignment -> . map_access ASSIGNATOR exp
    (119) map_operation -> . ID . OPERATION ( )
    (36) function_call -> . ID ( function_call1 )
    (27) condition -> . IF ( expression ) block condition1
    (58) while -> . WHILE ( expression ) block
    (117) map_access -> . ID ( exp )

    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    BOOL            shift and go to state 13
    STRING          shift and go to state 14
    CHAR            shift and go to state 15
    }               reduce using rule 120 (empty -> .)
    SET             shift and go to state 20
    MAP             shift and go to state 21
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    RETURN          shift and go to state 71
    IF              shift and go to state 73
    WHILE           shift and go to state 74

    var                            shift and go to state 142
    proc3                          shift and go to state 181
    proc4                          shift and go to state 143
    datatype                       shift and go to state 44
    statement                      shift and go to state 144
    empty                          shift and go to state 145
    set_definition                 shift and go to state 16
    map_definition                 shift and go to state 146
    statement1                     shift and go to state 55
    statement2                     shift and go to state 56
    assignment                     shift and go to state 57
    input                          shift and go to state 58
    output                         shift and go to state 59
    set_operation                  shift and go to state 60
    return                         shift and go to state 62
    map_assignment                 shift and go to state 63
    map_operation                  shift and go to state 64
    function_call                  shift and go to state 65
    condition                      shift and go to state 66
    while                          shift and go to state 67
    map_access                     shift and go to state 72

state 143

    (17) proc3 -> proc4 .

    }               reduce using rule 17 (proc3 -> proc4 .)


state 144

    (18) proc4 -> statement . proc4
    (18) proc4 -> . statement proc4
    (19) proc4 -> . empty
    (45) statement -> . statement1 ;
    (46) statement -> . statement2
    (120) empty -> .
    (47) statement1 -> . assignment
    (48) statement1 -> . input
    (49) statement1 -> . output
    (50) statement1 -> . set_operation
    (51) statement1 -> . map_definition
    (52) statement1 -> . return
    (53) statement1 -> . map_assignment
    (54) statement1 -> . map_operation
    (55) statement1 -> . function_call
    (56) statement2 -> . condition
    (57) statement2 -> . while
    (26) assignment -> . ID ASSIGNATOR expression
    (30) input -> . READ ( ID input1 )
    (33) output -> . PRINT ( expression output1 )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )
    (116) map_definition -> . MAP < datatype , datatype >
    (41) return -> . RETURN expression
    (118) map_assignment -> . map_access ASSIGNATOR exp
    (119) map_operation -> . ID . OPERATION ( )
    (36) function_call -> . ID ( function_call1 )
    (27) condition -> . IF ( expression ) block condition1
    (58) while -> . WHILE ( expression ) block
    (117) map_access -> . ID ( exp )

    }               reduce using rule 120 (empty -> .)
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    MAP             shift and go to state 21
    RETURN          shift and go to state 71
    IF              shift and go to state 73
    WHILE           shift and go to state 74

    statement                      shift and go to state 144
    proc4                          shift and go to state 182
    empty                          shift and go to state 145
    statement1                     shift and go to state 55
    statement2                     shift and go to state 56
    assignment                     shift and go to state 57
    input                          shift and go to state 58
    output                         shift and go to state 59
    set_operation                  shift and go to state 60
    map_definition                 shift and go to state 61
    return                         shift and go to state 62
    map_assignment                 shift and go to state 63
    map_operation                  shift and go to state 64
    function_call                  shift and go to state 65
    condition                      shift and go to state 66
    while                          shift and go to state 67
    map_access                     shift and go to state 72

state 145

    (19) proc4 -> empty .

    }               reduce using rule 19 (proc4 -> empty .)


state 146

    (108) datatype -> map_definition .
    (51) statement1 -> map_definition .

    ID              reduce using rule 108 (datatype -> map_definition .)
    ;               reduce using rule 51 (statement1 -> map_definition .)


state 147

    (14) proc2 -> , datatype . ID proc2

    ID              shift and go to state 183


state 148

    (42) set_operation -> ID . OPERATION ( . set_operation1 )
    (119) map_operation -> ID . OPERATION ( . )
    (43) set_operation1 -> . expression
    (44) set_operation1 -> . empty
    (67) expression -> . exp0 expression2
    (120) empty -> .
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 185
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    !               shift and go to state 93

  ! )               [ reduce using rule 120 (empty -> .) ]

    set_operation1                 shift and go to state 184
    expression                     shift and go to state 186
    empty                          shift and go to state 187
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92

state 149

    (36) function_call -> ID ( function_call1 ) .

    ;               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    *               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    /               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    +               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    -               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    <               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    >               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    NOT_EQ          reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    EQ              reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    LEQ             reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    GEQ             reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    OR              reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    AND             reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    )               reduce using rule 36 (function_call -> ID ( function_call1 ) .)
    ,               reduce using rule 36 (function_call -> ID ( function_call1 ) .)


state 150

    (117) map_access -> ID ( exp ) .

    ASSIGNATOR      reduce using rule 117 (map_access -> ID ( exp ) .)
    *               reduce using rule 117 (map_access -> ID ( exp ) .)
    /               reduce using rule 117 (map_access -> ID ( exp ) .)
    +               reduce using rule 117 (map_access -> ID ( exp ) .)
    -               reduce using rule 117 (map_access -> ID ( exp ) .)
    <               reduce using rule 117 (map_access -> ID ( exp ) .)
    >               reduce using rule 117 (map_access -> ID ( exp ) .)
    NOT_EQ          reduce using rule 117 (map_access -> ID ( exp ) .)
    EQ              reduce using rule 117 (map_access -> ID ( exp ) .)
    LEQ             reduce using rule 117 (map_access -> ID ( exp ) .)
    GEQ             reduce using rule 117 (map_access -> ID ( exp ) .)
    OR              reduce using rule 117 (map_access -> ID ( exp ) .)
    AND             reduce using rule 117 (map_access -> ID ( exp ) .)
    ;               reduce using rule 117 (map_access -> ID ( exp ) .)
    )               reduce using rule 117 (map_access -> ID ( exp ) .)
    ,               reduce using rule 117 (map_access -> ID ( exp ) .)


state 151

    (39) function_call2 -> expression , . function_call2
    (39) function_call2 -> . expression , function_call2
    (40) function_call2 -> . empty
    (67) expression -> . exp0 expression2
    (120) empty -> .
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty

    )               reduce using rule 120 (empty -> .)
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    !               shift and go to state 93

    expression                     shift and go to state 109
    function_call2                 shift and go to state 188
    empty                          shift and go to state 189
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92

state 152

    (30) input -> READ ( ID input1 . )

    )               shift and go to state 190


state 153

    (31) input1 -> , . ID input1

    ID              shift and go to state 191


state 154

    (32) input1 -> empty .

    )               reduce using rule 32 (input1 -> empty .)


state 155

    (33) output -> PRINT ( expression output1 . )

    )               shift and go to state 192


state 156

    (34) output1 -> , . expression output1
    (67) expression -> . exp0 expression2
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty
    (120) empty -> .

    !               shift and go to state 93
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    expression                     shift and go to state 193
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92
    empty                          shift and go to state 94

state 157

    (35) output1 -> empty .

    )               reduce using rule 35 (output1 -> empty .)


state 158

    (68) expression2 -> logop exp0 . expression2
    (68) expression2 -> . logop exp0 expression2
    (69) expression2 -> . empty
    (65) logop -> . OR
    (66) logop -> . AND
    (120) empty -> .

    OR              shift and go to state 115
    AND             shift and go to state 116
    ;               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)

    logop                          shift and go to state 113
    expression2                    shift and go to state 194
    empty                          shift and go to state 114

state 159

    (71) exp02 -> relop exp0 .

    OR              reduce using rule 71 (exp02 -> relop exp0 .)
    AND             reduce using rule 71 (exp02 -> relop exp0 .)
    ;               reduce using rule 71 (exp02 -> relop exp0 .)
    ,               reduce using rule 71 (exp02 -> relop exp0 .)
    )               reduce using rule 71 (exp02 -> relop exp0 .)


state 160

    (78) exp2 -> addsub term . exp2
    (78) exp2 -> . addsub term exp2
    (79) exp2 -> . empty
    (74) addsub -> . +
    (75) addsub -> . -
    (120) empty -> .

    +               shift and go to state 129
    -               shift and go to state 130
    <               reduce using rule 120 (empty -> .)
    >               reduce using rule 120 (empty -> .)
    NOT_EQ          reduce using rule 120 (empty -> .)
    EQ              reduce using rule 120 (empty -> .)
    LEQ             reduce using rule 120 (empty -> .)
    GEQ             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    ;               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)

    addsub                         shift and go to state 127
    exp2                           shift and go to state 195
    empty                          shift and go to state 128

state 161

    (80) term -> term_not factor term2 .

    +               reduce using rule 80 (term -> term_not factor term2 .)
    -               reduce using rule 80 (term -> term_not factor term2 .)
    <               reduce using rule 80 (term -> term_not factor term2 .)
    >               reduce using rule 80 (term -> term_not factor term2 .)
    NOT_EQ          reduce using rule 80 (term -> term_not factor term2 .)
    EQ              reduce using rule 80 (term -> term_not factor term2 .)
    LEQ             reduce using rule 80 (term -> term_not factor term2 .)
    GEQ             reduce using rule 80 (term -> term_not factor term2 .)
    OR              reduce using rule 80 (term -> term_not factor term2 .)
    AND             reduce using rule 80 (term -> term_not factor term2 .)
    ;               reduce using rule 80 (term -> term_not factor term2 .)
    )               reduce using rule 80 (term -> term_not factor term2 .)
    ,               reduce using rule 80 (term -> term_not factor term2 .)


state 162

    (81) term2 -> muldiv . factor term2
    (85) factor -> . ( expression )
    (86) factor -> . factor2
    (87) factor2 -> . factor3 varcte
    (88) factor3 -> . addsub
    (89) factor3 -> . empty
    (74) addsub -> . +
    (75) addsub -> . -
    (120) empty -> .

    (               shift and go to state 132
    +               shift and go to state 129
    -               shift and go to state 130
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)

    factor                         shift and go to state 196
    factor2                        shift and go to state 133
    factor3                        shift and go to state 134
    addsub                         shift and go to state 135
    empty                          shift and go to state 136

state 163

    (82) term2 -> empty .

    +               reduce using rule 82 (term2 -> empty .)
    -               reduce using rule 82 (term2 -> empty .)
    <               reduce using rule 82 (term2 -> empty .)
    >               reduce using rule 82 (term2 -> empty .)
    NOT_EQ          reduce using rule 82 (term2 -> empty .)
    EQ              reduce using rule 82 (term2 -> empty .)
    LEQ             reduce using rule 82 (term2 -> empty .)
    GEQ             reduce using rule 82 (term2 -> empty .)
    OR              reduce using rule 82 (term2 -> empty .)
    AND             reduce using rule 82 (term2 -> empty .)
    ;               reduce using rule 82 (term2 -> empty .)
    )               reduce using rule 82 (term2 -> empty .)
    ,               reduce using rule 82 (term2 -> empty .)


state 164

    (76) muldiv -> * .

    (               reduce using rule 76 (muldiv -> * .)
    +               reduce using rule 76 (muldiv -> * .)
    -               reduce using rule 76 (muldiv -> * .)
    ID              reduce using rule 76 (muldiv -> * .)
    CTE_INT         reduce using rule 76 (muldiv -> * .)
    CTE_FLOAT       reduce using rule 76 (muldiv -> * .)
    CTE_BOOL        reduce using rule 76 (muldiv -> * .)
    CTE_STRING      reduce using rule 76 (muldiv -> * .)
    CTE_CHAR        reduce using rule 76 (muldiv -> * .)


state 165

    (77) muldiv -> / .

    (               reduce using rule 77 (muldiv -> / .)
    +               reduce using rule 77 (muldiv -> / .)
    -               reduce using rule 77 (muldiv -> / .)
    ID              reduce using rule 77 (muldiv -> / .)
    CTE_INT         reduce using rule 77 (muldiv -> / .)
    CTE_FLOAT       reduce using rule 77 (muldiv -> / .)
    CTE_BOOL        reduce using rule 77 (muldiv -> / .)
    CTE_STRING      reduce using rule 77 (muldiv -> / .)
    CTE_CHAR        reduce using rule 77 (muldiv -> / .)


state 166

    (85) factor -> ( expression . )

    )               shift and go to state 197


state 167

    (87) factor2 -> factor3 varcte .

    *               reduce using rule 87 (factor2 -> factor3 varcte .)
    /               reduce using rule 87 (factor2 -> factor3 varcte .)
    +               reduce using rule 87 (factor2 -> factor3 varcte .)
    -               reduce using rule 87 (factor2 -> factor3 varcte .)
    <               reduce using rule 87 (factor2 -> factor3 varcte .)
    >               reduce using rule 87 (factor2 -> factor3 varcte .)
    NOT_EQ          reduce using rule 87 (factor2 -> factor3 varcte .)
    EQ              reduce using rule 87 (factor2 -> factor3 varcte .)
    LEQ             reduce using rule 87 (factor2 -> factor3 varcte .)
    GEQ             reduce using rule 87 (factor2 -> factor3 varcte .)
    OR              reduce using rule 87 (factor2 -> factor3 varcte .)
    AND             reduce using rule 87 (factor2 -> factor3 varcte .)
    ;               reduce using rule 87 (factor2 -> factor3 varcte .)
    )               reduce using rule 87 (factor2 -> factor3 varcte .)
    ,               reduce using rule 87 (factor2 -> factor3 varcte .)


state 168

    (90) varcte -> ID .
    (36) function_call -> ID . ( function_call1 )
    (117) map_access -> ID . ( exp )
    (119) map_operation -> ID . . OPERATION ( )
    (42) set_operation -> ID . . OPERATION ( set_operation1 )

    *               reduce using rule 90 (varcte -> ID .)
    /               reduce using rule 90 (varcte -> ID .)
    +               reduce using rule 90 (varcte -> ID .)
    -               reduce using rule 90 (varcte -> ID .)
    <               reduce using rule 90 (varcte -> ID .)
    >               reduce using rule 90 (varcte -> ID .)
    NOT_EQ          reduce using rule 90 (varcte -> ID .)
    EQ              reduce using rule 90 (varcte -> ID .)
    LEQ             reduce using rule 90 (varcte -> ID .)
    GEQ             reduce using rule 90 (varcte -> ID .)
    OR              reduce using rule 90 (varcte -> ID .)
    AND             reduce using rule 90 (varcte -> ID .)
    ;               reduce using rule 90 (varcte -> ID .)
    )               reduce using rule 90 (varcte -> ID .)
    ,               reduce using rule 90 (varcte -> ID .)
    (               shift and go to state 85
    .               shift and go to state 198


state 169

    (91) varcte -> CTE_INT .

    *               reduce using rule 91 (varcte -> CTE_INT .)
    /               reduce using rule 91 (varcte -> CTE_INT .)
    +               reduce using rule 91 (varcte -> CTE_INT .)
    -               reduce using rule 91 (varcte -> CTE_INT .)
    <               reduce using rule 91 (varcte -> CTE_INT .)
    >               reduce using rule 91 (varcte -> CTE_INT .)
    NOT_EQ          reduce using rule 91 (varcte -> CTE_INT .)
    EQ              reduce using rule 91 (varcte -> CTE_INT .)
    LEQ             reduce using rule 91 (varcte -> CTE_INT .)
    GEQ             reduce using rule 91 (varcte -> CTE_INT .)
    OR              reduce using rule 91 (varcte -> CTE_INT .)
    AND             reduce using rule 91 (varcte -> CTE_INT .)
    ;               reduce using rule 91 (varcte -> CTE_INT .)
    )               reduce using rule 91 (varcte -> CTE_INT .)
    ,               reduce using rule 91 (varcte -> CTE_INT .)


state 170

    (92) varcte -> CTE_FLOAT .

    *               reduce using rule 92 (varcte -> CTE_FLOAT .)
    /               reduce using rule 92 (varcte -> CTE_FLOAT .)
    +               reduce using rule 92 (varcte -> CTE_FLOAT .)
    -               reduce using rule 92 (varcte -> CTE_FLOAT .)
    <               reduce using rule 92 (varcte -> CTE_FLOAT .)
    >               reduce using rule 92 (varcte -> CTE_FLOAT .)
    NOT_EQ          reduce using rule 92 (varcte -> CTE_FLOAT .)
    EQ              reduce using rule 92 (varcte -> CTE_FLOAT .)
    LEQ             reduce using rule 92 (varcte -> CTE_FLOAT .)
    GEQ             reduce using rule 92 (varcte -> CTE_FLOAT .)
    OR              reduce using rule 92 (varcte -> CTE_FLOAT .)
    AND             reduce using rule 92 (varcte -> CTE_FLOAT .)
    ;               reduce using rule 92 (varcte -> CTE_FLOAT .)
    )               reduce using rule 92 (varcte -> CTE_FLOAT .)
    ,               reduce using rule 92 (varcte -> CTE_FLOAT .)


state 171

    (93) varcte -> CTE_BOOL .

    *               reduce using rule 93 (varcte -> CTE_BOOL .)
    /               reduce using rule 93 (varcte -> CTE_BOOL .)
    +               reduce using rule 93 (varcte -> CTE_BOOL .)
    -               reduce using rule 93 (varcte -> CTE_BOOL .)
    <               reduce using rule 93 (varcte -> CTE_BOOL .)
    >               reduce using rule 93 (varcte -> CTE_BOOL .)
    NOT_EQ          reduce using rule 93 (varcte -> CTE_BOOL .)
    EQ              reduce using rule 93 (varcte -> CTE_BOOL .)
    LEQ             reduce using rule 93 (varcte -> CTE_BOOL .)
    GEQ             reduce using rule 93 (varcte -> CTE_BOOL .)
    OR              reduce using rule 93 (varcte -> CTE_BOOL .)
    AND             reduce using rule 93 (varcte -> CTE_BOOL .)
    ;               reduce using rule 93 (varcte -> CTE_BOOL .)
    )               reduce using rule 93 (varcte -> CTE_BOOL .)
    ,               reduce using rule 93 (varcte -> CTE_BOOL .)


state 172

    (94) varcte -> CTE_STRING .

    *               reduce using rule 94 (varcte -> CTE_STRING .)
    /               reduce using rule 94 (varcte -> CTE_STRING .)
    +               reduce using rule 94 (varcte -> CTE_STRING .)
    -               reduce using rule 94 (varcte -> CTE_STRING .)
    <               reduce using rule 94 (varcte -> CTE_STRING .)
    >               reduce using rule 94 (varcte -> CTE_STRING .)
    NOT_EQ          reduce using rule 94 (varcte -> CTE_STRING .)
    EQ              reduce using rule 94 (varcte -> CTE_STRING .)
    LEQ             reduce using rule 94 (varcte -> CTE_STRING .)
    GEQ             reduce using rule 94 (varcte -> CTE_STRING .)
    OR              reduce using rule 94 (varcte -> CTE_STRING .)
    AND             reduce using rule 94 (varcte -> CTE_STRING .)
    ;               reduce using rule 94 (varcte -> CTE_STRING .)
    )               reduce using rule 94 (varcte -> CTE_STRING .)
    ,               reduce using rule 94 (varcte -> CTE_STRING .)


state 173

    (95) varcte -> CTE_CHAR .

    *               reduce using rule 95 (varcte -> CTE_CHAR .)
    /               reduce using rule 95 (varcte -> CTE_CHAR .)
    +               reduce using rule 95 (varcte -> CTE_CHAR .)
    -               reduce using rule 95 (varcte -> CTE_CHAR .)
    <               reduce using rule 95 (varcte -> CTE_CHAR .)
    >               reduce using rule 95 (varcte -> CTE_CHAR .)
    NOT_EQ          reduce using rule 95 (varcte -> CTE_CHAR .)
    EQ              reduce using rule 95 (varcte -> CTE_CHAR .)
    LEQ             reduce using rule 95 (varcte -> CTE_CHAR .)
    GEQ             reduce using rule 95 (varcte -> CTE_CHAR .)
    OR              reduce using rule 95 (varcte -> CTE_CHAR .)
    AND             reduce using rule 95 (varcte -> CTE_CHAR .)
    ;               reduce using rule 95 (varcte -> CTE_CHAR .)
    )               reduce using rule 95 (varcte -> CTE_CHAR .)
    ,               reduce using rule 95 (varcte -> CTE_CHAR .)


state 174

    (96) varcte -> function_call .

    *               reduce using rule 96 (varcte -> function_call .)
    /               reduce using rule 96 (varcte -> function_call .)
    +               reduce using rule 96 (varcte -> function_call .)
    -               reduce using rule 96 (varcte -> function_call .)
    <               reduce using rule 96 (varcte -> function_call .)
    >               reduce using rule 96 (varcte -> function_call .)
    NOT_EQ          reduce using rule 96 (varcte -> function_call .)
    EQ              reduce using rule 96 (varcte -> function_call .)
    LEQ             reduce using rule 96 (varcte -> function_call .)
    GEQ             reduce using rule 96 (varcte -> function_call .)
    OR              reduce using rule 96 (varcte -> function_call .)
    AND             reduce using rule 96 (varcte -> function_call .)
    ;               reduce using rule 96 (varcte -> function_call .)
    )               reduce using rule 96 (varcte -> function_call .)
    ,               reduce using rule 96 (varcte -> function_call .)


state 175

    (97) varcte -> map_access .

    *               reduce using rule 97 (varcte -> map_access .)
    /               reduce using rule 97 (varcte -> map_access .)
    +               reduce using rule 97 (varcte -> map_access .)
    -               reduce using rule 97 (varcte -> map_access .)
    <               reduce using rule 97 (varcte -> map_access .)
    >               reduce using rule 97 (varcte -> map_access .)
    NOT_EQ          reduce using rule 97 (varcte -> map_access .)
    EQ              reduce using rule 97 (varcte -> map_access .)
    LEQ             reduce using rule 97 (varcte -> map_access .)
    GEQ             reduce using rule 97 (varcte -> map_access .)
    OR              reduce using rule 97 (varcte -> map_access .)
    AND             reduce using rule 97 (varcte -> map_access .)
    ;               reduce using rule 97 (varcte -> map_access .)
    )               reduce using rule 97 (varcte -> map_access .)
    ,               reduce using rule 97 (varcte -> map_access .)


state 176

    (98) varcte -> map_operation .

    *               reduce using rule 98 (varcte -> map_operation .)
    /               reduce using rule 98 (varcte -> map_operation .)
    +               reduce using rule 98 (varcte -> map_operation .)
    -               reduce using rule 98 (varcte -> map_operation .)
    <               reduce using rule 98 (varcte -> map_operation .)
    >               reduce using rule 98 (varcte -> map_operation .)
    NOT_EQ          reduce using rule 98 (varcte -> map_operation .)
    EQ              reduce using rule 98 (varcte -> map_operation .)
    LEQ             reduce using rule 98 (varcte -> map_operation .)
    GEQ             reduce using rule 98 (varcte -> map_operation .)
    OR              reduce using rule 98 (varcte -> map_operation .)
    AND             reduce using rule 98 (varcte -> map_operation .)
    ;               reduce using rule 98 (varcte -> map_operation .)
    )               reduce using rule 98 (varcte -> map_operation .)
    ,               reduce using rule 98 (varcte -> map_operation .)


state 177

    (99) varcte -> set_operation .

    *               reduce using rule 99 (varcte -> set_operation .)
    /               reduce using rule 99 (varcte -> set_operation .)
    +               reduce using rule 99 (varcte -> set_operation .)
    -               reduce using rule 99 (varcte -> set_operation .)
    <               reduce using rule 99 (varcte -> set_operation .)
    >               reduce using rule 99 (varcte -> set_operation .)
    NOT_EQ          reduce using rule 99 (varcte -> set_operation .)
    EQ              reduce using rule 99 (varcte -> set_operation .)
    LEQ             reduce using rule 99 (varcte -> set_operation .)
    GEQ             reduce using rule 99 (varcte -> set_operation .)
    OR              reduce using rule 99 (varcte -> set_operation .)
    AND             reduce using rule 99 (varcte -> set_operation .)
    ;               reduce using rule 99 (varcte -> set_operation .)
    )               reduce using rule 99 (varcte -> set_operation .)
    ,               reduce using rule 99 (varcte -> set_operation .)


state 178

    (27) condition -> IF ( expression ) . block condition1
    (110) block -> . { statement_aux }

    {               shift and go to state 200

    block                          shift and go to state 199

state 179

    (58) while -> WHILE ( expression ) . block
    (110) block -> . { statement_aux }

    {               shift and go to state 200

    block                          shift and go to state 201

state 180

    (11) procA -> ID ( proc1 ) { proc3 } .

    VOID            reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    INT             reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    FLOAT           reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    BOOL            reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    STRING          reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    CHAR            reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    SET             reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    MAP             reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)
    MAIN            reduce using rule 11 (procA -> ID ( proc1 ) { proc3 } .)


state 181

    (16) proc3 -> var proc3 .

    }               reduce using rule 16 (proc3 -> var proc3 .)


state 182

    (18) proc4 -> statement proc4 .

    }               reduce using rule 18 (proc4 -> statement proc4 .)


state 183

    (14) proc2 -> , datatype ID . proc2
    (14) proc2 -> . , datatype ID proc2
    (15) proc2 -> . empty
    (120) empty -> .

    ,               shift and go to state 101
    )               reduce using rule 120 (empty -> .)

    proc2                          shift and go to state 202
    empty                          shift and go to state 102

state 184

    (42) set_operation -> ID . OPERATION ( set_operation1 . )

    )               shift and go to state 203


state 185

    (119) map_operation -> ID . OPERATION ( ) .

    ;               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    *               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    /               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    +               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    -               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    <               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    >               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    NOT_EQ          reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    EQ              reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    LEQ             reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    GEQ             reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    OR              reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    AND             reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    )               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)
    ,               reduce using rule 119 (map_operation -> ID . OPERATION ( ) .)


state 186

    (43) set_operation1 -> expression .

    )               reduce using rule 43 (set_operation1 -> expression .)


state 187

    (44) set_operation1 -> empty .
    (84) term_not -> empty .

    )               reduce using rule 44 (set_operation1 -> empty .)
    (               reduce using rule 84 (term_not -> empty .)
    +               reduce using rule 84 (term_not -> empty .)
    -               reduce using rule 84 (term_not -> empty .)
    ID              reduce using rule 84 (term_not -> empty .)
    CTE_INT         reduce using rule 84 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 84 (term_not -> empty .)
    CTE_BOOL        reduce using rule 84 (term_not -> empty .)
    CTE_STRING      reduce using rule 84 (term_not -> empty .)
    CTE_CHAR        reduce using rule 84 (term_not -> empty .)


state 188

    (39) function_call2 -> expression , function_call2 .

    )               reduce using rule 39 (function_call2 -> expression , function_call2 .)


state 189

    (40) function_call2 -> empty .
    (84) term_not -> empty .

    )               reduce using rule 40 (function_call2 -> empty .)
    (               reduce using rule 84 (term_not -> empty .)
    +               reduce using rule 84 (term_not -> empty .)
    -               reduce using rule 84 (term_not -> empty .)
    ID              reduce using rule 84 (term_not -> empty .)
    CTE_INT         reduce using rule 84 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 84 (term_not -> empty .)
    CTE_BOOL        reduce using rule 84 (term_not -> empty .)
    CTE_STRING      reduce using rule 84 (term_not -> empty .)
    CTE_CHAR        reduce using rule 84 (term_not -> empty .)


state 190

    (30) input -> READ ( ID input1 ) .

    ;               reduce using rule 30 (input -> READ ( ID input1 ) .)


state 191

    (31) input1 -> , ID . input1
    (31) input1 -> . , ID input1
    (32) input1 -> . empty
    (120) empty -> .

    ,               shift and go to state 153
    )               reduce using rule 120 (empty -> .)

    input1                         shift and go to state 204
    empty                          shift and go to state 154

state 192

    (33) output -> PRINT ( expression output1 ) .

    ;               reduce using rule 33 (output -> PRINT ( expression output1 ) .)


state 193

    (34) output1 -> , expression . output1
    (34) output1 -> . , expression output1
    (35) output1 -> . empty
    (120) empty -> .

    ,               shift and go to state 156
    )               reduce using rule 120 (empty -> .)

    output1                        shift and go to state 205
    empty                          shift and go to state 157

state 194

    (68) expression2 -> logop exp0 expression2 .

    ;               reduce using rule 68 (expression2 -> logop exp0 expression2 .)
    ,               reduce using rule 68 (expression2 -> logop exp0 expression2 .)
    )               reduce using rule 68 (expression2 -> logop exp0 expression2 .)


state 195

    (78) exp2 -> addsub term exp2 .

    <               reduce using rule 78 (exp2 -> addsub term exp2 .)
    >               reduce using rule 78 (exp2 -> addsub term exp2 .)
    NOT_EQ          reduce using rule 78 (exp2 -> addsub term exp2 .)
    EQ              reduce using rule 78 (exp2 -> addsub term exp2 .)
    LEQ             reduce using rule 78 (exp2 -> addsub term exp2 .)
    GEQ             reduce using rule 78 (exp2 -> addsub term exp2 .)
    OR              reduce using rule 78 (exp2 -> addsub term exp2 .)
    AND             reduce using rule 78 (exp2 -> addsub term exp2 .)
    ;               reduce using rule 78 (exp2 -> addsub term exp2 .)
    )               reduce using rule 78 (exp2 -> addsub term exp2 .)
    ,               reduce using rule 78 (exp2 -> addsub term exp2 .)


state 196

    (81) term2 -> muldiv factor . term2
    (81) term2 -> . muldiv factor term2
    (82) term2 -> . empty
    (76) muldiv -> . *
    (77) muldiv -> . /
    (120) empty -> .

    *               shift and go to state 164
    /               shift and go to state 165
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    <               reduce using rule 120 (empty -> .)
    >               reduce using rule 120 (empty -> .)
    NOT_EQ          reduce using rule 120 (empty -> .)
    EQ              reduce using rule 120 (empty -> .)
    LEQ             reduce using rule 120 (empty -> .)
    GEQ             reduce using rule 120 (empty -> .)
    OR              reduce using rule 120 (empty -> .)
    AND             reduce using rule 120 (empty -> .)
    ;               reduce using rule 120 (empty -> .)
    )               reduce using rule 120 (empty -> .)
    ,               reduce using rule 120 (empty -> .)

    muldiv                         shift and go to state 162
    term2                          shift and go to state 206
    empty                          shift and go to state 163

state 197

    (85) factor -> ( expression ) .

    *               reduce using rule 85 (factor -> ( expression ) .)
    /               reduce using rule 85 (factor -> ( expression ) .)
    +               reduce using rule 85 (factor -> ( expression ) .)
    -               reduce using rule 85 (factor -> ( expression ) .)
    <               reduce using rule 85 (factor -> ( expression ) .)
    >               reduce using rule 85 (factor -> ( expression ) .)
    NOT_EQ          reduce using rule 85 (factor -> ( expression ) .)
    EQ              reduce using rule 85 (factor -> ( expression ) .)
    LEQ             reduce using rule 85 (factor -> ( expression ) .)
    GEQ             reduce using rule 85 (factor -> ( expression ) .)
    OR              reduce using rule 85 (factor -> ( expression ) .)
    AND             reduce using rule 85 (factor -> ( expression ) .)
    ;               reduce using rule 85 (factor -> ( expression ) .)
    )               reduce using rule 85 (factor -> ( expression ) .)
    ,               reduce using rule 85 (factor -> ( expression ) .)


state 198

    (119) map_operation -> ID . . OPERATION ( )
    (42) set_operation -> ID . . OPERATION ( set_operation1 )

    OPERATION       shift and go to state 207


state 199

    (27) condition -> IF ( expression ) block . condition1
    (28) condition1 -> . ELSE block
    (29) condition1 -> . empty
    (120) empty -> .

    ELSE            shift and go to state 209
    ID              reduce using rule 120 (empty -> .)
    READ            reduce using rule 120 (empty -> .)
    PRINT           reduce using rule 120 (empty -> .)
    MAP             reduce using rule 120 (empty -> .)
    RETURN          reduce using rule 120 (empty -> .)
    IF              reduce using rule 120 (empty -> .)
    WHILE           reduce using rule 120 (empty -> .)
    }               reduce using rule 120 (empty -> .)

    condition1                     shift and go to state 208
    empty                          shift and go to state 210

state 200

    (110) block -> { . statement_aux }
    (111) statement_aux -> . statement statement_aux
    (112) statement_aux -> . empty
    (45) statement -> . statement1 ;
    (46) statement -> . statement2
    (120) empty -> .
    (47) statement1 -> . assignment
    (48) statement1 -> . input
    (49) statement1 -> . output
    (50) statement1 -> . set_operation
    (51) statement1 -> . map_definition
    (52) statement1 -> . return
    (53) statement1 -> . map_assignment
    (54) statement1 -> . map_operation
    (55) statement1 -> . function_call
    (56) statement2 -> . condition
    (57) statement2 -> . while
    (26) assignment -> . ID ASSIGNATOR expression
    (30) input -> . READ ( ID input1 )
    (33) output -> . PRINT ( expression output1 )
    (42) set_operation -> . ID . OPERATION ( set_operation1 )
    (116) map_definition -> . MAP < datatype , datatype >
    (41) return -> . RETURN expression
    (118) map_assignment -> . map_access ASSIGNATOR exp
    (119) map_operation -> . ID . OPERATION ( )
    (36) function_call -> . ID ( function_call1 )
    (27) condition -> . IF ( expression ) block condition1
    (58) while -> . WHILE ( expression ) block
    (117) map_access -> . ID ( exp )

    }               reduce using rule 120 (empty -> .)
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    MAP             shift and go to state 21
    RETURN          shift and go to state 71
    IF              shift and go to state 73
    WHILE           shift and go to state 74

    statement_aux                  shift and go to state 211
    statement                      shift and go to state 53
    empty                          shift and go to state 54
    statement1                     shift and go to state 55
    statement2                     shift and go to state 56
    assignment                     shift and go to state 57
    input                          shift and go to state 58
    output                         shift and go to state 59
    set_operation                  shift and go to state 60
    map_definition                 shift and go to state 61
    return                         shift and go to state 62
    map_assignment                 shift and go to state 63
    map_operation                  shift and go to state 64
    function_call                  shift and go to state 65
    condition                      shift and go to state 66
    while                          shift and go to state 67
    map_access                     shift and go to state 72

state 201

    (58) while -> WHILE ( expression ) block .

    ID              reduce using rule 58 (while -> WHILE ( expression ) block .)
    READ            reduce using rule 58 (while -> WHILE ( expression ) block .)
    PRINT           reduce using rule 58 (while -> WHILE ( expression ) block .)
    MAP             reduce using rule 58 (while -> WHILE ( expression ) block .)
    RETURN          reduce using rule 58 (while -> WHILE ( expression ) block .)
    IF              reduce using rule 58 (while -> WHILE ( expression ) block .)
    WHILE           reduce using rule 58 (while -> WHILE ( expression ) block .)
    }               reduce using rule 58 (while -> WHILE ( expression ) block .)


state 202

    (14) proc2 -> , datatype ID proc2 .

    )               reduce using rule 14 (proc2 -> , datatype ID proc2 .)


state 203

    (42) set_operation -> ID . OPERATION ( set_operation1 ) .

    ;               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    *               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    /               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    +               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    -               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    <               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    >               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    NOT_EQ          reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    EQ              reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    LEQ             reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    GEQ             reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    OR              reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    AND             reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    )               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    ,               reduce using rule 42 (set_operation -> ID . OPERATION ( set_operation1 ) .)


state 204

    (31) input1 -> , ID input1 .

    )               reduce using rule 31 (input1 -> , ID input1 .)


state 205

    (34) output1 -> , expression output1 .

    )               reduce using rule 34 (output1 -> , expression output1 .)


state 206

    (81) term2 -> muldiv factor term2 .

    +               reduce using rule 81 (term2 -> muldiv factor term2 .)
    -               reduce using rule 81 (term2 -> muldiv factor term2 .)
    <               reduce using rule 81 (term2 -> muldiv factor term2 .)
    >               reduce using rule 81 (term2 -> muldiv factor term2 .)
    NOT_EQ          reduce using rule 81 (term2 -> muldiv factor term2 .)
    EQ              reduce using rule 81 (term2 -> muldiv factor term2 .)
    LEQ             reduce using rule 81 (term2 -> muldiv factor term2 .)
    GEQ             reduce using rule 81 (term2 -> muldiv factor term2 .)
    OR              reduce using rule 81 (term2 -> muldiv factor term2 .)
    AND             reduce using rule 81 (term2 -> muldiv factor term2 .)
    ;               reduce using rule 81 (term2 -> muldiv factor term2 .)
    )               reduce using rule 81 (term2 -> muldiv factor term2 .)
    ,               reduce using rule 81 (term2 -> muldiv factor term2 .)


state 207

    (119) map_operation -> ID . OPERATION . ( )
    (42) set_operation -> ID . OPERATION . ( set_operation1 )

    (               shift and go to state 212


state 208

    (27) condition -> IF ( expression ) block condition1 .

    ID              reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    READ            reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    PRINT           reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    MAP             reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    RETURN          reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    IF              reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    WHILE           reduce using rule 27 (condition -> IF ( expression ) block condition1 .)
    }               reduce using rule 27 (condition -> IF ( expression ) block condition1 .)


state 209

    (28) condition1 -> ELSE . block
    (110) block -> . { statement_aux }

    {               shift and go to state 200

    block                          shift and go to state 213

state 210

    (29) condition1 -> empty .

    ID              reduce using rule 29 (condition1 -> empty .)
    READ            reduce using rule 29 (condition1 -> empty .)
    PRINT           reduce using rule 29 (condition1 -> empty .)
    MAP             reduce using rule 29 (condition1 -> empty .)
    RETURN          reduce using rule 29 (condition1 -> empty .)
    IF              reduce using rule 29 (condition1 -> empty .)
    WHILE           reduce using rule 29 (condition1 -> empty .)
    }               reduce using rule 29 (condition1 -> empty .)


state 211

    (110) block -> { statement_aux . }

    }               shift and go to state 214


state 212

    (119) map_operation -> ID . OPERATION ( . )
    (42) set_operation -> ID . OPERATION ( . set_operation1 )
    (43) set_operation1 -> . expression
    (44) set_operation1 -> . empty
    (67) expression -> . exp0 expression2
    (120) empty -> .
    (70) exp0 -> . exp exp02
    (73) exp -> . term exp2
    (80) term -> . term_not factor term2
    (83) term_not -> . !
    (84) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 185
    (               reduce using rule 120 (empty -> .)
    +               reduce using rule 120 (empty -> .)
    -               reduce using rule 120 (empty -> .)
    ID              reduce using rule 120 (empty -> .)
    CTE_INT         reduce using rule 120 (empty -> .)
    CTE_FLOAT       reduce using rule 120 (empty -> .)
    CTE_BOOL        reduce using rule 120 (empty -> .)
    CTE_STRING      reduce using rule 120 (empty -> .)
    CTE_CHAR        reduce using rule 120 (empty -> .)
    !               shift and go to state 93

  ! )               [ reduce using rule 120 (empty -> .) ]

    set_operation1                 shift and go to state 184
    expression                     shift and go to state 186
    empty                          shift and go to state 187
    exp0                           shift and go to state 89
    exp                            shift and go to state 90
    term                           shift and go to state 91
    term_not                       shift and go to state 92

state 213

    (28) condition1 -> ELSE block .

    ID              reduce using rule 28 (condition1 -> ELSE block .)
    READ            reduce using rule 28 (condition1 -> ELSE block .)
    PRINT           reduce using rule 28 (condition1 -> ELSE block .)
    MAP             reduce using rule 28 (condition1 -> ELSE block .)
    RETURN          reduce using rule 28 (condition1 -> ELSE block .)
    IF              reduce using rule 28 (condition1 -> ELSE block .)
    WHILE           reduce using rule 28 (condition1 -> ELSE block .)
    }               reduce using rule 28 (condition1 -> ELSE block .)


state 214

    (110) block -> { statement_aux } .

    ELSE            reduce using rule 110 (block -> { statement_aux } .)
    ID              reduce using rule 110 (block -> { statement_aux } .)
    READ            reduce using rule 110 (block -> { statement_aux } .)
    PRINT           reduce using rule 110 (block -> { statement_aux } .)
    MAP             reduce using rule 110 (block -> { statement_aux } .)
    RETURN          reduce using rule 110 (block -> { statement_aux } .)
    IF              reduce using rule 110 (block -> { statement_aux } .)
    WHILE           reduce using rule 110 (block -> { statement_aux } .)
    }               reduce using rule 110 (block -> { statement_aux } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 4 resolved as shift
WARNING: shift/reduce conflict for SET in state 4 resolved as shift
WARNING: shift/reduce conflict for MAP in state 4 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 4 resolved as shift
WARNING: shift/reduce conflict for VOID in state 6 resolved as shift
WARNING: shift/reduce conflict for INT in state 6 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 6 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 6 resolved as shift
WARNING: shift/reduce conflict for STRING in state 6 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 6 resolved as shift
WARNING: shift/reduce conflict for SET in state 6 resolved as shift
WARNING: shift/reduce conflict for MAP in state 6 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 6 resolved as shift
WARNING: shift/reduce conflict for VOID in state 18 resolved as shift
WARNING: shift/reduce conflict for INT in state 18 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 18 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 18 resolved as shift
WARNING: shift/reduce conflict for STRING in state 18 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 18 resolved as shift
WARNING: shift/reduce conflict for SET in state 18 resolved as shift
WARNING: shift/reduce conflict for MAP in state 18 resolved as shift
WARNING: shift/reduce conflict for MAP in state 31 resolved as shift
WARNING: shift/reduce conflict for MAP in state 43 resolved as shift
WARNING: shift/reduce conflict for ) in state 148 resolved as shift
WARNING: shift/reduce conflict for ) in state 212 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (procs -> proc)
WARNING: rejected rule (empty -> <empty>) in state 18
WARNING: reduce/reduce conflict in state 108 resolved using rule (function_call1 -> empty)
WARNING: rejected rule (function_call2 -> empty) in state 108
