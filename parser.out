Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; program1
Rule 2     program1 -> var program1
Rule 3     program1 -> program2
Rule 4     program2 -> proc program2
Rule 5     program2 -> main
Rule 6     procs -> proc
Rule 7     procs -> proc procs
Rule 8     proc -> proca1 procA
Rule 9     proc -> VOID procA
Rule 10    proc -> empty
Rule 11    proca1 -> datatype ID (
Rule 12    procA -> proc1 ) { proc3 }
Rule 13    proc1 -> datatype ID proc2
Rule 14    proc1 -> empty
Rule 15    proc2 -> , datatype ID proc2
Rule 16    proc2 -> empty
Rule 17    proc3 -> var proc3
Rule 18    proc3 -> proc4
Rule 19    proc4 -> statement proc4
Rule 20    proc4 -> empty
Rule 21    vars -> var vars
Rule 22    vars -> var
Rule 23    var -> datatype var1
Rule 24    var1 -> ID , var1
Rule 25    var1 -> ID var2
Rule 26    var2 -> ;
Rule 27    assignment -> ID ASSIGNATOR expression
Rule 28    condition -> IF ( expression ) block condition1
Rule 29    condition1 -> ELSE block
Rule 30    condition1 -> empty
Rule 31    input -> READ ( ID input1 )
Rule 32    input1 -> , ID input1
Rule 33    input1 -> empty
Rule 34    output -> PRINT ( expression output1 )
Rule 35    output1 -> , expression output1
Rule 36    output1 -> empty
Rule 37    function_call -> ID ( function_call1 )
Rule 38    function_call1 -> empty
Rule 39    function_call1 -> function_call2
Rule 40    function_call2 -> expression , function_call2
Rule 41    function_call2 -> expression
Rule 42    return -> RETURN expression
Rule 43    set_operation -> ID . OPERATION ( set_operation1 )
Rule 44    set_operation1 -> expression
Rule 45    set_operation1 -> empty
Rule 46    statement -> statement1 ;
Rule 47    statement -> statement2
Rule 48    statement1 -> assignment
Rule 49    statement1 -> input
Rule 50    statement1 -> output
Rule 51    statement1 -> set_operation
Rule 52    statement1 -> map_definition
Rule 53    statement1 -> return
Rule 54    statement1 -> map_assignment
Rule 55    statement1 -> map_operation
Rule 56    statement1 -> function_call
Rule 57    statement2 -> condition
Rule 58    statement2 -> while
Rule 59    while -> WHILE ( expression ) block
Rule 60    relop -> <
Rule 61    relop -> >
Rule 62    relop -> NOT_EQ
Rule 63    relop -> EQ
Rule 64    relop -> LEQ
Rule 65    relop -> GEQ
Rule 66    logop -> OR
Rule 67    logop -> AND
Rule 68    expression -> exp0 expression2
Rule 69    expression2 -> logop exp0 n_quad_logop expression2
Rule 70    expression2 -> empty
Rule 71    n_quad_logop -> <empty>
Rule 72    exp0 -> exp exp02
Rule 73    exp02 -> relop exp
Rule 74    exp02 -> empty
Rule 75    exp -> term exp2
Rule 76    addsub -> +
Rule 77    addsub -> -
Rule 78    muldiv -> *
Rule 79    muldiv -> /
Rule 80    exp2 -> addsub term n_quad_addsub exp2
Rule 81    exp2 -> empty
Rule 82    term -> term_not factor n_quad_muldiv term2
Rule 83    n_quad_muldiv -> <empty>
Rule 84    n_quad_addsub -> <empty>
Rule 85    term2 -> muldiv factor n_quad_muldiv term2
Rule 86    term2 -> n_quad_not
Rule 87    n_quad_not -> <empty>
Rule 88    term_not -> !
Rule 89    term_not -> empty
Rule 90    factor -> ( n_push_false_bottom expression ) n_pop_false_bottom
Rule 91    factor -> varcte
Rule 92    n_push_false_bottom -> <empty>
Rule 93    n_pop_false_bottom -> <empty>
Rule 94    varcte -> ID n_push_operand
Rule 95    varcte -> varcte1
Rule 96    n_push_operand -> <empty>
Rule 97    varcte1 -> CTE_INT
Rule 98    varcte1 -> CTE_FLOAT
Rule 99    varcte1 -> CTE_BOOL
Rule 100   varcte1 -> CTE_STRING
Rule 101   varcte1 -> CTE_CHAR
Rule 102   varcte1 -> function_call
Rule 103   varcte1 -> map_access
Rule 104   varcte1 -> map_operation
Rule 105   varcte1 -> set_operation
Rule 106   functype -> datatype
Rule 107   functype -> VOID
Rule 108   datatype -> INT
Rule 109   datatype -> FLOAT
Rule 110   datatype -> BOOL
Rule 111   datatype -> STRING
Rule 112   datatype -> CHAR
Rule 113   datatype -> set_definition
Rule 114   datatype -> map_definition
Rule 115   set_definition -> SET < datatype >
Rule 116   block -> { statement_aux }
Rule 117   statement_aux -> statement statement_aux
Rule 118   statement_aux -> empty
Rule 119   main -> MAIN n_clear_scope { vars_aux statement_aux }
Rule 120   n_clear_scope -> <empty>
Rule 121   vars_aux -> vars
Rule 122   vars_aux -> empty
Rule 123   map_definition -> MAP < datatype , datatype >
Rule 124   map_access -> ID ( exp )
Rule 125   map_assignment -> map_access ASSIGNATOR exp
Rule 126   map_operation -> ID . OPERATION ( )
Rule 127   empty -> <empty>

Terminals, with rules where they appear

!                    : 88
(                    : 11 28 31 34 37 43 59 90 124 126
)                    : 12 28 31 34 37 43 59 90 124 126
*                    : 78
+                    : 76
,                    : 15 24 32 35 40 123
-                    : 77
.                    : 43 126
/                    : 79
;                    : 1 26 46
<                    : 60 115 123
>                    : 61 115 123
AND                  : 67
ASSIGNATOR           : 27 125
BOOL                 : 110
CHAR                 : 112
CTE_BOOL             : 99
CTE_CHAR             : 101
CTE_FLOAT            : 98
CTE_INT              : 97
CTE_STRING           : 100
ELSE                 : 29
EQ                   : 63
FLOAT                : 109
GEQ                  : 65
ID                   : 1 11 13 15 24 25 27 31 32 37 43 94 124 126
IF                   : 28
INT                  : 108
LEQ                  : 64
MAIN                 : 119
MAP                  : 123
NOT_EQ               : 62
OPERATION            : 43 126
OR                   : 66
PRINT                : 34
PROGRAM              : 1
READ                 : 31
RETURN               : 42
SET                  : 115
STRING               : 111
VOID                 : 9 107
WHILE                : 59
error                : 
{                    : 12 116 119
}                    : 12 116 119

Nonterminals, with rules where they appear

addsub               : 80
assignment           : 48
block                : 28 29 59
condition            : 57
condition1           : 28
datatype             : 11 13 15 23 106 115 123 123
empty                : 10 14 16 20 30 33 36 38 45 70 74 81 89 118 122
exp                  : 72 73 124 125
exp0                 : 68 69
exp02                : 72
exp2                 : 75 80
expression           : 27 28 34 35 40 41 42 44 59 90
expression2          : 68 69
factor               : 82 85
function_call        : 56 102
function_call1       : 37
function_call2       : 39 40
functype             : 
input                : 49
input1               : 31 32
logop                : 69
main                 : 5
map_access           : 103 125
map_assignment       : 54
map_definition       : 52 114
map_operation        : 55 104
muldiv               : 85
n_clear_scope        : 119
n_pop_false_bottom   : 90
n_push_false_bottom  : 90
n_push_operand       : 94
n_quad_addsub        : 80
n_quad_logop         : 69
n_quad_muldiv        : 82 85
n_quad_not           : 86
output               : 50
output1              : 34 35
proc                 : 4 6 7
proc1                : 12
proc2                : 13 15
proc3                : 12 17
proc4                : 18 19
procA                : 8 9
proca1               : 8
procs                : 7
program              : 0
program1             : 1 2
program2             : 3 4
relop                : 73
return               : 53
set_definition       : 113
set_operation        : 51 105
set_operation1       : 43
statement            : 19 117
statement1           : 46
statement2           : 47
statement_aux        : 116 117 119
term                 : 75 80
term2                : 82 85
term_not             : 82
var                  : 2 17 21 22
var1                 : 23 24
var2                 : 25
varcte               : 91
varcte1              : 95
vars                 : 21 121
vars_aux             : 119
while                : 58

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; program1

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . ID ; program1

    ID              shift and go to state 3


state 2

    (0) S' -> program .



state 3

    (1) program -> PROGRAM ID . ; program1

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . program1
    (2) program1 -> . var program1
    (3) program1 -> . program2
    (23) var -> . datatype var1
    (4) program2 -> . proc program2
    (5) program2 -> . main
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (8) proc -> . proca1 procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (119) main -> . MAIN n_clear_scope { vars_aux statement_aux }
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >
    (11) proca1 -> . datatype ID (
    (127) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    VOID            shift and go to state 5
    MAIN            shift and go to state 23
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! VOID            [ reduce using rule 127 (empty -> .) ]
  ! MAIN            [ reduce using rule 127 (empty -> .) ]
  ! INT             [ reduce using rule 127 (empty -> .) ]
  ! FLOAT           [ reduce using rule 127 (empty -> .) ]
  ! BOOL            [ reduce using rule 127 (empty -> .) ]
  ! STRING          [ reduce using rule 127 (empty -> .) ]
  ! CHAR            [ reduce using rule 127 (empty -> .) ]
  ! SET             [ reduce using rule 127 (empty -> .) ]
  ! MAP             [ reduce using rule 127 (empty -> .) ]

    program1                       shift and go to state 9
    program2                       shift and go to state 10
    datatype                       shift and go to state 19
    proca1                         shift and go to state 11
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18
    var                            shift and go to state 12
    main                           shift and go to state 13
    proc                           shift and go to state 14
    empty                          shift and go to state 15

state 5

    (9) proc -> VOID . procA
    (12) procA -> . proc1 ) { proc3 }
    (13) proc1 -> . datatype ID proc2
    (14) proc1 -> . empty
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (127) empty -> .
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    )               reduce using rule 127 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17

    set_definition                 shift and go to state 18
    datatype                       shift and go to state 26
    map_definition                 shift and go to state 6
    procA                          shift and go to state 27
    proc1                          shift and go to state 24
    empty                          shift and go to state 25

state 6

    (114) datatype -> map_definition .

    ID              reduce using rule 114 (datatype -> map_definition .)
    >               reduce using rule 114 (datatype -> map_definition .)
    ,               reduce using rule 114 (datatype -> map_definition .)


state 7

    (112) datatype -> CHAR .

    ID              reduce using rule 112 (datatype -> CHAR .)
    >               reduce using rule 112 (datatype -> CHAR .)
    ,               reduce using rule 112 (datatype -> CHAR .)


state 8

    (115) set_definition -> SET . < datatype >

    <               shift and go to state 28


state 9

    (1) program -> PROGRAM ID ; program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID ; program1 .)


state 10

    (3) program1 -> program2 .

    $end            reduce using rule 3 (program1 -> program2 .)


state 11

    (8) proc -> proca1 . procA
    (12) procA -> . proc1 ) { proc3 }
    (13) proc1 -> . datatype ID proc2
    (14) proc1 -> . empty
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (127) empty -> .
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    )               reduce using rule 127 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17

    set_definition                 shift and go to state 18
    datatype                       shift and go to state 26
    procA                          shift and go to state 29
    empty                          shift and go to state 25
    map_definition                 shift and go to state 6
    proc1                          shift and go to state 24

state 12

    (2) program1 -> var . program1
    (2) program1 -> . var program1
    (3) program1 -> . program2
    (23) var -> . datatype var1
    (4) program2 -> . proc program2
    (5) program2 -> . main
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (8) proc -> . proca1 procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (119) main -> . MAIN n_clear_scope { vars_aux statement_aux }
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >
    (11) proca1 -> . datatype ID (
    (127) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    VOID            shift and go to state 5
    MAIN            shift and go to state 23
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! VOID            [ reduce using rule 127 (empty -> .) ]
  ! MAIN            [ reduce using rule 127 (empty -> .) ]
  ! INT             [ reduce using rule 127 (empty -> .) ]
  ! FLOAT           [ reduce using rule 127 (empty -> .) ]
  ! BOOL            [ reduce using rule 127 (empty -> .) ]
  ! STRING          [ reduce using rule 127 (empty -> .) ]
  ! CHAR            [ reduce using rule 127 (empty -> .) ]
  ! SET             [ reduce using rule 127 (empty -> .) ]
  ! MAP             [ reduce using rule 127 (empty -> .) ]

    program1                       shift and go to state 30
    program2                       shift and go to state 10
    datatype                       shift and go to state 19
    proca1                         shift and go to state 11
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18
    var                            shift and go to state 12
    main                           shift and go to state 13
    proc                           shift and go to state 14
    empty                          shift and go to state 15

state 13

    (5) program2 -> main .

    $end            reduce using rule 5 (program2 -> main .)


state 14

    (4) program2 -> proc . program2
    (4) program2 -> . proc program2
    (5) program2 -> . main
    (8) proc -> . proca1 procA
    (9) proc -> . VOID procA
    (10) proc -> . empty
    (119) main -> . MAIN n_clear_scope { vars_aux statement_aux }
    (11) proca1 -> . datatype ID (
    (127) empty -> .
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SET resolved as shift
  ! shift/reduce conflict for MAP resolved as shift
    VOID            shift and go to state 5
    MAIN            shift and go to state 23
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! VOID            [ reduce using rule 127 (empty -> .) ]
  ! MAIN            [ reduce using rule 127 (empty -> .) ]
  ! INT             [ reduce using rule 127 (empty -> .) ]
  ! FLOAT           [ reduce using rule 127 (empty -> .) ]
  ! BOOL            [ reduce using rule 127 (empty -> .) ]
  ! STRING          [ reduce using rule 127 (empty -> .) ]
  ! CHAR            [ reduce using rule 127 (empty -> .) ]
  ! SET             [ reduce using rule 127 (empty -> .) ]
  ! MAP             [ reduce using rule 127 (empty -> .) ]

    set_definition                 shift and go to state 18
    program2                       shift and go to state 31
    datatype                       shift and go to state 32
    proca1                         shift and go to state 11
    map_definition                 shift and go to state 6
    main                           shift and go to state 13
    proc                           shift and go to state 14
    empty                          shift and go to state 15

state 15

    (10) proc -> empty .

    VOID            reduce using rule 10 (proc -> empty .)
    MAIN            reduce using rule 10 (proc -> empty .)
    INT             reduce using rule 10 (proc -> empty .)
    FLOAT           reduce using rule 10 (proc -> empty .)
    BOOL            reduce using rule 10 (proc -> empty .)
    STRING          reduce using rule 10 (proc -> empty .)
    CHAR            reduce using rule 10 (proc -> empty .)
    SET             reduce using rule 10 (proc -> empty .)
    MAP             reduce using rule 10 (proc -> empty .)


state 16

    (111) datatype -> STRING .

    ID              reduce using rule 111 (datatype -> STRING .)
    >               reduce using rule 111 (datatype -> STRING .)
    ,               reduce using rule 111 (datatype -> STRING .)


state 17

    (123) map_definition -> MAP . < datatype , datatype >

    <               shift and go to state 33


state 18

    (113) datatype -> set_definition .

    ID              reduce using rule 113 (datatype -> set_definition .)
    >               reduce using rule 113 (datatype -> set_definition .)
    ,               reduce using rule 113 (datatype -> set_definition .)


state 19

    (23) var -> datatype . var1
    (11) proca1 -> datatype . ID (
    (24) var1 -> . ID , var1
    (25) var1 -> . ID var2

    ID              shift and go to state 35

    var1                           shift and go to state 34

state 20

    (109) datatype -> FLOAT .

    ID              reduce using rule 109 (datatype -> FLOAT .)
    >               reduce using rule 109 (datatype -> FLOAT .)
    ,               reduce using rule 109 (datatype -> FLOAT .)


state 21

    (108) datatype -> INT .

    ID              reduce using rule 108 (datatype -> INT .)
    >               reduce using rule 108 (datatype -> INT .)
    ,               reduce using rule 108 (datatype -> INT .)


state 22

    (110) datatype -> BOOL .

    ID              reduce using rule 110 (datatype -> BOOL .)
    >               reduce using rule 110 (datatype -> BOOL .)
    ,               reduce using rule 110 (datatype -> BOOL .)


state 23

    (119) main -> MAIN . n_clear_scope { vars_aux statement_aux }
    (120) n_clear_scope -> .

    {               reduce using rule 120 (n_clear_scope -> .)

    n_clear_scope                  shift and go to state 36

state 24

    (12) procA -> proc1 . ) { proc3 }

    )               shift and go to state 37


state 25

    (14) proc1 -> empty .

    )               reduce using rule 14 (proc1 -> empty .)


state 26

    (13) proc1 -> datatype . ID proc2

    ID              shift and go to state 38


state 27

    (9) proc -> VOID procA .

    VOID            reduce using rule 9 (proc -> VOID procA .)
    MAIN            reduce using rule 9 (proc -> VOID procA .)
    INT             reduce using rule 9 (proc -> VOID procA .)
    FLOAT           reduce using rule 9 (proc -> VOID procA .)
    BOOL            reduce using rule 9 (proc -> VOID procA .)
    STRING          reduce using rule 9 (proc -> VOID procA .)
    CHAR            reduce using rule 9 (proc -> VOID procA .)
    SET             reduce using rule 9 (proc -> VOID procA .)
    MAP             reduce using rule 9 (proc -> VOID procA .)


state 28

    (115) set_definition -> SET < . datatype >
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 39
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 29

    (8) proc -> proca1 procA .

    VOID            reduce using rule 8 (proc -> proca1 procA .)
    MAIN            reduce using rule 8 (proc -> proca1 procA .)
    INT             reduce using rule 8 (proc -> proca1 procA .)
    FLOAT           reduce using rule 8 (proc -> proca1 procA .)
    BOOL            reduce using rule 8 (proc -> proca1 procA .)
    STRING          reduce using rule 8 (proc -> proca1 procA .)
    CHAR            reduce using rule 8 (proc -> proca1 procA .)
    SET             reduce using rule 8 (proc -> proca1 procA .)
    MAP             reduce using rule 8 (proc -> proca1 procA .)


state 30

    (2) program1 -> var program1 .

    $end            reduce using rule 2 (program1 -> var program1 .)


state 31

    (4) program2 -> proc program2 .

    $end            reduce using rule 4 (program2 -> proc program2 .)


state 32

    (11) proca1 -> datatype . ID (

    ID              shift and go to state 40


state 33

    (123) map_definition -> MAP < . datatype , datatype >
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 41
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 34

    (23) var -> datatype var1 .

    INT             reduce using rule 23 (var -> datatype var1 .)
    FLOAT           reduce using rule 23 (var -> datatype var1 .)
    BOOL            reduce using rule 23 (var -> datatype var1 .)
    STRING          reduce using rule 23 (var -> datatype var1 .)
    CHAR            reduce using rule 23 (var -> datatype var1 .)
    SET             reduce using rule 23 (var -> datatype var1 .)
    MAP             reduce using rule 23 (var -> datatype var1 .)
    ID              reduce using rule 23 (var -> datatype var1 .)
    READ            reduce using rule 23 (var -> datatype var1 .)
    PRINT           reduce using rule 23 (var -> datatype var1 .)
    RETURN          reduce using rule 23 (var -> datatype var1 .)
    IF              reduce using rule 23 (var -> datatype var1 .)
    WHILE           reduce using rule 23 (var -> datatype var1 .)
    }               reduce using rule 23 (var -> datatype var1 .)
    VOID            reduce using rule 23 (var -> datatype var1 .)
    MAIN            reduce using rule 23 (var -> datatype var1 .)


state 35

    (11) proca1 -> datatype ID . (
    (24) var1 -> ID . , var1
    (25) var1 -> ID . var2
    (26) var2 -> . ;

    (               shift and go to state 43
    ,               shift and go to state 44
    ;               shift and go to state 45

    var2                           shift and go to state 42

state 36

    (119) main -> MAIN n_clear_scope . { vars_aux statement_aux }

    {               shift and go to state 46


state 37

    (12) procA -> proc1 ) . { proc3 }

    {               shift and go to state 47


state 38

    (13) proc1 -> datatype ID . proc2
    (15) proc2 -> . , datatype ID proc2
    (16) proc2 -> . empty
    (127) empty -> .

    ,               shift and go to state 48
    )               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 49
    proc2                          shift and go to state 50

state 39

    (115) set_definition -> SET < datatype . >

    >               shift and go to state 51


state 40

    (11) proca1 -> datatype ID . (

    (               shift and go to state 43


state 41

    (123) map_definition -> MAP < datatype . , datatype >

    ,               shift and go to state 52


state 42

    (25) var1 -> ID var2 .

    INT             reduce using rule 25 (var1 -> ID var2 .)
    FLOAT           reduce using rule 25 (var1 -> ID var2 .)
    BOOL            reduce using rule 25 (var1 -> ID var2 .)
    STRING          reduce using rule 25 (var1 -> ID var2 .)
    CHAR            reduce using rule 25 (var1 -> ID var2 .)
    VOID            reduce using rule 25 (var1 -> ID var2 .)
    MAIN            reduce using rule 25 (var1 -> ID var2 .)
    SET             reduce using rule 25 (var1 -> ID var2 .)
    MAP             reduce using rule 25 (var1 -> ID var2 .)
    ID              reduce using rule 25 (var1 -> ID var2 .)
    READ            reduce using rule 25 (var1 -> ID var2 .)
    PRINT           reduce using rule 25 (var1 -> ID var2 .)
    RETURN          reduce using rule 25 (var1 -> ID var2 .)
    IF              reduce using rule 25 (var1 -> ID var2 .)
    WHILE           reduce using rule 25 (var1 -> ID var2 .)
    }               reduce using rule 25 (var1 -> ID var2 .)


state 43

    (11) proca1 -> datatype ID ( .

    INT             reduce using rule 11 (proca1 -> datatype ID ( .)
    FLOAT           reduce using rule 11 (proca1 -> datatype ID ( .)
    BOOL            reduce using rule 11 (proca1 -> datatype ID ( .)
    STRING          reduce using rule 11 (proca1 -> datatype ID ( .)
    CHAR            reduce using rule 11 (proca1 -> datatype ID ( .)
    SET             reduce using rule 11 (proca1 -> datatype ID ( .)
    MAP             reduce using rule 11 (proca1 -> datatype ID ( .)
    )               reduce using rule 11 (proca1 -> datatype ID ( .)


state 44

    (24) var1 -> ID , . var1
    (24) var1 -> . ID , var1
    (25) var1 -> . ID var2

    ID              shift and go to state 54

    var1                           shift and go to state 53

state 45

    (26) var2 -> ; .

    INT             reduce using rule 26 (var2 -> ; .)
    FLOAT           reduce using rule 26 (var2 -> ; .)
    BOOL            reduce using rule 26 (var2 -> ; .)
    STRING          reduce using rule 26 (var2 -> ; .)
    CHAR            reduce using rule 26 (var2 -> ; .)
    VOID            reduce using rule 26 (var2 -> ; .)
    MAIN            reduce using rule 26 (var2 -> ; .)
    SET             reduce using rule 26 (var2 -> ; .)
    MAP             reduce using rule 26 (var2 -> ; .)
    ID              reduce using rule 26 (var2 -> ; .)
    READ            reduce using rule 26 (var2 -> ; .)
    PRINT           reduce using rule 26 (var2 -> ; .)
    RETURN          reduce using rule 26 (var2 -> ; .)
    IF              reduce using rule 26 (var2 -> ; .)
    WHILE           reduce using rule 26 (var2 -> ; .)
    }               reduce using rule 26 (var2 -> ; .)


state 46

    (119) main -> MAIN n_clear_scope { . vars_aux statement_aux }
    (121) vars_aux -> . vars
    (122) vars_aux -> . empty
    (21) vars -> . var vars
    (22) vars -> . var
    (127) empty -> .
    (23) var -> . datatype var1
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    ID              reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    }               reduce using rule 127 (empty -> .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! MAP             [ reduce using rule 127 (empty -> .) ]

    set_definition                 shift and go to state 18
    vars                           shift and go to state 55
    datatype                       shift and go to state 59
    map_definition                 shift and go to state 6
    vars_aux                       shift and go to state 56
    var                            shift and go to state 57
    empty                          shift and go to state 58

state 47

    (12) procA -> proc1 ) { . proc3 }
    (17) proc3 -> . var proc3
    (18) proc3 -> . proc4
    (23) var -> . datatype var1
    (19) proc4 -> . statement proc4
    (20) proc4 -> . empty
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (46) statement -> . statement1 ;
    (47) statement -> . statement2
    (127) empty -> .
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >
    (48) statement1 -> . assignment
    (49) statement1 -> . input
    (50) statement1 -> . output
    (51) statement1 -> . set_operation
    (52) statement1 -> . map_definition
    (53) statement1 -> . return
    (54) statement1 -> . map_assignment
    (55) statement1 -> . map_operation
    (56) statement1 -> . function_call
    (57) statement2 -> . condition
    (58) statement2 -> . while
    (27) assignment -> . ID ASSIGNATOR expression
    (31) input -> . READ ( ID input1 )
    (34) output -> . PRINT ( expression output1 )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )
    (42) return -> . RETURN expression
    (125) map_assignment -> . map_access ASSIGNATOR exp
    (126) map_operation -> . ID . OPERATION ( )
    (37) function_call -> . ID ( function_call1 )
    (28) condition -> . IF ( expression ) block condition1
    (59) while -> . WHILE ( expression ) block
    (124) map_access -> . ID ( exp )

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    }               reduce using rule 127 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17
    ID              shift and go to state 79
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    RETURN          shift and go to state 60
    IF              shift and go to state 81
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 63
    function_call                  shift and go to state 64
    proc4                          shift and go to state 67
    return                         shift and go to state 77
    proc3                          shift and go to state 68
    set_definition                 shift and go to state 18
    map_access                     shift and go to state 70
    statement                      shift and go to state 71
    var                            shift and go to state 72
    input                          shift and go to state 73
    empty                          shift and go to state 74
    statement2                     shift and go to state 69
    statement1                     shift and go to state 75
    assignment                     shift and go to state 76
    map_operation                  shift and go to state 78
    condition                      shift and go to state 80
    set_operation                  shift and go to state 82
    datatype                       shift and go to state 59
    map_assignment                 shift and go to state 62
    while                          shift and go to state 83
    output                         shift and go to state 84

state 48

    (15) proc2 -> , . datatype ID proc2
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 85
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 49

    (16) proc2 -> empty .

    )               reduce using rule 16 (proc2 -> empty .)


state 50

    (13) proc1 -> datatype ID proc2 .

    )               reduce using rule 13 (proc1 -> datatype ID proc2 .)


state 51

    (115) set_definition -> SET < datatype > .

    ID              reduce using rule 115 (set_definition -> SET < datatype > .)
    ,               reduce using rule 115 (set_definition -> SET < datatype > .)
    >               reduce using rule 115 (set_definition -> SET < datatype > .)


state 52

    (123) map_definition -> MAP < datatype , . datatype >
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

    datatype                       shift and go to state 86
    map_definition                 shift and go to state 6
    set_definition                 shift and go to state 18

state 53

    (24) var1 -> ID , var1 .

    INT             reduce using rule 24 (var1 -> ID , var1 .)
    FLOAT           reduce using rule 24 (var1 -> ID , var1 .)
    BOOL            reduce using rule 24 (var1 -> ID , var1 .)
    STRING          reduce using rule 24 (var1 -> ID , var1 .)
    CHAR            reduce using rule 24 (var1 -> ID , var1 .)
    VOID            reduce using rule 24 (var1 -> ID , var1 .)
    MAIN            reduce using rule 24 (var1 -> ID , var1 .)
    SET             reduce using rule 24 (var1 -> ID , var1 .)
    MAP             reduce using rule 24 (var1 -> ID , var1 .)
    ID              reduce using rule 24 (var1 -> ID , var1 .)
    READ            reduce using rule 24 (var1 -> ID , var1 .)
    PRINT           reduce using rule 24 (var1 -> ID , var1 .)
    RETURN          reduce using rule 24 (var1 -> ID , var1 .)
    IF              reduce using rule 24 (var1 -> ID , var1 .)
    WHILE           reduce using rule 24 (var1 -> ID , var1 .)
    }               reduce using rule 24 (var1 -> ID , var1 .)


state 54

    (24) var1 -> ID . , var1
    (25) var1 -> ID . var2
    (26) var2 -> . ;

    ,               shift and go to state 44
    ;               shift and go to state 45

    var2                           shift and go to state 42

state 55

    (121) vars_aux -> vars .

    ID              reduce using rule 121 (vars_aux -> vars .)
    READ            reduce using rule 121 (vars_aux -> vars .)
    PRINT           reduce using rule 121 (vars_aux -> vars .)
    MAP             reduce using rule 121 (vars_aux -> vars .)
    RETURN          reduce using rule 121 (vars_aux -> vars .)
    IF              reduce using rule 121 (vars_aux -> vars .)
    WHILE           reduce using rule 121 (vars_aux -> vars .)
    }               reduce using rule 121 (vars_aux -> vars .)


state 56

    (119) main -> MAIN n_clear_scope { vars_aux . statement_aux }
    (117) statement_aux -> . statement statement_aux
    (118) statement_aux -> . empty
    (46) statement -> . statement1 ;
    (47) statement -> . statement2
    (127) empty -> .
    (48) statement1 -> . assignment
    (49) statement1 -> . input
    (50) statement1 -> . output
    (51) statement1 -> . set_operation
    (52) statement1 -> . map_definition
    (53) statement1 -> . return
    (54) statement1 -> . map_assignment
    (55) statement1 -> . map_operation
    (56) statement1 -> . function_call
    (57) statement2 -> . condition
    (58) statement2 -> . while
    (27) assignment -> . ID ASSIGNATOR expression
    (31) input -> . READ ( ID input1 )
    (34) output -> . PRINT ( expression output1 )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )
    (123) map_definition -> . MAP < datatype , datatype >
    (42) return -> . RETURN expression
    (125) map_assignment -> . map_access ASSIGNATOR exp
    (126) map_operation -> . ID . OPERATION ( )
    (37) function_call -> . ID ( function_call1 )
    (28) condition -> . IF ( expression ) block condition1
    (59) while -> . WHILE ( expression ) block
    (124) map_access -> . ID ( exp )

    }               reduce using rule 127 (empty -> .)
    ID              shift and go to state 79
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 81
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 87
    function_call                  shift and go to state 64
    statement_aux                  shift and go to state 88
    map_access                     shift and go to state 70
    statement                      shift and go to state 89
    input                          shift and go to state 73
    empty                          shift and go to state 90
    return                         shift and go to state 77
    statement2                     shift and go to state 69
    statement1                     shift and go to state 75
    assignment                     shift and go to state 76
    map_operation                  shift and go to state 78
    condition                      shift and go to state 80
    set_operation                  shift and go to state 82
    map_assignment                 shift and go to state 62
    while                          shift and go to state 83
    output                         shift and go to state 84

state 57

    (21) vars -> var . vars
    (22) vars -> var .
    (21) vars -> . var vars
    (22) vars -> . var
    (23) var -> . datatype var1
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >

  ! shift/reduce conflict for MAP resolved as shift
    ID              reduce using rule 22 (vars -> var .)
    READ            reduce using rule 22 (vars -> var .)
    PRINT           reduce using rule 22 (vars -> var .)
    RETURN          reduce using rule 22 (vars -> var .)
    IF              reduce using rule 22 (vars -> var .)
    WHILE           reduce using rule 22 (vars -> var .)
    }               reduce using rule 22 (vars -> var .)
    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    SET             shift and go to state 8
    MAP             shift and go to state 17

  ! MAP             [ reduce using rule 22 (vars -> var .) ]

    vars                           shift and go to state 91
    set_definition                 shift and go to state 18
    datatype                       shift and go to state 59
    map_definition                 shift and go to state 6
    var                            shift and go to state 57

state 58

    (122) vars_aux -> empty .

    ID              reduce using rule 122 (vars_aux -> empty .)
    READ            reduce using rule 122 (vars_aux -> empty .)
    PRINT           reduce using rule 122 (vars_aux -> empty .)
    MAP             reduce using rule 122 (vars_aux -> empty .)
    RETURN          reduce using rule 122 (vars_aux -> empty .)
    IF              reduce using rule 122 (vars_aux -> empty .)
    WHILE           reduce using rule 122 (vars_aux -> empty .)
    }               reduce using rule 122 (vars_aux -> empty .)


state 59

    (23) var -> datatype . var1
    (24) var1 -> . ID , var1
    (25) var1 -> . ID var2

    ID              shift and go to state 54

    var1                           shift and go to state 34

state 60

    (42) return -> RETURN . expression
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 97
    empty                          shift and go to state 98

state 61

    (31) input -> READ . ( ID input1 )

    (               shift and go to state 99


state 62

    (54) statement1 -> map_assignment .

    ;               reduce using rule 54 (statement1 -> map_assignment .)


state 63

    (114) datatype -> map_definition .
    (52) statement1 -> map_definition .

    ID              reduce using rule 114 (datatype -> map_definition .)
    ;               reduce using rule 52 (statement1 -> map_definition .)


state 64

    (56) statement1 -> function_call .

    ;               reduce using rule 56 (statement1 -> function_call .)


state 65

    (59) while -> WHILE . ( expression ) block

    (               shift and go to state 100


state 66

    (34) output -> PRINT . ( expression output1 )

    (               shift and go to state 101


state 67

    (18) proc3 -> proc4 .

    }               reduce using rule 18 (proc3 -> proc4 .)


state 68

    (12) procA -> proc1 ) { proc3 . }

    }               shift and go to state 102


state 69

    (47) statement -> statement2 .

    ID              reduce using rule 47 (statement -> statement2 .)
    READ            reduce using rule 47 (statement -> statement2 .)
    PRINT           reduce using rule 47 (statement -> statement2 .)
    MAP             reduce using rule 47 (statement -> statement2 .)
    RETURN          reduce using rule 47 (statement -> statement2 .)
    IF              reduce using rule 47 (statement -> statement2 .)
    WHILE           reduce using rule 47 (statement -> statement2 .)
    }               reduce using rule 47 (statement -> statement2 .)


state 70

    (125) map_assignment -> map_access . ASSIGNATOR exp

    ASSIGNATOR      shift and go to state 103


state 71

    (19) proc4 -> statement . proc4
    (19) proc4 -> . statement proc4
    (20) proc4 -> . empty
    (46) statement -> . statement1 ;
    (47) statement -> . statement2
    (127) empty -> .
    (48) statement1 -> . assignment
    (49) statement1 -> . input
    (50) statement1 -> . output
    (51) statement1 -> . set_operation
    (52) statement1 -> . map_definition
    (53) statement1 -> . return
    (54) statement1 -> . map_assignment
    (55) statement1 -> . map_operation
    (56) statement1 -> . function_call
    (57) statement2 -> . condition
    (58) statement2 -> . while
    (27) assignment -> . ID ASSIGNATOR expression
    (31) input -> . READ ( ID input1 )
    (34) output -> . PRINT ( expression output1 )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )
    (123) map_definition -> . MAP < datatype , datatype >
    (42) return -> . RETURN expression
    (125) map_assignment -> . map_access ASSIGNATOR exp
    (126) map_operation -> . ID . OPERATION ( )
    (37) function_call -> . ID ( function_call1 )
    (28) condition -> . IF ( expression ) block condition1
    (59) while -> . WHILE ( expression ) block
    (124) map_access -> . ID ( exp )

    }               reduce using rule 127 (empty -> .)
    ID              shift and go to state 79
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 81
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 87
    function_call                  shift and go to state 64
    proc4                          shift and go to state 104
    map_access                     shift and go to state 70
    statement                      shift and go to state 71
    input                          shift and go to state 73
    empty                          shift and go to state 74
    return                         shift and go to state 77
    statement2                     shift and go to state 69
    statement1                     shift and go to state 75
    assignment                     shift and go to state 76
    map_operation                  shift and go to state 78
    condition                      shift and go to state 80
    set_operation                  shift and go to state 82
    map_assignment                 shift and go to state 62
    while                          shift and go to state 83
    output                         shift and go to state 84

state 72

    (17) proc3 -> var . proc3
    (17) proc3 -> . var proc3
    (18) proc3 -> . proc4
    (23) var -> . datatype var1
    (19) proc4 -> . statement proc4
    (20) proc4 -> . empty
    (108) datatype -> . INT
    (109) datatype -> . FLOAT
    (110) datatype -> . BOOL
    (111) datatype -> . STRING
    (112) datatype -> . CHAR
    (113) datatype -> . set_definition
    (114) datatype -> . map_definition
    (46) statement -> . statement1 ;
    (47) statement -> . statement2
    (127) empty -> .
    (115) set_definition -> . SET < datatype >
    (123) map_definition -> . MAP < datatype , datatype >
    (48) statement1 -> . assignment
    (49) statement1 -> . input
    (50) statement1 -> . output
    (51) statement1 -> . set_operation
    (52) statement1 -> . map_definition
    (53) statement1 -> . return
    (54) statement1 -> . map_assignment
    (55) statement1 -> . map_operation
    (56) statement1 -> . function_call
    (57) statement2 -> . condition
    (58) statement2 -> . while
    (27) assignment -> . ID ASSIGNATOR expression
    (31) input -> . READ ( ID input1 )
    (34) output -> . PRINT ( expression output1 )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )
    (42) return -> . RETURN expression
    (125) map_assignment -> . map_access ASSIGNATOR exp
    (126) map_operation -> . ID . OPERATION ( )
    (37) function_call -> . ID ( function_call1 )
    (28) condition -> . IF ( expression ) block condition1
    (59) while -> . WHILE ( expression ) block
    (124) map_access -> . ID ( exp )

    INT             shift and go to state 21
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 22
    STRING          shift and go to state 16
    CHAR            shift and go to state 7
    }               reduce using rule 127 (empty -> .)
    SET             shift and go to state 8
    MAP             shift and go to state 17
    ID              shift and go to state 79
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    RETURN          shift and go to state 60
    IF              shift and go to state 81
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 63
    function_call                  shift and go to state 64
    proc4                          shift and go to state 67
    return                         shift and go to state 77
    proc3                          shift and go to state 105
    set_definition                 shift and go to state 18
    map_access                     shift and go to state 70
    statement                      shift and go to state 71
    var                            shift and go to state 72
    input                          shift and go to state 73
    empty                          shift and go to state 74
    statement2                     shift and go to state 69
    statement1                     shift and go to state 75
    assignment                     shift and go to state 76
    map_operation                  shift and go to state 78
    condition                      shift and go to state 80
    set_operation                  shift and go to state 82
    datatype                       shift and go to state 59
    map_assignment                 shift and go to state 62
    while                          shift and go to state 83
    output                         shift and go to state 84

state 73

    (49) statement1 -> input .

    ;               reduce using rule 49 (statement1 -> input .)


state 74

    (20) proc4 -> empty .

    }               reduce using rule 20 (proc4 -> empty .)


state 75

    (46) statement -> statement1 . ;

    ;               shift and go to state 106


state 76

    (48) statement1 -> assignment .

    ;               reduce using rule 48 (statement1 -> assignment .)


state 77

    (53) statement1 -> return .

    ;               reduce using rule 53 (statement1 -> return .)


state 78

    (55) statement1 -> map_operation .

    ;               reduce using rule 55 (statement1 -> map_operation .)


state 79

    (27) assignment -> ID . ASSIGNATOR expression
    (43) set_operation -> ID . . OPERATION ( set_operation1 )
    (126) map_operation -> ID . . OPERATION ( )
    (37) function_call -> ID . ( function_call1 )
    (124) map_access -> ID . ( exp )

    ASSIGNATOR      shift and go to state 109
    .               shift and go to state 108
    (               shift and go to state 107


state 80

    (57) statement2 -> condition .

    ID              reduce using rule 57 (statement2 -> condition .)
    READ            reduce using rule 57 (statement2 -> condition .)
    PRINT           reduce using rule 57 (statement2 -> condition .)
    MAP             reduce using rule 57 (statement2 -> condition .)
    RETURN          reduce using rule 57 (statement2 -> condition .)
    IF              reduce using rule 57 (statement2 -> condition .)
    WHILE           reduce using rule 57 (statement2 -> condition .)
    }               reduce using rule 57 (statement2 -> condition .)


state 81

    (28) condition -> IF . ( expression ) block condition1

    (               shift and go to state 110


state 82

    (51) statement1 -> set_operation .

    ;               reduce using rule 51 (statement1 -> set_operation .)


state 83

    (58) statement2 -> while .

    ID              reduce using rule 58 (statement2 -> while .)
    READ            reduce using rule 58 (statement2 -> while .)
    PRINT           reduce using rule 58 (statement2 -> while .)
    MAP             reduce using rule 58 (statement2 -> while .)
    RETURN          reduce using rule 58 (statement2 -> while .)
    IF              reduce using rule 58 (statement2 -> while .)
    WHILE           reduce using rule 58 (statement2 -> while .)
    }               reduce using rule 58 (statement2 -> while .)


state 84

    (50) statement1 -> output .

    ;               reduce using rule 50 (statement1 -> output .)


state 85

    (15) proc2 -> , datatype . ID proc2

    ID              shift and go to state 111


state 86

    (123) map_definition -> MAP < datatype , datatype . >

    >               shift and go to state 112


state 87

    (52) statement1 -> map_definition .

    ;               reduce using rule 52 (statement1 -> map_definition .)


state 88

    (119) main -> MAIN n_clear_scope { vars_aux statement_aux . }

    }               shift and go to state 113


state 89

    (117) statement_aux -> statement . statement_aux
    (117) statement_aux -> . statement statement_aux
    (118) statement_aux -> . empty
    (46) statement -> . statement1 ;
    (47) statement -> . statement2
    (127) empty -> .
    (48) statement1 -> . assignment
    (49) statement1 -> . input
    (50) statement1 -> . output
    (51) statement1 -> . set_operation
    (52) statement1 -> . map_definition
    (53) statement1 -> . return
    (54) statement1 -> . map_assignment
    (55) statement1 -> . map_operation
    (56) statement1 -> . function_call
    (57) statement2 -> . condition
    (58) statement2 -> . while
    (27) assignment -> . ID ASSIGNATOR expression
    (31) input -> . READ ( ID input1 )
    (34) output -> . PRINT ( expression output1 )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )
    (123) map_definition -> . MAP < datatype , datatype >
    (42) return -> . RETURN expression
    (125) map_assignment -> . map_access ASSIGNATOR exp
    (126) map_operation -> . ID . OPERATION ( )
    (37) function_call -> . ID ( function_call1 )
    (28) condition -> . IF ( expression ) block condition1
    (59) while -> . WHILE ( expression ) block
    (124) map_access -> . ID ( exp )

    }               reduce using rule 127 (empty -> .)
    ID              shift and go to state 79
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 81
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 87
    function_call                  shift and go to state 64
    statement_aux                  shift and go to state 114
    map_access                     shift and go to state 70
    statement                      shift and go to state 89
    input                          shift and go to state 73
    empty                          shift and go to state 90
    return                         shift and go to state 77
    statement2                     shift and go to state 69
    statement1                     shift and go to state 75
    assignment                     shift and go to state 76
    map_operation                  shift and go to state 78
    condition                      shift and go to state 80
    set_operation                  shift and go to state 82
    map_assignment                 shift and go to state 62
    while                          shift and go to state 83
    output                         shift and go to state 84

state 90

    (118) statement_aux -> empty .

    }               reduce using rule 118 (statement_aux -> empty .)


state 91

    (21) vars -> var vars .

    ID              reduce using rule 21 (vars -> var vars .)
    READ            reduce using rule 21 (vars -> var vars .)
    PRINT           reduce using rule 21 (vars -> var vars .)
    MAP             reduce using rule 21 (vars -> var vars .)
    RETURN          reduce using rule 21 (vars -> var vars .)
    IF              reduce using rule 21 (vars -> var vars .)
    WHILE           reduce using rule 21 (vars -> var vars .)
    }               reduce using rule 21 (vars -> var vars .)


state 92

    (82) term -> term_not . factor n_quad_muldiv term2
    (90) factor -> . ( n_push_false_bottom expression ) n_pop_false_bottom
    (91) factor -> . varcte
    (94) varcte -> . ID n_push_operand
    (95) varcte -> . varcte1
    (97) varcte1 -> . CTE_INT
    (98) varcte1 -> . CTE_FLOAT
    (99) varcte1 -> . CTE_BOOL
    (100) varcte1 -> . CTE_STRING
    (101) varcte1 -> . CTE_CHAR
    (102) varcte1 -> . function_call
    (103) varcte1 -> . map_access
    (104) varcte1 -> . map_operation
    (105) varcte1 -> . set_operation
    (37) function_call -> . ID ( function_call1 )
    (124) map_access -> . ID ( exp )
    (126) map_operation -> . ID . OPERATION ( )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )

    (               shift and go to state 117
    ID              shift and go to state 122
    CTE_INT         shift and go to state 121
    CTE_FLOAT       shift and go to state 125
    CTE_BOOL        shift and go to state 126
    CTE_STRING      shift and go to state 127
    CTE_CHAR        shift and go to state 119

    map_access                     shift and go to state 128
    set_operation                  shift and go to state 124
    function_call                  shift and go to state 115
    factor                         shift and go to state 118
    varcte1                        shift and go to state 116
    map_operation                  shift and go to state 120
    varcte                         shift and go to state 123

state 93

    (75) exp -> term . exp2
    (80) exp2 -> . addsub term n_quad_addsub exp2
    (81) exp2 -> . empty
    (76) addsub -> . +
    (77) addsub -> . -
    (127) empty -> .

    +               shift and go to state 130
    -               shift and go to state 131
    <               reduce using rule 127 (empty -> .)
    >               reduce using rule 127 (empty -> .)
    NOT_EQ          reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    LEQ             reduce using rule 127 (empty -> .)
    GEQ             reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    exp2                           shift and go to state 129
    addsub                         shift and go to state 132
    empty                          shift and go to state 133

state 94

    (68) expression -> exp0 . expression2
    (69) expression2 -> . logop exp0 n_quad_logop expression2
    (70) expression2 -> . empty
    (66) logop -> . OR
    (67) logop -> . AND
    (127) empty -> .

    OR              shift and go to state 137
    AND             shift and go to state 134
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 138
    expression2                    shift and go to state 136
    logop                          shift and go to state 135

state 95

    (88) term_not -> ! .

    (               reduce using rule 88 (term_not -> ! .)
    ID              reduce using rule 88 (term_not -> ! .)
    CTE_INT         reduce using rule 88 (term_not -> ! .)
    CTE_FLOAT       reduce using rule 88 (term_not -> ! .)
    CTE_BOOL        reduce using rule 88 (term_not -> ! .)
    CTE_STRING      reduce using rule 88 (term_not -> ! .)
    CTE_CHAR        reduce using rule 88 (term_not -> ! .)


state 96

    (72) exp0 -> exp . exp02
    (73) exp02 -> . relop exp
    (74) exp02 -> . empty
    (60) relop -> . <
    (61) relop -> . >
    (62) relop -> . NOT_EQ
    (63) relop -> . EQ
    (64) relop -> . LEQ
    (65) relop -> . GEQ
    (127) empty -> .

    <               shift and go to state 145
    >               shift and go to state 147
    NOT_EQ          shift and go to state 141
    EQ              shift and go to state 144
    LEQ             shift and go to state 142
    GEQ             shift and go to state 139
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    exp02                          shift and go to state 143
    empty                          shift and go to state 146
    relop                          shift and go to state 140

state 97

    (42) return -> RETURN expression .

    ;               reduce using rule 42 (return -> RETURN expression .)


state 98

    (89) term_not -> empty .

    (               reduce using rule 89 (term_not -> empty .)
    ID              reduce using rule 89 (term_not -> empty .)
    CTE_INT         reduce using rule 89 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 89 (term_not -> empty .)
    CTE_BOOL        reduce using rule 89 (term_not -> empty .)
    CTE_STRING      reduce using rule 89 (term_not -> empty .)
    CTE_CHAR        reduce using rule 89 (term_not -> empty .)


state 99

    (31) input -> READ ( . ID input1 )

    ID              shift and go to state 148


state 100

    (59) while -> WHILE ( . expression ) block
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    empty                          shift and go to state 98
    exp                            shift and go to state 96
    expression                     shift and go to state 149

state 101

    (34) output -> PRINT ( . expression output1 )
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 150
    empty                          shift and go to state 98

state 102

    (12) procA -> proc1 ) { proc3 } .

    VOID            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    MAIN            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    INT             reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    FLOAT           reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    BOOL            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    STRING          reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    CHAR            reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    SET             reduce using rule 12 (procA -> proc1 ) { proc3 } .)
    MAP             reduce using rule 12 (procA -> proc1 ) { proc3 } .)


state 103

    (125) map_assignment -> map_access ASSIGNATOR . exp
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp                            shift and go to state 151
    empty                          shift and go to state 98

state 104

    (19) proc4 -> statement proc4 .

    }               reduce using rule 19 (proc4 -> statement proc4 .)


state 105

    (17) proc3 -> var proc3 .

    }               reduce using rule 17 (proc3 -> var proc3 .)


state 106

    (46) statement -> statement1 ; .

    ID              reduce using rule 46 (statement -> statement1 ; .)
    READ            reduce using rule 46 (statement -> statement1 ; .)
    PRINT           reduce using rule 46 (statement -> statement1 ; .)
    MAP             reduce using rule 46 (statement -> statement1 ; .)
    RETURN          reduce using rule 46 (statement -> statement1 ; .)
    IF              reduce using rule 46 (statement -> statement1 ; .)
    WHILE           reduce using rule 46 (statement -> statement1 ; .)
    }               reduce using rule 46 (statement -> statement1 ; .)


state 107

    (37) function_call -> ID ( . function_call1 )
    (124) map_access -> ID ( . exp )
    (38) function_call1 -> . empty
    (39) function_call1 -> . function_call2
    (75) exp -> . term exp2
    (127) empty -> .
    (40) function_call2 -> . expression , function_call2
    (41) function_call2 -> . expression
    (82) term -> . term_not factor n_quad_muldiv term2
    (68) expression -> . exp0 expression2
    (88) term_not -> . !
    (89) term_not -> . empty
    (72) exp0 -> . exp exp02

    )               reduce using rule 127 (empty -> .)
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)
    !               shift and go to state 95

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    function_call1                 shift and go to state 152
    exp0                           shift and go to state 94
    function_call2                 shift and go to state 153
    exp                            shift and go to state 154
    expression                     shift and go to state 155
    empty                          shift and go to state 156

state 108

    (43) set_operation -> ID . . OPERATION ( set_operation1 )
    (126) map_operation -> ID . . OPERATION ( )

    OPERATION       shift and go to state 157


state 109

    (27) assignment -> ID ASSIGNATOR . expression
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 158
    empty                          shift and go to state 98

state 110

    (28) condition -> IF ( . expression ) block condition1
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    empty                          shift and go to state 98
    exp                            shift and go to state 96
    expression                     shift and go to state 159

state 111

    (15) proc2 -> , datatype ID . proc2
    (15) proc2 -> . , datatype ID proc2
    (16) proc2 -> . empty
    (127) empty -> .

    ,               shift and go to state 48
    )               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 49
    proc2                          shift and go to state 160

state 112

    (123) map_definition -> MAP < datatype , datatype > .

    ID              reduce using rule 123 (map_definition -> MAP < datatype , datatype > .)
    ,               reduce using rule 123 (map_definition -> MAP < datatype , datatype > .)
    ;               reduce using rule 123 (map_definition -> MAP < datatype , datatype > .)
    >               reduce using rule 123 (map_definition -> MAP < datatype , datatype > .)


state 113

    (119) main -> MAIN n_clear_scope { vars_aux statement_aux } .

    $end            reduce using rule 119 (main -> MAIN n_clear_scope { vars_aux statement_aux } .)


state 114

    (117) statement_aux -> statement statement_aux .

    }               reduce using rule 117 (statement_aux -> statement statement_aux .)


state 115

    (102) varcte1 -> function_call .

    *               reduce using rule 102 (varcte1 -> function_call .)
    /               reduce using rule 102 (varcte1 -> function_call .)
    +               reduce using rule 102 (varcte1 -> function_call .)
    -               reduce using rule 102 (varcte1 -> function_call .)
    <               reduce using rule 102 (varcte1 -> function_call .)
    >               reduce using rule 102 (varcte1 -> function_call .)
    NOT_EQ          reduce using rule 102 (varcte1 -> function_call .)
    EQ              reduce using rule 102 (varcte1 -> function_call .)
    LEQ             reduce using rule 102 (varcte1 -> function_call .)
    GEQ             reduce using rule 102 (varcte1 -> function_call .)
    OR              reduce using rule 102 (varcte1 -> function_call .)
    AND             reduce using rule 102 (varcte1 -> function_call .)
    ;               reduce using rule 102 (varcte1 -> function_call .)
    )               reduce using rule 102 (varcte1 -> function_call .)
    ,               reduce using rule 102 (varcte1 -> function_call .)


state 116

    (95) varcte -> varcte1 .

    *               reduce using rule 95 (varcte -> varcte1 .)
    /               reduce using rule 95 (varcte -> varcte1 .)
    +               reduce using rule 95 (varcte -> varcte1 .)
    -               reduce using rule 95 (varcte -> varcte1 .)
    <               reduce using rule 95 (varcte -> varcte1 .)
    >               reduce using rule 95 (varcte -> varcte1 .)
    NOT_EQ          reduce using rule 95 (varcte -> varcte1 .)
    EQ              reduce using rule 95 (varcte -> varcte1 .)
    LEQ             reduce using rule 95 (varcte -> varcte1 .)
    GEQ             reduce using rule 95 (varcte -> varcte1 .)
    OR              reduce using rule 95 (varcte -> varcte1 .)
    AND             reduce using rule 95 (varcte -> varcte1 .)
    ;               reduce using rule 95 (varcte -> varcte1 .)
    )               reduce using rule 95 (varcte -> varcte1 .)
    ,               reduce using rule 95 (varcte -> varcte1 .)


state 117

    (90) factor -> ( . n_push_false_bottom expression ) n_pop_false_bottom
    (92) n_push_false_bottom -> .

    !               reduce using rule 92 (n_push_false_bottom -> .)
    (               reduce using rule 92 (n_push_false_bottom -> .)
    ID              reduce using rule 92 (n_push_false_bottom -> .)
    CTE_INT         reduce using rule 92 (n_push_false_bottom -> .)
    CTE_FLOAT       reduce using rule 92 (n_push_false_bottom -> .)
    CTE_BOOL        reduce using rule 92 (n_push_false_bottom -> .)
    CTE_STRING      reduce using rule 92 (n_push_false_bottom -> .)
    CTE_CHAR        reduce using rule 92 (n_push_false_bottom -> .)

    n_push_false_bottom            shift and go to state 161

state 118

    (82) term -> term_not factor . n_quad_muldiv term2
    (83) n_quad_muldiv -> .

    *               reduce using rule 83 (n_quad_muldiv -> .)
    /               reduce using rule 83 (n_quad_muldiv -> .)
    +               reduce using rule 83 (n_quad_muldiv -> .)
    -               reduce using rule 83 (n_quad_muldiv -> .)
    <               reduce using rule 83 (n_quad_muldiv -> .)
    >               reduce using rule 83 (n_quad_muldiv -> .)
    NOT_EQ          reduce using rule 83 (n_quad_muldiv -> .)
    EQ              reduce using rule 83 (n_quad_muldiv -> .)
    LEQ             reduce using rule 83 (n_quad_muldiv -> .)
    GEQ             reduce using rule 83 (n_quad_muldiv -> .)
    OR              reduce using rule 83 (n_quad_muldiv -> .)
    AND             reduce using rule 83 (n_quad_muldiv -> .)
    ;               reduce using rule 83 (n_quad_muldiv -> .)
    )               reduce using rule 83 (n_quad_muldiv -> .)
    ,               reduce using rule 83 (n_quad_muldiv -> .)

    n_quad_muldiv                  shift and go to state 162

state 119

    (101) varcte1 -> CTE_CHAR .

    *               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    /               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    +               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    -               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    <               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    >               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    NOT_EQ          reduce using rule 101 (varcte1 -> CTE_CHAR .)
    EQ              reduce using rule 101 (varcte1 -> CTE_CHAR .)
    LEQ             reduce using rule 101 (varcte1 -> CTE_CHAR .)
    GEQ             reduce using rule 101 (varcte1 -> CTE_CHAR .)
    OR              reduce using rule 101 (varcte1 -> CTE_CHAR .)
    AND             reduce using rule 101 (varcte1 -> CTE_CHAR .)
    ;               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    )               reduce using rule 101 (varcte1 -> CTE_CHAR .)
    ,               reduce using rule 101 (varcte1 -> CTE_CHAR .)


state 120

    (104) varcte1 -> map_operation .

    *               reduce using rule 104 (varcte1 -> map_operation .)
    /               reduce using rule 104 (varcte1 -> map_operation .)
    +               reduce using rule 104 (varcte1 -> map_operation .)
    -               reduce using rule 104 (varcte1 -> map_operation .)
    <               reduce using rule 104 (varcte1 -> map_operation .)
    >               reduce using rule 104 (varcte1 -> map_operation .)
    NOT_EQ          reduce using rule 104 (varcte1 -> map_operation .)
    EQ              reduce using rule 104 (varcte1 -> map_operation .)
    LEQ             reduce using rule 104 (varcte1 -> map_operation .)
    GEQ             reduce using rule 104 (varcte1 -> map_operation .)
    OR              reduce using rule 104 (varcte1 -> map_operation .)
    AND             reduce using rule 104 (varcte1 -> map_operation .)
    ;               reduce using rule 104 (varcte1 -> map_operation .)
    )               reduce using rule 104 (varcte1 -> map_operation .)
    ,               reduce using rule 104 (varcte1 -> map_operation .)


state 121

    (97) varcte1 -> CTE_INT .

    *               reduce using rule 97 (varcte1 -> CTE_INT .)
    /               reduce using rule 97 (varcte1 -> CTE_INT .)
    +               reduce using rule 97 (varcte1 -> CTE_INT .)
    -               reduce using rule 97 (varcte1 -> CTE_INT .)
    <               reduce using rule 97 (varcte1 -> CTE_INT .)
    >               reduce using rule 97 (varcte1 -> CTE_INT .)
    NOT_EQ          reduce using rule 97 (varcte1 -> CTE_INT .)
    EQ              reduce using rule 97 (varcte1 -> CTE_INT .)
    LEQ             reduce using rule 97 (varcte1 -> CTE_INT .)
    GEQ             reduce using rule 97 (varcte1 -> CTE_INT .)
    OR              reduce using rule 97 (varcte1 -> CTE_INT .)
    AND             reduce using rule 97 (varcte1 -> CTE_INT .)
    ;               reduce using rule 97 (varcte1 -> CTE_INT .)
    )               reduce using rule 97 (varcte1 -> CTE_INT .)
    ,               reduce using rule 97 (varcte1 -> CTE_INT .)


state 122

    (94) varcte -> ID . n_push_operand
    (37) function_call -> ID . ( function_call1 )
    (124) map_access -> ID . ( exp )
    (126) map_operation -> ID . . OPERATION ( )
    (43) set_operation -> ID . . OPERATION ( set_operation1 )
    (96) n_push_operand -> .

    (               shift and go to state 107
    .               shift and go to state 163
    *               reduce using rule 96 (n_push_operand -> .)
    /               reduce using rule 96 (n_push_operand -> .)
    +               reduce using rule 96 (n_push_operand -> .)
    -               reduce using rule 96 (n_push_operand -> .)
    <               reduce using rule 96 (n_push_operand -> .)
    >               reduce using rule 96 (n_push_operand -> .)
    NOT_EQ          reduce using rule 96 (n_push_operand -> .)
    EQ              reduce using rule 96 (n_push_operand -> .)
    LEQ             reduce using rule 96 (n_push_operand -> .)
    GEQ             reduce using rule 96 (n_push_operand -> .)
    OR              reduce using rule 96 (n_push_operand -> .)
    AND             reduce using rule 96 (n_push_operand -> .)
    ;               reduce using rule 96 (n_push_operand -> .)
    )               reduce using rule 96 (n_push_operand -> .)
    ,               reduce using rule 96 (n_push_operand -> .)

    n_push_operand                 shift and go to state 164

state 123

    (91) factor -> varcte .

    *               reduce using rule 91 (factor -> varcte .)
    /               reduce using rule 91 (factor -> varcte .)
    +               reduce using rule 91 (factor -> varcte .)
    -               reduce using rule 91 (factor -> varcte .)
    <               reduce using rule 91 (factor -> varcte .)
    >               reduce using rule 91 (factor -> varcte .)
    NOT_EQ          reduce using rule 91 (factor -> varcte .)
    EQ              reduce using rule 91 (factor -> varcte .)
    LEQ             reduce using rule 91 (factor -> varcte .)
    GEQ             reduce using rule 91 (factor -> varcte .)
    OR              reduce using rule 91 (factor -> varcte .)
    AND             reduce using rule 91 (factor -> varcte .)
    ;               reduce using rule 91 (factor -> varcte .)
    )               reduce using rule 91 (factor -> varcte .)
    ,               reduce using rule 91 (factor -> varcte .)


state 124

    (105) varcte1 -> set_operation .

    *               reduce using rule 105 (varcte1 -> set_operation .)
    /               reduce using rule 105 (varcte1 -> set_operation .)
    +               reduce using rule 105 (varcte1 -> set_operation .)
    -               reduce using rule 105 (varcte1 -> set_operation .)
    <               reduce using rule 105 (varcte1 -> set_operation .)
    >               reduce using rule 105 (varcte1 -> set_operation .)
    NOT_EQ          reduce using rule 105 (varcte1 -> set_operation .)
    EQ              reduce using rule 105 (varcte1 -> set_operation .)
    LEQ             reduce using rule 105 (varcte1 -> set_operation .)
    GEQ             reduce using rule 105 (varcte1 -> set_operation .)
    OR              reduce using rule 105 (varcte1 -> set_operation .)
    AND             reduce using rule 105 (varcte1 -> set_operation .)
    ;               reduce using rule 105 (varcte1 -> set_operation .)
    )               reduce using rule 105 (varcte1 -> set_operation .)
    ,               reduce using rule 105 (varcte1 -> set_operation .)


state 125

    (98) varcte1 -> CTE_FLOAT .

    *               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    /               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    +               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    -               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    <               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    >               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    NOT_EQ          reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    EQ              reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    LEQ             reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    GEQ             reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    OR              reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    AND             reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    ;               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    )               reduce using rule 98 (varcte1 -> CTE_FLOAT .)
    ,               reduce using rule 98 (varcte1 -> CTE_FLOAT .)


state 126

    (99) varcte1 -> CTE_BOOL .

    *               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    /               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    +               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    -               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    <               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    >               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    NOT_EQ          reduce using rule 99 (varcte1 -> CTE_BOOL .)
    EQ              reduce using rule 99 (varcte1 -> CTE_BOOL .)
    LEQ             reduce using rule 99 (varcte1 -> CTE_BOOL .)
    GEQ             reduce using rule 99 (varcte1 -> CTE_BOOL .)
    OR              reduce using rule 99 (varcte1 -> CTE_BOOL .)
    AND             reduce using rule 99 (varcte1 -> CTE_BOOL .)
    ;               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    )               reduce using rule 99 (varcte1 -> CTE_BOOL .)
    ,               reduce using rule 99 (varcte1 -> CTE_BOOL .)


state 127

    (100) varcte1 -> CTE_STRING .

    *               reduce using rule 100 (varcte1 -> CTE_STRING .)
    /               reduce using rule 100 (varcte1 -> CTE_STRING .)
    +               reduce using rule 100 (varcte1 -> CTE_STRING .)
    -               reduce using rule 100 (varcte1 -> CTE_STRING .)
    <               reduce using rule 100 (varcte1 -> CTE_STRING .)
    >               reduce using rule 100 (varcte1 -> CTE_STRING .)
    NOT_EQ          reduce using rule 100 (varcte1 -> CTE_STRING .)
    EQ              reduce using rule 100 (varcte1 -> CTE_STRING .)
    LEQ             reduce using rule 100 (varcte1 -> CTE_STRING .)
    GEQ             reduce using rule 100 (varcte1 -> CTE_STRING .)
    OR              reduce using rule 100 (varcte1 -> CTE_STRING .)
    AND             reduce using rule 100 (varcte1 -> CTE_STRING .)
    ;               reduce using rule 100 (varcte1 -> CTE_STRING .)
    )               reduce using rule 100 (varcte1 -> CTE_STRING .)
    ,               reduce using rule 100 (varcte1 -> CTE_STRING .)


state 128

    (103) varcte1 -> map_access .

    *               reduce using rule 103 (varcte1 -> map_access .)
    /               reduce using rule 103 (varcte1 -> map_access .)
    +               reduce using rule 103 (varcte1 -> map_access .)
    -               reduce using rule 103 (varcte1 -> map_access .)
    <               reduce using rule 103 (varcte1 -> map_access .)
    >               reduce using rule 103 (varcte1 -> map_access .)
    NOT_EQ          reduce using rule 103 (varcte1 -> map_access .)
    EQ              reduce using rule 103 (varcte1 -> map_access .)
    LEQ             reduce using rule 103 (varcte1 -> map_access .)
    GEQ             reduce using rule 103 (varcte1 -> map_access .)
    OR              reduce using rule 103 (varcte1 -> map_access .)
    AND             reduce using rule 103 (varcte1 -> map_access .)
    ;               reduce using rule 103 (varcte1 -> map_access .)
    )               reduce using rule 103 (varcte1 -> map_access .)
    ,               reduce using rule 103 (varcte1 -> map_access .)


state 129

    (75) exp -> term exp2 .

    <               reduce using rule 75 (exp -> term exp2 .)
    >               reduce using rule 75 (exp -> term exp2 .)
    NOT_EQ          reduce using rule 75 (exp -> term exp2 .)
    EQ              reduce using rule 75 (exp -> term exp2 .)
    LEQ             reduce using rule 75 (exp -> term exp2 .)
    GEQ             reduce using rule 75 (exp -> term exp2 .)
    OR              reduce using rule 75 (exp -> term exp2 .)
    AND             reduce using rule 75 (exp -> term exp2 .)
    ;               reduce using rule 75 (exp -> term exp2 .)
    )               reduce using rule 75 (exp -> term exp2 .)
    ,               reduce using rule 75 (exp -> term exp2 .)


state 130

    (76) addsub -> + .

    !               reduce using rule 76 (addsub -> + .)
    (               reduce using rule 76 (addsub -> + .)
    ID              reduce using rule 76 (addsub -> + .)
    CTE_INT         reduce using rule 76 (addsub -> + .)
    CTE_FLOAT       reduce using rule 76 (addsub -> + .)
    CTE_BOOL        reduce using rule 76 (addsub -> + .)
    CTE_STRING      reduce using rule 76 (addsub -> + .)
    CTE_CHAR        reduce using rule 76 (addsub -> + .)


state 131

    (77) addsub -> - .

    !               reduce using rule 77 (addsub -> - .)
    (               reduce using rule 77 (addsub -> - .)
    ID              reduce using rule 77 (addsub -> - .)
    CTE_INT         reduce using rule 77 (addsub -> - .)
    CTE_FLOAT       reduce using rule 77 (addsub -> - .)
    CTE_BOOL        reduce using rule 77 (addsub -> - .)
    CTE_STRING      reduce using rule 77 (addsub -> - .)
    CTE_CHAR        reduce using rule 77 (addsub -> - .)


state 132

    (80) exp2 -> addsub . term n_quad_addsub exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 165
    empty                          shift and go to state 98

state 133

    (81) exp2 -> empty .

    <               reduce using rule 81 (exp2 -> empty .)
    >               reduce using rule 81 (exp2 -> empty .)
    NOT_EQ          reduce using rule 81 (exp2 -> empty .)
    EQ              reduce using rule 81 (exp2 -> empty .)
    LEQ             reduce using rule 81 (exp2 -> empty .)
    GEQ             reduce using rule 81 (exp2 -> empty .)
    OR              reduce using rule 81 (exp2 -> empty .)
    AND             reduce using rule 81 (exp2 -> empty .)
    ;               reduce using rule 81 (exp2 -> empty .)
    )               reduce using rule 81 (exp2 -> empty .)
    ,               reduce using rule 81 (exp2 -> empty .)


state 134

    (67) logop -> AND .

    !               reduce using rule 67 (logop -> AND .)
    (               reduce using rule 67 (logop -> AND .)
    ID              reduce using rule 67 (logop -> AND .)
    CTE_INT         reduce using rule 67 (logop -> AND .)
    CTE_FLOAT       reduce using rule 67 (logop -> AND .)
    CTE_BOOL        reduce using rule 67 (logop -> AND .)
    CTE_STRING      reduce using rule 67 (logop -> AND .)
    CTE_CHAR        reduce using rule 67 (logop -> AND .)


state 135

    (69) expression2 -> logop . exp0 n_quad_logop expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    exp0                           shift and go to state 166
    term                           shift and go to state 93
    exp                            shift and go to state 96
    empty                          shift and go to state 98

state 136

    (68) expression -> exp0 expression2 .

    )               reduce using rule 68 (expression -> exp0 expression2 .)
    ,               reduce using rule 68 (expression -> exp0 expression2 .)
    ;               reduce using rule 68 (expression -> exp0 expression2 .)


state 137

    (66) logop -> OR .

    !               reduce using rule 66 (logop -> OR .)
    (               reduce using rule 66 (logop -> OR .)
    ID              reduce using rule 66 (logop -> OR .)
    CTE_INT         reduce using rule 66 (logop -> OR .)
    CTE_FLOAT       reduce using rule 66 (logop -> OR .)
    CTE_BOOL        reduce using rule 66 (logop -> OR .)
    CTE_STRING      reduce using rule 66 (logop -> OR .)
    CTE_CHAR        reduce using rule 66 (logop -> OR .)


state 138

    (70) expression2 -> empty .

    ;               reduce using rule 70 (expression2 -> empty .)
    )               reduce using rule 70 (expression2 -> empty .)
    ,               reduce using rule 70 (expression2 -> empty .)


state 139

    (65) relop -> GEQ .

    !               reduce using rule 65 (relop -> GEQ .)
    (               reduce using rule 65 (relop -> GEQ .)
    ID              reduce using rule 65 (relop -> GEQ .)
    CTE_INT         reduce using rule 65 (relop -> GEQ .)
    CTE_FLOAT       reduce using rule 65 (relop -> GEQ .)
    CTE_BOOL        reduce using rule 65 (relop -> GEQ .)
    CTE_STRING      reduce using rule 65 (relop -> GEQ .)
    CTE_CHAR        reduce using rule 65 (relop -> GEQ .)


state 140

    (73) exp02 -> relop . exp
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp                            shift and go to state 167
    empty                          shift and go to state 98

state 141

    (62) relop -> NOT_EQ .

    !               reduce using rule 62 (relop -> NOT_EQ .)
    (               reduce using rule 62 (relop -> NOT_EQ .)
    ID              reduce using rule 62 (relop -> NOT_EQ .)
    CTE_INT         reduce using rule 62 (relop -> NOT_EQ .)
    CTE_FLOAT       reduce using rule 62 (relop -> NOT_EQ .)
    CTE_BOOL        reduce using rule 62 (relop -> NOT_EQ .)
    CTE_STRING      reduce using rule 62 (relop -> NOT_EQ .)
    CTE_CHAR        reduce using rule 62 (relop -> NOT_EQ .)


state 142

    (64) relop -> LEQ .

    !               reduce using rule 64 (relop -> LEQ .)
    (               reduce using rule 64 (relop -> LEQ .)
    ID              reduce using rule 64 (relop -> LEQ .)
    CTE_INT         reduce using rule 64 (relop -> LEQ .)
    CTE_FLOAT       reduce using rule 64 (relop -> LEQ .)
    CTE_BOOL        reduce using rule 64 (relop -> LEQ .)
    CTE_STRING      reduce using rule 64 (relop -> LEQ .)
    CTE_CHAR        reduce using rule 64 (relop -> LEQ .)


state 143

    (72) exp0 -> exp exp02 .

    OR              reduce using rule 72 (exp0 -> exp exp02 .)
    AND             reduce using rule 72 (exp0 -> exp exp02 .)
    ;               reduce using rule 72 (exp0 -> exp exp02 .)
    )               reduce using rule 72 (exp0 -> exp exp02 .)
    ,               reduce using rule 72 (exp0 -> exp exp02 .)


state 144

    (63) relop -> EQ .

    !               reduce using rule 63 (relop -> EQ .)
    (               reduce using rule 63 (relop -> EQ .)
    ID              reduce using rule 63 (relop -> EQ .)
    CTE_INT         reduce using rule 63 (relop -> EQ .)
    CTE_FLOAT       reduce using rule 63 (relop -> EQ .)
    CTE_BOOL        reduce using rule 63 (relop -> EQ .)
    CTE_STRING      reduce using rule 63 (relop -> EQ .)
    CTE_CHAR        reduce using rule 63 (relop -> EQ .)


state 145

    (60) relop -> < .

    !               reduce using rule 60 (relop -> < .)
    (               reduce using rule 60 (relop -> < .)
    ID              reduce using rule 60 (relop -> < .)
    CTE_INT         reduce using rule 60 (relop -> < .)
    CTE_FLOAT       reduce using rule 60 (relop -> < .)
    CTE_BOOL        reduce using rule 60 (relop -> < .)
    CTE_STRING      reduce using rule 60 (relop -> < .)
    CTE_CHAR        reduce using rule 60 (relop -> < .)


state 146

    (74) exp02 -> empty .

    OR              reduce using rule 74 (exp02 -> empty .)
    AND             reduce using rule 74 (exp02 -> empty .)
    ;               reduce using rule 74 (exp02 -> empty .)
    )               reduce using rule 74 (exp02 -> empty .)
    ,               reduce using rule 74 (exp02 -> empty .)


state 147

    (61) relop -> > .

    !               reduce using rule 61 (relop -> > .)
    (               reduce using rule 61 (relop -> > .)
    ID              reduce using rule 61 (relop -> > .)
    CTE_INT         reduce using rule 61 (relop -> > .)
    CTE_FLOAT       reduce using rule 61 (relop -> > .)
    CTE_BOOL        reduce using rule 61 (relop -> > .)
    CTE_STRING      reduce using rule 61 (relop -> > .)
    CTE_CHAR        reduce using rule 61 (relop -> > .)


state 148

    (31) input -> READ ( ID . input1 )
    (32) input1 -> . , ID input1
    (33) input1 -> . empty
    (127) empty -> .

    ,               shift and go to state 169
    )               reduce using rule 127 (empty -> .)

    input1                         shift and go to state 168
    empty                          shift and go to state 170

state 149

    (59) while -> WHILE ( expression . ) block

    )               shift and go to state 171


state 150

    (34) output -> PRINT ( expression . output1 )
    (35) output1 -> . , expression output1
    (36) output1 -> . empty
    (127) empty -> .

    ,               shift and go to state 173
    )               reduce using rule 127 (empty -> .)

    output1                        shift and go to state 172
    empty                          shift and go to state 174

state 151

    (125) map_assignment -> map_access ASSIGNATOR exp .

    ;               reduce using rule 125 (map_assignment -> map_access ASSIGNATOR exp .)


state 152

    (37) function_call -> ID ( function_call1 . )

    )               shift and go to state 175


state 153

    (39) function_call1 -> function_call2 .

    )               reduce using rule 39 (function_call1 -> function_call2 .)


state 154

    (124) map_access -> ID ( exp . )
    (72) exp0 -> exp . exp02
    (73) exp02 -> . relop exp
    (74) exp02 -> . empty
    (60) relop -> . <
    (61) relop -> . >
    (62) relop -> . NOT_EQ
    (63) relop -> . EQ
    (64) relop -> . LEQ
    (65) relop -> . GEQ
    (127) empty -> .

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 176
    <               shift and go to state 145
    >               shift and go to state 147
    NOT_EQ          shift and go to state 141
    EQ              shift and go to state 144
    LEQ             shift and go to state 142
    GEQ             shift and go to state 139
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

  ! )               [ reduce using rule 127 (empty -> .) ]

    exp02                          shift and go to state 143
    empty                          shift and go to state 146
    relop                          shift and go to state 140

state 155

    (40) function_call2 -> expression . , function_call2
    (41) function_call2 -> expression .

    ,               shift and go to state 177
    )               reduce using rule 41 (function_call2 -> expression .)


state 156

    (38) function_call1 -> empty .
    (89) term_not -> empty .

    )               reduce using rule 38 (function_call1 -> empty .)
    (               reduce using rule 89 (term_not -> empty .)
    ID              reduce using rule 89 (term_not -> empty .)
    CTE_INT         reduce using rule 89 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 89 (term_not -> empty .)
    CTE_BOOL        reduce using rule 89 (term_not -> empty .)
    CTE_STRING      reduce using rule 89 (term_not -> empty .)
    CTE_CHAR        reduce using rule 89 (term_not -> empty .)


state 157

    (43) set_operation -> ID . OPERATION . ( set_operation1 )
    (126) map_operation -> ID . OPERATION . ( )

    (               shift and go to state 178


state 158

    (27) assignment -> ID ASSIGNATOR expression .

    ;               reduce using rule 27 (assignment -> ID ASSIGNATOR expression .)


state 159

    (28) condition -> IF ( expression . ) block condition1

    )               shift and go to state 179


state 160

    (15) proc2 -> , datatype ID proc2 .

    )               reduce using rule 15 (proc2 -> , datatype ID proc2 .)


state 161

    (90) factor -> ( n_push_false_bottom . expression ) n_pop_false_bottom
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 180
    empty                          shift and go to state 98

state 162

    (82) term -> term_not factor n_quad_muldiv . term2
    (85) term2 -> . muldiv factor n_quad_muldiv term2
    (86) term2 -> . n_quad_not
    (78) muldiv -> . *
    (79) muldiv -> . /
    (87) n_quad_not -> .

    *               shift and go to state 182
    /               shift and go to state 184
    +               reduce using rule 87 (n_quad_not -> .)
    -               reduce using rule 87 (n_quad_not -> .)
    <               reduce using rule 87 (n_quad_not -> .)
    >               reduce using rule 87 (n_quad_not -> .)
    NOT_EQ          reduce using rule 87 (n_quad_not -> .)
    EQ              reduce using rule 87 (n_quad_not -> .)
    LEQ             reduce using rule 87 (n_quad_not -> .)
    GEQ             reduce using rule 87 (n_quad_not -> .)
    OR              reduce using rule 87 (n_quad_not -> .)
    AND             reduce using rule 87 (n_quad_not -> .)
    ;               reduce using rule 87 (n_quad_not -> .)
    )               reduce using rule 87 (n_quad_not -> .)
    ,               reduce using rule 87 (n_quad_not -> .)

    term2                          shift and go to state 181
    n_quad_not                     shift and go to state 183
    muldiv                         shift and go to state 185

state 163

    (126) map_operation -> ID . . OPERATION ( )
    (43) set_operation -> ID . . OPERATION ( set_operation1 )

    OPERATION       shift and go to state 186


state 164

    (94) varcte -> ID n_push_operand .

    *               reduce using rule 94 (varcte -> ID n_push_operand .)
    /               reduce using rule 94 (varcte -> ID n_push_operand .)
    +               reduce using rule 94 (varcte -> ID n_push_operand .)
    -               reduce using rule 94 (varcte -> ID n_push_operand .)
    <               reduce using rule 94 (varcte -> ID n_push_operand .)
    >               reduce using rule 94 (varcte -> ID n_push_operand .)
    NOT_EQ          reduce using rule 94 (varcte -> ID n_push_operand .)
    EQ              reduce using rule 94 (varcte -> ID n_push_operand .)
    LEQ             reduce using rule 94 (varcte -> ID n_push_operand .)
    GEQ             reduce using rule 94 (varcte -> ID n_push_operand .)
    OR              reduce using rule 94 (varcte -> ID n_push_operand .)
    AND             reduce using rule 94 (varcte -> ID n_push_operand .)
    ;               reduce using rule 94 (varcte -> ID n_push_operand .)
    )               reduce using rule 94 (varcte -> ID n_push_operand .)
    ,               reduce using rule 94 (varcte -> ID n_push_operand .)


state 165

    (80) exp2 -> addsub term . n_quad_addsub exp2
    (84) n_quad_addsub -> .

    +               reduce using rule 84 (n_quad_addsub -> .)
    -               reduce using rule 84 (n_quad_addsub -> .)
    <               reduce using rule 84 (n_quad_addsub -> .)
    >               reduce using rule 84 (n_quad_addsub -> .)
    NOT_EQ          reduce using rule 84 (n_quad_addsub -> .)
    EQ              reduce using rule 84 (n_quad_addsub -> .)
    LEQ             reduce using rule 84 (n_quad_addsub -> .)
    GEQ             reduce using rule 84 (n_quad_addsub -> .)
    OR              reduce using rule 84 (n_quad_addsub -> .)
    AND             reduce using rule 84 (n_quad_addsub -> .)
    ;               reduce using rule 84 (n_quad_addsub -> .)
    )               reduce using rule 84 (n_quad_addsub -> .)
    ,               reduce using rule 84 (n_quad_addsub -> .)

    n_quad_addsub                  shift and go to state 187

state 166

    (69) expression2 -> logop exp0 . n_quad_logop expression2
    (71) n_quad_logop -> .

    OR              reduce using rule 71 (n_quad_logop -> .)
    AND             reduce using rule 71 (n_quad_logop -> .)
    ;               reduce using rule 71 (n_quad_logop -> .)
    )               reduce using rule 71 (n_quad_logop -> .)
    ,               reduce using rule 71 (n_quad_logop -> .)

    n_quad_logop                   shift and go to state 188

state 167

    (73) exp02 -> relop exp .

    OR              reduce using rule 73 (exp02 -> relop exp .)
    AND             reduce using rule 73 (exp02 -> relop exp .)
    ;               reduce using rule 73 (exp02 -> relop exp .)
    )               reduce using rule 73 (exp02 -> relop exp .)
    ,               reduce using rule 73 (exp02 -> relop exp .)


state 168

    (31) input -> READ ( ID input1 . )

    )               shift and go to state 189


state 169

    (32) input1 -> , . ID input1

    ID              shift and go to state 190


state 170

    (33) input1 -> empty .

    )               reduce using rule 33 (input1 -> empty .)


state 171

    (59) while -> WHILE ( expression ) . block
    (116) block -> . { statement_aux }

    {               shift and go to state 191

    block                          shift and go to state 192

state 172

    (34) output -> PRINT ( expression output1 . )

    )               shift and go to state 193


state 173

    (35) output1 -> , . expression output1
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 194
    empty                          shift and go to state 98

state 174

    (36) output1 -> empty .

    )               reduce using rule 36 (output1 -> empty .)


state 175

    (37) function_call -> ID ( function_call1 ) .

    ;               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    *               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    /               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    +               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    -               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    <               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    >               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    NOT_EQ          reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    EQ              reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    LEQ             reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    GEQ             reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    OR              reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    AND             reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    )               reduce using rule 37 (function_call -> ID ( function_call1 ) .)
    ,               reduce using rule 37 (function_call -> ID ( function_call1 ) .)


state 176

    (124) map_access -> ID ( exp ) .

    ASSIGNATOR      reduce using rule 124 (map_access -> ID ( exp ) .)
    *               reduce using rule 124 (map_access -> ID ( exp ) .)
    /               reduce using rule 124 (map_access -> ID ( exp ) .)
    +               reduce using rule 124 (map_access -> ID ( exp ) .)
    -               reduce using rule 124 (map_access -> ID ( exp ) .)
    <               reduce using rule 124 (map_access -> ID ( exp ) .)
    >               reduce using rule 124 (map_access -> ID ( exp ) .)
    NOT_EQ          reduce using rule 124 (map_access -> ID ( exp ) .)
    EQ              reduce using rule 124 (map_access -> ID ( exp ) .)
    LEQ             reduce using rule 124 (map_access -> ID ( exp ) .)
    GEQ             reduce using rule 124 (map_access -> ID ( exp ) .)
    OR              reduce using rule 124 (map_access -> ID ( exp ) .)
    AND             reduce using rule 124 (map_access -> ID ( exp ) .)
    ;               reduce using rule 124 (map_access -> ID ( exp ) .)
    )               reduce using rule 124 (map_access -> ID ( exp ) .)
    ,               reduce using rule 124 (map_access -> ID ( exp ) .)


state 177

    (40) function_call2 -> expression , . function_call2
    (40) function_call2 -> . expression , function_call2
    (41) function_call2 -> . expression
    (68) expression -> . exp0 expression2
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty
    (127) empty -> .

    !               shift and go to state 95
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)

    term_not                       shift and go to state 92
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    function_call2                 shift and go to state 195
    exp                            shift and go to state 96
    expression                     shift and go to state 155
    empty                          shift and go to state 98

state 178

    (43) set_operation -> ID . OPERATION ( . set_operation1 )
    (126) map_operation -> ID . OPERATION ( . )
    (44) set_operation1 -> . expression
    (45) set_operation1 -> . empty
    (68) expression -> . exp0 expression2
    (127) empty -> .
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 197
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)
    !               shift and go to state 95

  ! )               [ reduce using rule 127 (empty -> .) ]

    term_not                       shift and go to state 92
    set_operation1                 shift and go to state 196
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 198
    empty                          shift and go to state 199

state 179

    (28) condition -> IF ( expression ) . block condition1
    (116) block -> . { statement_aux }

    {               shift and go to state 191

    block                          shift and go to state 200

state 180

    (90) factor -> ( n_push_false_bottom expression . ) n_pop_false_bottom

    )               shift and go to state 201


state 181

    (82) term -> term_not factor n_quad_muldiv term2 .

    +               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    -               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    <               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    >               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    NOT_EQ          reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    EQ              reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    LEQ             reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    GEQ             reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    OR              reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    AND             reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    ,               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    )               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)
    ;               reduce using rule 82 (term -> term_not factor n_quad_muldiv term2 .)


state 182

    (78) muldiv -> * .

    (               reduce using rule 78 (muldiv -> * .)
    ID              reduce using rule 78 (muldiv -> * .)
    CTE_INT         reduce using rule 78 (muldiv -> * .)
    CTE_FLOAT       reduce using rule 78 (muldiv -> * .)
    CTE_BOOL        reduce using rule 78 (muldiv -> * .)
    CTE_STRING      reduce using rule 78 (muldiv -> * .)
    CTE_CHAR        reduce using rule 78 (muldiv -> * .)


state 183

    (86) term2 -> n_quad_not .

    +               reduce using rule 86 (term2 -> n_quad_not .)
    -               reduce using rule 86 (term2 -> n_quad_not .)
    <               reduce using rule 86 (term2 -> n_quad_not .)
    >               reduce using rule 86 (term2 -> n_quad_not .)
    NOT_EQ          reduce using rule 86 (term2 -> n_quad_not .)
    EQ              reduce using rule 86 (term2 -> n_quad_not .)
    LEQ             reduce using rule 86 (term2 -> n_quad_not .)
    GEQ             reduce using rule 86 (term2 -> n_quad_not .)
    OR              reduce using rule 86 (term2 -> n_quad_not .)
    AND             reduce using rule 86 (term2 -> n_quad_not .)
    ;               reduce using rule 86 (term2 -> n_quad_not .)
    )               reduce using rule 86 (term2 -> n_quad_not .)
    ,               reduce using rule 86 (term2 -> n_quad_not .)


state 184

    (79) muldiv -> / .

    (               reduce using rule 79 (muldiv -> / .)
    ID              reduce using rule 79 (muldiv -> / .)
    CTE_INT         reduce using rule 79 (muldiv -> / .)
    CTE_FLOAT       reduce using rule 79 (muldiv -> / .)
    CTE_BOOL        reduce using rule 79 (muldiv -> / .)
    CTE_STRING      reduce using rule 79 (muldiv -> / .)
    CTE_CHAR        reduce using rule 79 (muldiv -> / .)


state 185

    (85) term2 -> muldiv . factor n_quad_muldiv term2
    (90) factor -> . ( n_push_false_bottom expression ) n_pop_false_bottom
    (91) factor -> . varcte
    (94) varcte -> . ID n_push_operand
    (95) varcte -> . varcte1
    (97) varcte1 -> . CTE_INT
    (98) varcte1 -> . CTE_FLOAT
    (99) varcte1 -> . CTE_BOOL
    (100) varcte1 -> . CTE_STRING
    (101) varcte1 -> . CTE_CHAR
    (102) varcte1 -> . function_call
    (103) varcte1 -> . map_access
    (104) varcte1 -> . map_operation
    (105) varcte1 -> . set_operation
    (37) function_call -> . ID ( function_call1 )
    (124) map_access -> . ID ( exp )
    (126) map_operation -> . ID . OPERATION ( )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )

    (               shift and go to state 117
    ID              shift and go to state 122
    CTE_INT         shift and go to state 121
    CTE_FLOAT       shift and go to state 125
    CTE_BOOL        shift and go to state 126
    CTE_STRING      shift and go to state 127
    CTE_CHAR        shift and go to state 119

    map_operation                  shift and go to state 120
    map_access                     shift and go to state 128
    set_operation                  shift and go to state 124
    factor                         shift and go to state 202
    varcte1                        shift and go to state 116
    function_call                  shift and go to state 115
    varcte                         shift and go to state 123

state 186

    (126) map_operation -> ID . OPERATION . ( )
    (43) set_operation -> ID . OPERATION . ( set_operation1 )

    (               shift and go to state 203


state 187

    (80) exp2 -> addsub term n_quad_addsub . exp2
    (80) exp2 -> . addsub term n_quad_addsub exp2
    (81) exp2 -> . empty
    (76) addsub -> . +
    (77) addsub -> . -
    (127) empty -> .

    +               shift and go to state 130
    -               shift and go to state 131
    <               reduce using rule 127 (empty -> .)
    >               reduce using rule 127 (empty -> .)
    NOT_EQ          reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    LEQ             reduce using rule 127 (empty -> .)
    GEQ             reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    exp2                           shift and go to state 204
    addsub                         shift and go to state 132
    empty                          shift and go to state 133

state 188

    (69) expression2 -> logop exp0 n_quad_logop . expression2
    (69) expression2 -> . logop exp0 n_quad_logop expression2
    (70) expression2 -> . empty
    (66) logop -> . OR
    (67) logop -> . AND
    (127) empty -> .

    OR              shift and go to state 137
    AND             shift and go to state 134
    ;               reduce using rule 127 (empty -> .)
    )               reduce using rule 127 (empty -> .)
    ,               reduce using rule 127 (empty -> .)

    logop                          shift and go to state 135
    empty                          shift and go to state 138
    expression2                    shift and go to state 205

state 189

    (31) input -> READ ( ID input1 ) .

    ;               reduce using rule 31 (input -> READ ( ID input1 ) .)


state 190

    (32) input1 -> , ID . input1
    (32) input1 -> . , ID input1
    (33) input1 -> . empty
    (127) empty -> .

    ,               shift and go to state 169
    )               reduce using rule 127 (empty -> .)

    input1                         shift and go to state 206
    empty                          shift and go to state 170

state 191

    (116) block -> { . statement_aux }
    (117) statement_aux -> . statement statement_aux
    (118) statement_aux -> . empty
    (46) statement -> . statement1 ;
    (47) statement -> . statement2
    (127) empty -> .
    (48) statement1 -> . assignment
    (49) statement1 -> . input
    (50) statement1 -> . output
    (51) statement1 -> . set_operation
    (52) statement1 -> . map_definition
    (53) statement1 -> . return
    (54) statement1 -> . map_assignment
    (55) statement1 -> . map_operation
    (56) statement1 -> . function_call
    (57) statement2 -> . condition
    (58) statement2 -> . while
    (27) assignment -> . ID ASSIGNATOR expression
    (31) input -> . READ ( ID input1 )
    (34) output -> . PRINT ( expression output1 )
    (43) set_operation -> . ID . OPERATION ( set_operation1 )
    (123) map_definition -> . MAP < datatype , datatype >
    (42) return -> . RETURN expression
    (125) map_assignment -> . map_access ASSIGNATOR exp
    (126) map_operation -> . ID . OPERATION ( )
    (37) function_call -> . ID ( function_call1 )
    (28) condition -> . IF ( expression ) block condition1
    (59) while -> . WHILE ( expression ) block
    (124) map_access -> . ID ( exp )

    }               reduce using rule 127 (empty -> .)
    ID              shift and go to state 79
    READ            shift and go to state 61
    PRINT           shift and go to state 66
    MAP             shift and go to state 17
    RETURN          shift and go to state 60
    IF              shift and go to state 81
    WHILE           shift and go to state 65

    map_definition                 shift and go to state 87
    function_call                  shift and go to state 64
    statement_aux                  shift and go to state 207
    map_access                     shift and go to state 70
    statement                      shift and go to state 89
    input                          shift and go to state 73
    empty                          shift and go to state 90
    return                         shift and go to state 77
    statement2                     shift and go to state 69
    statement1                     shift and go to state 75
    assignment                     shift and go to state 76
    map_operation                  shift and go to state 78
    condition                      shift and go to state 80
    set_operation                  shift and go to state 82
    map_assignment                 shift and go to state 62
    while                          shift and go to state 83
    output                         shift and go to state 84

state 192

    (59) while -> WHILE ( expression ) block .

    ID              reduce using rule 59 (while -> WHILE ( expression ) block .)
    READ            reduce using rule 59 (while -> WHILE ( expression ) block .)
    PRINT           reduce using rule 59 (while -> WHILE ( expression ) block .)
    MAP             reduce using rule 59 (while -> WHILE ( expression ) block .)
    RETURN          reduce using rule 59 (while -> WHILE ( expression ) block .)
    IF              reduce using rule 59 (while -> WHILE ( expression ) block .)
    WHILE           reduce using rule 59 (while -> WHILE ( expression ) block .)
    }               reduce using rule 59 (while -> WHILE ( expression ) block .)


state 193

    (34) output -> PRINT ( expression output1 ) .

    ;               reduce using rule 34 (output -> PRINT ( expression output1 ) .)


state 194

    (35) output1 -> , expression . output1
    (35) output1 -> . , expression output1
    (36) output1 -> . empty
    (127) empty -> .

    ,               shift and go to state 173
    )               reduce using rule 127 (empty -> .)

    output1                        shift and go to state 208
    empty                          shift and go to state 174

state 195

    (40) function_call2 -> expression , function_call2 .

    )               reduce using rule 40 (function_call2 -> expression , function_call2 .)


state 196

    (43) set_operation -> ID . OPERATION ( set_operation1 . )

    )               shift and go to state 209


state 197

    (126) map_operation -> ID . OPERATION ( ) .

    ;               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    *               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    /               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    +               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    -               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    <               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    >               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    NOT_EQ          reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    EQ              reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    LEQ             reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    GEQ             reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    OR              reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    AND             reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    )               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)
    ,               reduce using rule 126 (map_operation -> ID . OPERATION ( ) .)


state 198

    (44) set_operation1 -> expression .

    )               reduce using rule 44 (set_operation1 -> expression .)


state 199

    (45) set_operation1 -> empty .
    (89) term_not -> empty .

    )               reduce using rule 45 (set_operation1 -> empty .)
    (               reduce using rule 89 (term_not -> empty .)
    ID              reduce using rule 89 (term_not -> empty .)
    CTE_INT         reduce using rule 89 (term_not -> empty .)
    CTE_FLOAT       reduce using rule 89 (term_not -> empty .)
    CTE_BOOL        reduce using rule 89 (term_not -> empty .)
    CTE_STRING      reduce using rule 89 (term_not -> empty .)
    CTE_CHAR        reduce using rule 89 (term_not -> empty .)


state 200

    (28) condition -> IF ( expression ) block . condition1
    (29) condition1 -> . ELSE block
    (30) condition1 -> . empty
    (127) empty -> .

    ELSE            shift and go to state 210
    ID              reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    MAP             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    }               reduce using rule 127 (empty -> .)

    empty                          shift and go to state 211
    condition1                     shift and go to state 212

state 201

    (90) factor -> ( n_push_false_bottom expression ) . n_pop_false_bottom
    (93) n_pop_false_bottom -> .

    *               reduce using rule 93 (n_pop_false_bottom -> .)
    /               reduce using rule 93 (n_pop_false_bottom -> .)
    +               reduce using rule 93 (n_pop_false_bottom -> .)
    -               reduce using rule 93 (n_pop_false_bottom -> .)
    <               reduce using rule 93 (n_pop_false_bottom -> .)
    >               reduce using rule 93 (n_pop_false_bottom -> .)
    NOT_EQ          reduce using rule 93 (n_pop_false_bottom -> .)
    EQ              reduce using rule 93 (n_pop_false_bottom -> .)
    LEQ             reduce using rule 93 (n_pop_false_bottom -> .)
    GEQ             reduce using rule 93 (n_pop_false_bottom -> .)
    OR              reduce using rule 93 (n_pop_false_bottom -> .)
    AND             reduce using rule 93 (n_pop_false_bottom -> .)
    ;               reduce using rule 93 (n_pop_false_bottom -> .)
    )               reduce using rule 93 (n_pop_false_bottom -> .)
    ,               reduce using rule 93 (n_pop_false_bottom -> .)

    n_pop_false_bottom             shift and go to state 213

state 202

    (85) term2 -> muldiv factor . n_quad_muldiv term2
    (83) n_quad_muldiv -> .

    *               reduce using rule 83 (n_quad_muldiv -> .)
    /               reduce using rule 83 (n_quad_muldiv -> .)
    +               reduce using rule 83 (n_quad_muldiv -> .)
    -               reduce using rule 83 (n_quad_muldiv -> .)
    <               reduce using rule 83 (n_quad_muldiv -> .)
    >               reduce using rule 83 (n_quad_muldiv -> .)
    NOT_EQ          reduce using rule 83 (n_quad_muldiv -> .)
    EQ              reduce using rule 83 (n_quad_muldiv -> .)
    LEQ             reduce using rule 83 (n_quad_muldiv -> .)
    GEQ             reduce using rule 83 (n_quad_muldiv -> .)
    OR              reduce using rule 83 (n_quad_muldiv -> .)
    AND             reduce using rule 83 (n_quad_muldiv -> .)
    ;               reduce using rule 83 (n_quad_muldiv -> .)
    )               reduce using rule 83 (n_quad_muldiv -> .)
    ,               reduce using rule 83 (n_quad_muldiv -> .)

    n_quad_muldiv                  shift and go to state 214

state 203

    (126) map_operation -> ID . OPERATION ( . )
    (43) set_operation -> ID . OPERATION ( . set_operation1 )
    (44) set_operation1 -> . expression
    (45) set_operation1 -> . empty
    (68) expression -> . exp0 expression2
    (127) empty -> .
    (72) exp0 -> . exp exp02
    (75) exp -> . term exp2
    (82) term -> . term_not factor n_quad_muldiv term2
    (88) term_not -> . !
    (89) term_not -> . empty

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 197
    (               reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    CTE_INT         reduce using rule 127 (empty -> .)
    CTE_FLOAT       reduce using rule 127 (empty -> .)
    CTE_BOOL        reduce using rule 127 (empty -> .)
    CTE_STRING      reduce using rule 127 (empty -> .)
    CTE_CHAR        reduce using rule 127 (empty -> .)
    !               shift and go to state 95

  ! )               [ reduce using rule 127 (empty -> .) ]

    term_not                       shift and go to state 92
    set_operation1                 shift and go to state 196
    term                           shift and go to state 93
    exp0                           shift and go to state 94
    exp                            shift and go to state 96
    expression                     shift and go to state 198
    empty                          shift and go to state 199

state 204

    (80) exp2 -> addsub term n_quad_addsub exp2 .

    <               reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    >               reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    NOT_EQ          reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    EQ              reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    LEQ             reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    GEQ             reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    OR              reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    AND             reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    ;               reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    )               reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)
    ,               reduce using rule 80 (exp2 -> addsub term n_quad_addsub exp2 .)


state 205

    (69) expression2 -> logop exp0 n_quad_logop expression2 .

    ;               reduce using rule 69 (expression2 -> logop exp0 n_quad_logop expression2 .)
    )               reduce using rule 69 (expression2 -> logop exp0 n_quad_logop expression2 .)
    ,               reduce using rule 69 (expression2 -> logop exp0 n_quad_logop expression2 .)


state 206

    (32) input1 -> , ID input1 .

    )               reduce using rule 32 (input1 -> , ID input1 .)


state 207

    (116) block -> { statement_aux . }

    }               shift and go to state 215


state 208

    (35) output1 -> , expression output1 .

    )               reduce using rule 35 (output1 -> , expression output1 .)


state 209

    (43) set_operation -> ID . OPERATION ( set_operation1 ) .

    ;               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    *               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    /               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    +               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    -               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    <               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    >               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    NOT_EQ          reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    EQ              reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    LEQ             reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    GEQ             reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    OR              reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    AND             reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    )               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)
    ,               reduce using rule 43 (set_operation -> ID . OPERATION ( set_operation1 ) .)


state 210

    (29) condition1 -> ELSE . block
    (116) block -> . { statement_aux }

    {               shift and go to state 191

    block                          shift and go to state 216

state 211

    (30) condition1 -> empty .

    ID              reduce using rule 30 (condition1 -> empty .)
    READ            reduce using rule 30 (condition1 -> empty .)
    PRINT           reduce using rule 30 (condition1 -> empty .)
    MAP             reduce using rule 30 (condition1 -> empty .)
    RETURN          reduce using rule 30 (condition1 -> empty .)
    IF              reduce using rule 30 (condition1 -> empty .)
    WHILE           reduce using rule 30 (condition1 -> empty .)
    }               reduce using rule 30 (condition1 -> empty .)


state 212

    (28) condition -> IF ( expression ) block condition1 .

    ID              reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    READ            reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    PRINT           reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    MAP             reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    RETURN          reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    IF              reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    WHILE           reduce using rule 28 (condition -> IF ( expression ) block condition1 .)
    }               reduce using rule 28 (condition -> IF ( expression ) block condition1 .)


state 213

    (90) factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .

    *               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    /               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    +               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    -               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    <               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    >               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    NOT_EQ          reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    EQ              reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    LEQ             reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    GEQ             reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    OR              reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    AND             reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ;               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    )               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)
    ,               reduce using rule 90 (factor -> ( n_push_false_bottom expression ) n_pop_false_bottom .)


state 214

    (85) term2 -> muldiv factor n_quad_muldiv . term2
    (85) term2 -> . muldiv factor n_quad_muldiv term2
    (86) term2 -> . n_quad_not
    (78) muldiv -> . *
    (79) muldiv -> . /
    (87) n_quad_not -> .

    *               shift and go to state 182
    /               shift and go to state 184
    +               reduce using rule 87 (n_quad_not -> .)
    -               reduce using rule 87 (n_quad_not -> .)
    <               reduce using rule 87 (n_quad_not -> .)
    >               reduce using rule 87 (n_quad_not -> .)
    NOT_EQ          reduce using rule 87 (n_quad_not -> .)
    EQ              reduce using rule 87 (n_quad_not -> .)
    LEQ             reduce using rule 87 (n_quad_not -> .)
    GEQ             reduce using rule 87 (n_quad_not -> .)
    OR              reduce using rule 87 (n_quad_not -> .)
    AND             reduce using rule 87 (n_quad_not -> .)
    ;               reduce using rule 87 (n_quad_not -> .)
    )               reduce using rule 87 (n_quad_not -> .)
    ,               reduce using rule 87 (n_quad_not -> .)

    term2                          shift and go to state 217
    n_quad_not                     shift and go to state 183
    muldiv                         shift and go to state 185

state 215

    (116) block -> { statement_aux } .

    ID              reduce using rule 116 (block -> { statement_aux } .)
    READ            reduce using rule 116 (block -> { statement_aux } .)
    PRINT           reduce using rule 116 (block -> { statement_aux } .)
    MAP             reduce using rule 116 (block -> { statement_aux } .)
    RETURN          reduce using rule 116 (block -> { statement_aux } .)
    IF              reduce using rule 116 (block -> { statement_aux } .)
    WHILE           reduce using rule 116 (block -> { statement_aux } .)
    }               reduce using rule 116 (block -> { statement_aux } .)
    ELSE            reduce using rule 116 (block -> { statement_aux } .)


state 216

    (29) condition1 -> ELSE block .

    ID              reduce using rule 29 (condition1 -> ELSE block .)
    READ            reduce using rule 29 (condition1 -> ELSE block .)
    PRINT           reduce using rule 29 (condition1 -> ELSE block .)
    MAP             reduce using rule 29 (condition1 -> ELSE block .)
    RETURN          reduce using rule 29 (condition1 -> ELSE block .)
    IF              reduce using rule 29 (condition1 -> ELSE block .)
    WHILE           reduce using rule 29 (condition1 -> ELSE block .)
    }               reduce using rule 29 (condition1 -> ELSE block .)


state 217

    (85) term2 -> muldiv factor n_quad_muldiv term2 .

    +               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    -               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    <               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    >               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    NOT_EQ          reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    EQ              reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    LEQ             reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    GEQ             reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    OR              reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    AND             reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ;               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    )               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)
    ,               reduce using rule 85 (term2 -> muldiv factor n_quad_muldiv term2 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 4 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 4 resolved as shift
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 4 resolved as shift
WARNING: shift/reduce conflict for STRING in state 4 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 4 resolved as shift
WARNING: shift/reduce conflict for SET in state 4 resolved as shift
WARNING: shift/reduce conflict for MAP in state 4 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 12 resolved as shift
WARNING: shift/reduce conflict for INT in state 12 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 12 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 12 resolved as shift
WARNING: shift/reduce conflict for STRING in state 12 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 12 resolved as shift
WARNING: shift/reduce conflict for SET in state 12 resolved as shift
WARNING: shift/reduce conflict for MAP in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 14 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 14 resolved as shift
WARNING: shift/reduce conflict for INT in state 14 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 14 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 14 resolved as shift
WARNING: shift/reduce conflict for STRING in state 14 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 14 resolved as shift
WARNING: shift/reduce conflict for SET in state 14 resolved as shift
WARNING: shift/reduce conflict for MAP in state 14 resolved as shift
WARNING: shift/reduce conflict for MAP in state 46 resolved as shift
WARNING: shift/reduce conflict for MAP in state 57 resolved as shift
WARNING: shift/reduce conflict for ) in state 154 resolved as shift
WARNING: shift/reduce conflict for ) in state 178 resolved as shift
WARNING: shift/reduce conflict for ) in state 203 resolved as shift
